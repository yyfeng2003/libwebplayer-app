// Generated by Construct 3, the game and app creator :: https://www.construct.net
'use strict';
(function(n, e) {
    if ('object' == typeof exports && 'object' == typeof module)
        module.exports = e();
    else if ('function' == typeof define && define.amd)
        define([], e);
    else {
        var t = e();
        for (var r in t)
            ('object' == typeof exports ? exports : n)[r] = t[r]
    }
}
)(this, function() {
    var g = Math.acos
      , a = Math.round
      , _ = Math.min
      , r = Math.floor
      , p = Math.ceil
      , G = Math.sqrt
      , t = Math.pow
      , C = Math.cos
      , B = Math.sin
      , w = Math.max
      , F = Math.abs
      , h = Math.PI;
    return function(n) {
        function i(t) {
            if (e[t])
                return e[t].exports;
            var a = e[t] = {
                i: t,
                l: !1,
                exports: {}
            };
            return n[t].call(a.exports, a, a.exports, i),
            a.l = !0,
            a.exports
        }
        var e = {};
        return i.m = n,
        i.c = e,
        i.d = function(t, e, a) {
            i.o(t, e) || Object.defineProperty(t, e, {
                configurable: !1,
                enumerable: !0,
                get: a
            })
        }
        ,
        i.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t['default']
            }
            : function() {
                return t
            }
            ;
            return i.d(e, 'a', e),
            e
        }
        ,
        i.o = function(a, e) {
            return Object.prototype.hasOwnProperty.call(a, e)
        }
        ,
        i.p = '',
        i(i.s = 4)
    }([function(n, i) {
        'use strict';
        Object.defineProperty(i, '__esModule', {
            value: !0
        }),
        i.setMatrixArrayType = function(a) {
            i.ARRAY_TYPE = t = a
        }
        ,
        i.toRadian = function(t) {
            return t * r
        }
        ,
        i.equals = function(a, e) {
            return F(a - e) <= _ * w(1, F(a), F(e))
        }
        ;
        var _ = i.EPSILON = 1e-6
          , t = i.ARRAY_TYPE = 'undefined' == typeof Float32Array ? Array : Float32Array
          , e = i.RANDOM = Math.random
          , r = h / 180
    }
    , function(n, e, i) {
        'use strict';
        function a(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = e[3]
              , h = e[4]
              , n = e[5]
              , d = e[6]
              , u = e[7]
              , i = e[8]
              , c = t[0]
              , m = t[1]
              , f = t[2]
              , S = t[3]
              , p = t[4]
              , G = t[5]
              , y = t[6]
              , b = t[7]
              , T = t[8];
            return _[0] = c * a + m * l + f * d,
            _[1] = c * r + m * h + f * u,
            _[2] = c * g + m * n + f * i,
            _[3] = S * a + p * l + G * d,
            _[4] = S * r + p * h + G * u,
            _[5] = S * g + p * n + G * i,
            _[6] = y * a + b * l + T * d,
            _[7] = y * r + b * h + T * u,
            _[8] = y * g + b * n + T * i,
            _
        }
        function r(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n[3] = e[3] - t[3],
            n[4] = e[4] - t[4],
            n[5] = e[5] - t[5],
            n[6] = e[6] - t[6],
            n[7] = e[7] - t[7],
            n[8] = e[8] - t[8],
            n
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.sub = e.mul = void 0,
        e.create = function() {
            var t = new g.ARRAY_TYPE(9);
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 1,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 1,
            t
        }
        ,
        e.fromMat4 = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[4],
            a[4] = e[5],
            a[5] = e[6],
            a[6] = e[8],
            a[7] = e[9],
            a[8] = e[10],
            a
        }
        ,
        e.clone = function(a) {
            var e = new g.ARRAY_TYPE(9);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e[3] = a[3],
            e[4] = a[4],
            e[5] = a[5],
            e[6] = a[6],
            e[7] = a[7],
            e[8] = a[8],
            e
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[3],
            a[4] = e[4],
            a[5] = e[5],
            a[6] = e[6],
            a[7] = e[7],
            a[8] = e[8],
            a
        }
        ,
        e.fromValues = function(i, e, t, a, r, _, l, c, n) {
            var d = new g.ARRAY_TYPE(9);
            return d[0] = i,
            d[1] = e,
            d[2] = t,
            d[3] = a,
            d[4] = r,
            d[5] = _,
            d[6] = l,
            d[7] = c,
            d[8] = n,
            d
        }
        ,
        e.set = function(i, e, t, a, r, _, l, c, n, d) {
            return i[0] = e,
            i[1] = t,
            i[2] = a,
            i[3] = r,
            i[4] = _,
            i[5] = l,
            i[6] = c,
            i[7] = n,
            i[8] = d,
            i
        }
        ,
        e.identity = function(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 1,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 1,
            t
        }
        ,
        e.transpose = function(n, e) {
            if (n === e) {
                var t = e[1]
                  , a = e[2]
                  , r = e[5];
                n[1] = e[3],
                n[2] = e[6],
                n[3] = t,
                n[5] = e[7],
                n[6] = a,
                n[7] = r
            } else
                n[0] = e[0],
                n[1] = e[3],
                n[2] = e[6],
                n[3] = e[1],
                n[4] = e[4],
                n[5] = e[7],
                n[6] = e[2],
                n[7] = e[5],
                n[8] = e[8];
            return n
        }
        ,
        e.invert = function(_, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , g = e[3]
              , l = e[4]
              , p = e[5]
              , n = e[6]
              , d = e[7]
              , u = e[8]
              , i = u * l - p * d
              , c = -u * g + p * n
              , m = d * g - l * n
              , h = t * i + a * c + r * m;
            return h ? (h = 1 / h,
            _[0] = i * h,
            _[1] = (-u * a + r * d) * h,
            _[2] = (p * a - r * l) * h,
            _[3] = c * h,
            _[4] = (u * t - r * n) * h,
            _[5] = (-p * t + r * g) * h,
            _[6] = m * h,
            _[7] = (-d * t + a * n) * h,
            _[8] = (l * t - a * g) * h,
            _) : null
        }
        ,
        e.adjoint = function(_, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , c = e[3]
              , l = e[4]
              , g = e[5]
              , n = e[6]
              , d = e[7]
              , u = e[8];
            return _[0] = l * u - g * d,
            _[1] = r * d - a * u,
            _[2] = a * g - r * l,
            _[3] = g * n - c * u,
            _[4] = t * u - r * n,
            _[5] = r * c - t * g,
            _[6] = c * d - l * n,
            _[7] = a * n - t * d,
            _[8] = t * l - a * c,
            _
        }
        ,
        e.determinant = function(i) {
            var e = i[0]
              , t = i[1]
              , a = i[2]
              , r = i[3]
              , _ = i[4]
              , l = i[5]
              , c = i[6]
              , n = i[7]
              , d = i[8];
            return e * (d * _ - l * n) + t * (-d * r + l * c) + a * (n * r - _ * c)
        }
        ,
        e.multiply = a,
        e.translate = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = e[3]
              , p = e[4]
              , n = e[5]
              , d = e[6]
              , u = e[7]
              , i = e[8]
              , c = t[0]
              , m = t[1];
            return _[0] = a,
            _[1] = r,
            _[2] = g,
            _[3] = l,
            _[4] = p,
            _[5] = n,
            _[6] = c * a + m * l + d,
            _[7] = c * r + m * p + u,
            _[8] = c * g + m * n + i,
            _
        }
        ,
        e.rotate = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , d = e[2]
              , l = e[3]
              , n = e[4]
              , i = e[5]
              , u = e[6]
              , c = e[7]
              , g = e[8]
              , m = B(t)
              , p = C(t);
            return _[0] = p * a + m * l,
            _[1] = p * r + m * n,
            _[2] = p * d + m * i,
            _[3] = p * l - m * a,
            _[4] = p * n - m * r,
            _[5] = p * i - m * d,
            _[6] = u,
            _[7] = c,
            _[8] = g,
            _
        }
        ,
        e.scale = function(n, e, t) {
            var a = t[0]
              , r = t[1];
            return n[0] = a * e[0],
            n[1] = a * e[1],
            n[2] = a * e[2],
            n[3] = r * e[3],
            n[4] = r * e[4],
            n[5] = r * e[5],
            n[6] = e[6],
            n[7] = e[7],
            n[8] = e[8],
            n
        }
        ,
        e.fromTranslation = function(a, e) {
            return a[0] = 1,
            a[1] = 0,
            a[2] = 0,
            a[3] = 0,
            a[4] = 1,
            a[5] = 0,
            a[6] = e[0],
            a[7] = e[1],
            a[8] = 1,
            a
        }
        ,
        e.fromRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = a,
            n[1] = t,
            n[2] = 0,
            n[3] = -t,
            n[4] = a,
            n[5] = 0,
            n[6] = 0,
            n[7] = 0,
            n[8] = 1,
            n
        }
        ,
        e.fromScaling = function(a, e) {
            return a[0] = e[0],
            a[1] = 0,
            a[2] = 0,
            a[3] = 0,
            a[4] = e[1],
            a[5] = 0,
            a[6] = 0,
            a[7] = 0,
            a[8] = 1,
            a
        }
        ,
        e.fromMat2d = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = 0,
            a[3] = e[2],
            a[4] = e[3],
            a[5] = 0,
            a[6] = e[4],
            a[7] = e[5],
            a[8] = 1,
            a
        }
        ,
        e.fromQuat = function(_, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , g = e[3]
              , l = t + t
              , h = a + a
              , n = r + r
              , d = t * l
              , u = a * l
              , i = a * h
              , c = r * l
              , m = r * h
              , f = r * n
              , S = g * l
              , p = g * h
              , G = g * n;
            return _[0] = 1 - i - f,
            _[3] = u - G,
            _[6] = c + p,
            _[1] = u + G,
            _[4] = 1 - d - f,
            _[7] = m - S,
            _[2] = c - p,
            _[5] = m + S,
            _[8] = 1 - d - i,
            _
        }
        ,
        e.normalFromMat4 = function(h, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , G = e[3]
              , l = e[4]
              , b = e[5]
              , n = e[6]
              , d = e[7]
              , u = e[8]
              , i = e[9]
              , c = e[10]
              , m = e[11]
              , f = e[12]
              , T = e[13]
              , p = e[14]
              , C = e[15]
              , y = t * b - a * l
              , x = t * n - r * l
              , P = t * d - G * l
              , A = a * n - r * b
              , R = a * d - G * b
              , S = r * d - G * n
              , _ = u * T - i * f
              , E = u * p - c * f
              , I = u * C - m * f
              , D = i * p - c * T
              , B = i * C - m * T
              , g = c * C - m * p
              , k = y * g - x * B + P * D + A * I - R * E + S * _;
            return k ? (k = 1 / k,
            h[0] = (b * g - n * B + d * D) * k,
            h[1] = (n * I - l * g - d * E) * k,
            h[2] = (l * B - b * I + d * _) * k,
            h[3] = (r * B - a * g - G * D) * k,
            h[4] = (t * g - r * I + G * E) * k,
            h[5] = (a * I - t * B - G * _) * k,
            h[6] = (T * S - p * R + C * A) * k,
            h[7] = (p * P - f * S - C * x) * k,
            h[8] = (f * R - T * P + C * y) * k,
            h) : null
        }
        ,
        e.projection = function(n, e, t) {
            return n[0] = 2 / e,
            n[1] = 0,
            n[2] = 0,
            n[3] = 0,
            n[4] = -2 / t,
            n[5] = 0,
            n[6] = -1,
            n[7] = 1,
            n[8] = 1,
            n
        }
        ,
        e.str = function(t) {
            return 'mat3(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ', ' + t[4] + ', ' + t[5] + ', ' + t[6] + ', ' + t[7] + ', ' + t[8] + ')'
        }
        ,
        e.frob = function(a) {
            return G(t(a[0], 2) + t(a[1], 2) + t(a[2], 2) + t(a[3], 2) + t(a[4], 2) + t(a[5], 2) + t(a[6], 2) + t(a[7], 2) + t(a[8], 2))
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n[3] = e[3] + t[3],
            n[4] = e[4] + t[4],
            n[5] = e[5] + t[5],
            n[6] = e[6] + t[6],
            n[7] = e[7] + t[7],
            n[8] = e[8] + t[8],
            n
        }
        ,
        e.subtract = r,
        e.multiplyScalar = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n[3] = e[3] * t,
            n[4] = e[4] * t,
            n[5] = e[5] * t,
            n[6] = e[6] * t,
            n[7] = e[7] * t,
            n[8] = e[8] * t,
            n
        }
        ,
        e.multiplyScalarAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n[3] = e[3] + t[3] * a,
            n[4] = e[4] + t[4] * a,
            n[5] = e[5] + t[5] * a,
            n[6] = e[6] + t[6] * a,
            n[7] = e[7] + t[7] * a,
            n[8] = e[8] + t[8] * a,
            n
        }
        ,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3] && a[4] === e[4] && a[5] === e[5] && a[6] === e[6] && a[7] === e[7] && a[8] === e[8]
        }
        ,
        e.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , _ = i[3]
              , l = i[4]
              , c = i[5]
              , n = i[6]
              , d = i[7]
              , u = i[8]
              , m = e[0]
              , h = e[1]
              , p = e[2]
              , f = e[3]
              , y = e[4]
              , G = e[5]
              , b = e[6]
              , T = e[7]
              , I = e[8];
            return F(t - m) <= g.EPSILON * w(1, F(t), F(m)) && F(a - h) <= g.EPSILON * w(1, F(a), F(h)) && F(r - p) <= g.EPSILON * w(1, F(r), F(p)) && F(_ - f) <= g.EPSILON * w(1, F(_), F(f)) && F(l - y) <= g.EPSILON * w(1, F(l), F(y)) && F(c - G) <= g.EPSILON * w(1, F(c), F(G)) && F(n - b) <= g.EPSILON * w(1, F(n), F(b)) && F(d - T) <= g.EPSILON * w(1, F(d), F(T)) && F(u - I) <= g.EPSILON * w(1, F(u), F(I))
        }
        ;
        var _ = i(0)
          , g = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(_)
          , l = e.mul = a
          , d = e.sub = r
    }
    , function(e, t, n) {
        'use strict';
        function i() {
            var t = new I.ARRAY_TYPE(3);
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t
        }
        function l(n) {
            var e = n[0]
              , t = n[1]
              , a = n[2];
            return G(e * e + t * t + a * a)
        }
        function d(n, e, t) {
            var a = new I.ARRAY_TYPE(3);
            return a[0] = n,
            a[1] = e,
            a[2] = t,
            a
        }
        function u(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n
        }
        function c(n, e, t) {
            return n[0] = e[0] * t[0],
            n[1] = e[1] * t[1],
            n[2] = e[2] * t[2],
            n
        }
        function m(n, e, t) {
            return n[0] = e[0] / t[0],
            n[1] = e[1] / t[1],
            n[2] = e[2] / t[2],
            n
        }
        function f(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1]
              , r = e[2] - n[2];
            return G(t * t + a * a + r * r)
        }
        function y(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1]
              , r = e[2] - n[2];
            return t * t + a * a + r * r
        }
        function P(n) {
            var e = n[0]
              , t = n[1]
              , a = n[2];
            return e * e + t * t + a * a
        }
        function S(n, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , i = t * t + a * a + r * r;
            return 0 < i && (i = 1 / G(i),
            n[0] = e[0] * i,
            n[1] = e[1] * i,
            n[2] = e[2] * i),
            n
        }
        function A(a, e) {
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2]
        }
        Object.defineProperty(t, '__esModule', {
            value: !0
        }),
        t.forEach = t.sqrLen = t.len = t.sqrDist = t.dist = t.div = t.mul = t.sub = void 0,
        t.create = i,
        t.clone = function(a) {
            var e = new I.ARRAY_TYPE(3);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e
        }
        ,
        t.length = l,
        t.fromValues = d,
        t.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a
        }
        ,
        t.set = function(n, e, t, a) {
            return n[0] = e,
            n[1] = t,
            n[2] = a,
            n
        }
        ,
        t.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n
        }
        ,
        t.subtract = u,
        t.multiply = c,
        t.divide = m,
        t.ceil = function(a, e) {
            return a[0] = p(e[0]),
            a[1] = p(e[1]),
            a[2] = p(e[2]),
            a
        }
        ,
        t.floor = function(a, e) {
            return a[0] = r(e[0]),
            a[1] = r(e[1]),
            a[2] = r(e[2]),
            a
        }
        ,
        t.min = function(n, e, t) {
            return n[0] = _(e[0], t[0]),
            n[1] = _(e[1], t[1]),
            n[2] = _(e[2], t[2]),
            n
        }
        ,
        t.max = function(n, e, t) {
            return n[0] = w(e[0], t[0]),
            n[1] = w(e[1], t[1]),
            n[2] = w(e[2], t[2]),
            n
        }
        ,
        t.round = function(t, e) {
            return t[0] = a(e[0]),
            t[1] = a(e[1]),
            t[2] = a(e[2]),
            t
        }
        ,
        t.scale = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n
        }
        ,
        t.scaleAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n
        }
        ,
        t.distance = f,
        t.squaredDistance = y,
        t.squaredLength = P,
        t.negate = function(a, e) {
            return a[0] = -e[0],
            a[1] = -e[1],
            a[2] = -e[2],
            a
        }
        ,
        t.inverse = function(a, e) {
            return a[0] = 1 / e[0],
            a[1] = 1 / e[1],
            a[2] = 1 / e[2],
            a
        }
        ,
        t.normalize = S,
        t.dot = A,
        t.cross = function(i, e, t) {
            var a = e[0]
              , r = e[1]
              , _ = e[2]
              , l = t[0]
              , u = t[1]
              , n = t[2];
            return i[0] = r * n - _ * u,
            i[1] = _ * l - a * n,
            i[2] = a * u - r * l,
            i
        }
        ,
        t.lerp = function(n, e, r, a) {
            var i = e[0]
              , t = e[1]
              , l = e[2];
            return n[0] = i + a * (r[0] - i),
            n[1] = t + a * (r[1] - t),
            n[2] = l + a * (r[2] - l),
            n
        }
        ,
        t.hermite = function(_, e, r, a, c, l) {
            var g = l * l
              , t = g * (2 * l - 3) + 1
              , n = g * (l - 2) + l
              , d = g * (l - 1)
              , u = g * (3 - 2 * l);
            return _[0] = e[0] * t + r[0] * n + a[0] * d + c[0] * u,
            _[1] = e[1] * t + r[1] * n + a[1] * d + c[1] * u,
            _[2] = e[2] * t + r[2] * n + a[2] * d + c[2] * u,
            _
        }
        ,
        t.bezier = function(_, e, r, a, g, l) {
            var p = 1 - l
              , t = p * p
              , n = l * l
              , d = t * p
              , u = 3 * l * t
              , i = 3 * n * p
              , c = n * l;
            return _[0] = e[0] * d + r[0] * u + a[0] * i + g[0] * c,
            _[1] = e[1] * d + r[1] * u + a[1] * i + g[1] * c,
            _[2] = e[2] * d + r[2] * u + a[2] * i + g[2] * c,
            _
        }
        ,
        t.random = function(n, e) {
            e = e || 1;
            var i = 2 * I.RANDOM() * h
              , a = 2 * I.RANDOM() - 1
              , r = G(1 - a * a) * e;
            return n[0] = C(i) * r,
            n[1] = B(i) * r,
            n[2] = a * e,
            n
        }
        ,
        t.transformMat4 = function(n, e, t) {
            var a = e[0]
              , r = e[1]
              , i = e[2]
              , l = t[3] * a + t[7] * r + t[11] * i + t[15];
            return l = l || 1,
            n[0] = (t[0] * a + t[4] * r + t[8] * i + t[12]) / l,
            n[1] = (t[1] * a + t[5] * r + t[9] * i + t[13]) / l,
            n[2] = (t[2] * a + t[6] * r + t[10] * i + t[14]) / l,
            n
        }
        ,
        t.transformMat3 = function(n, e, t) {
            var a = e[0]
              , r = e[1]
              , i = e[2];
            return n[0] = a * t[0] + r * t[3] + i * t[6],
            n[1] = a * t[1] + r * t[4] + i * t[7],
            n[2] = a * t[2] + r * t[5] + i * t[8],
            n
        }
        ,
        t.transformQuat = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = t[0]
              , p = t[1]
              , n = t[2]
              , d = t[3]
              , u = d * a + p * g - n * r
              , i = d * r + n * a - l * g
              , c = d * g + l * r - p * a
              , m = -l * a - p * r - n * g;
            return _[0] = u * d + m * -l + i * -n - c * -p,
            _[1] = i * d + m * -p + c * -l - u * -n,
            _[2] = c * d + m * -n + u * -p - i * -l,
            _
        }
        ,
        t.rotateX = function(n, e, t, a) {
            var r = []
              , i = [];
            return r[0] = e[0] - t[0],
            r[1] = e[1] - t[1],
            r[2] = e[2] - t[2],
            i[0] = r[0],
            i[1] = r[1] * C(a) - r[2] * B(a),
            i[2] = r[1] * B(a) + r[2] * C(a),
            n[0] = i[0] + t[0],
            n[1] = i[1] + t[1],
            n[2] = i[2] + t[2],
            n
        }
        ,
        t.rotateY = function(n, e, t, a) {
            var r = []
              , i = [];
            return r[0] = e[0] - t[0],
            r[1] = e[1] - t[1],
            r[2] = e[2] - t[2],
            i[0] = r[2] * B(a) + r[0] * C(a),
            i[1] = r[1],
            i[2] = r[2] * C(a) - r[0] * B(a),
            n[0] = i[0] + t[0],
            n[1] = i[1] + t[1],
            n[2] = i[2] + t[2],
            n
        }
        ,
        t.rotateZ = function(n, e, t, a) {
            var r = []
              , i = [];
            return r[0] = e[0] - t[0],
            r[1] = e[1] - t[1],
            r[2] = e[2] - t[2],
            i[0] = r[0] * C(a) - r[1] * B(a),
            i[1] = r[0] * B(a) + r[1] * C(a),
            i[2] = r[2],
            n[0] = i[0] + t[0],
            n[1] = i[1] + t[1],
            n[2] = i[2] + t[2],
            n
        }
        ,
        t.angle = function(e, t) {
            var a = d(e[0], e[1], e[2])
              , n = d(t[0], t[1], t[2]);
            S(a, a),
            S(n, n);
            var r = A(a, n);
            return 1 < r ? 0 : -1 > r ? h : g(r)
        }
        ,
        t.str = function(t) {
            return 'vec3(' + t[0] + ', ' + t[1] + ', ' + t[2] + ')'
        }
        ,
        t.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2]
        }
        ,
        t.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , _ = e[0]
              , l = e[1]
              , d = e[2];
            return F(t - _) <= I.EPSILON * w(1, F(t), F(_)) && F(a - l) <= I.EPSILON * w(1, F(a), F(l)) && F(r - d) <= I.EPSILON * w(1, F(r), F(d))
        }
        ;
        var R = n(0)
          , I = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(R)
          , E = t.sub = u
          , D = t.mul = c
          , k = t.div = m
          , L = t.dist = f
          , v = t.sqrDist = y
          , O = t.len = l
          , T = t.sqrLen = P
          , b = t.forEach = function() {
            var r = i();
            return function(e, t, l, c, g, n) {
                var d, m;
                for (t || (t = 3),
                l || (l = 0),
                m = c ? _(c * t + l, e.length) : e.length,
                d = l; d < m; d += t)
                    r[0] = e[d],
                    r[1] = e[d + 1],
                    r[2] = e[d + 2],
                    g(r, r, n),
                    e[d] = r[0],
                    e[d + 1] = r[1],
                    e[d + 2] = r[2];
                return e
            }
        }()
    }
    , function(t, e, n) {
        'use strict';
        function i() {
            var t = new C.ARRAY_TYPE(4);
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t
        }
        function l(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n[3] = e[3] - t[3],
            n
        }
        function d(n, e, t) {
            return n[0] = e[0] * t[0],
            n[1] = e[1] * t[1],
            n[2] = e[2] * t[2],
            n[3] = e[3] * t[3],
            n
        }
        function u(n, e, t) {
            return n[0] = e[0] / t[0],
            n[1] = e[1] / t[1],
            n[2] = e[2] / t[2],
            n[3] = e[3] / t[3],
            n
        }
        function c(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n[3] = e[3] * t,
            n
        }
        function m(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1]
              , r = e[2] - n[2]
              , i = e[3] - n[3];
            return G(t * t + a * a + r * r + i * i)
        }
        function h(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1]
              , r = e[2] - n[2]
              , i = e[3] - n[3];
            return t * t + a * a + r * r + i * i
        }
        function f(n) {
            var e = n[0]
              , t = n[1]
              , a = n[2]
              , r = n[3];
            return G(e * e + t * t + a * a + r * r)
        }
        function y(n) {
            var e = n[0]
              , t = n[1]
              , a = n[2]
              , r = n[3];
            return e * e + t * t + a * a + r * r
        }
        function b(n, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , i = e[3]
              , l = t * t + a * a + r * r + i * i;
            return 0 < l && (l = 1 / G(l),
            n[0] = t * l,
            n[1] = a * l,
            n[2] = r * l,
            n[3] = i * l),
            n
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.forEach = e.sqrLen = e.len = e.sqrDist = e.dist = e.div = e.mul = e.sub = void 0,
        e.create = i,
        e.clone = function(a) {
            var e = new C.ARRAY_TYPE(4);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e[3] = a[3],
            e
        }
        ,
        e.fromValues = function(n, e, t, a) {
            var r = new C.ARRAY_TYPE(4);
            return r[0] = n,
            r[1] = e,
            r[2] = t,
            r[3] = a,
            r
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[3],
            a
        }
        ,
        e.set = function(n, e, t, a, r) {
            return n[0] = e,
            n[1] = t,
            n[2] = a,
            n[3] = r,
            n
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n[3] = e[3] + t[3],
            n
        }
        ,
        e.subtract = l,
        e.multiply = d,
        e.divide = u,
        e.ceil = function(a, e) {
            return a[0] = p(e[0]),
            a[1] = p(e[1]),
            a[2] = p(e[2]),
            a[3] = p(e[3]),
            a
        }
        ,
        e.floor = function(a, e) {
            return a[0] = r(e[0]),
            a[1] = r(e[1]),
            a[2] = r(e[2]),
            a[3] = r(e[3]),
            a
        }
        ,
        e.min = function(n, e, t) {
            return n[0] = _(e[0], t[0]),
            n[1] = _(e[1], t[1]),
            n[2] = _(e[2], t[2]),
            n[3] = _(e[3], t[3]),
            n
        }
        ,
        e.max = function(n, e, t) {
            return n[0] = w(e[0], t[0]),
            n[1] = w(e[1], t[1]),
            n[2] = w(e[2], t[2]),
            n[3] = w(e[3], t[3]),
            n
        }
        ,
        e.round = function(t, e) {
            return t[0] = a(e[0]),
            t[1] = a(e[1]),
            t[2] = a(e[2]),
            t[3] = a(e[3]),
            t
        }
        ,
        e.scale = c,
        e.scaleAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n[3] = e[3] + t[3] * a,
            n
        }
        ,
        e.distance = m,
        e.squaredDistance = h,
        e.length = f,
        e.squaredLength = y,
        e.negate = function(a, e) {
            return a[0] = -e[0],
            a[1] = -e[1],
            a[2] = -e[2],
            a[3] = -e[3],
            a
        }
        ,
        e.inverse = function(a, e) {
            return a[0] = 1 / e[0],
            a[1] = 1 / e[1],
            a[2] = 1 / e[2],
            a[3] = 1 / e[3],
            a
        }
        ,
        e.normalize = b,
        e.dot = function(a, e) {
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] * e[3]
        }
        ,
        e.lerp = function(i, e, r, a) {
            var _ = e[0]
              , t = e[1]
              , l = e[2]
              , d = e[3];
            return i[0] = _ + a * (r[0] - _),
            i[1] = t + a * (r[1] - t),
            i[2] = l + a * (r[2] - l),
            i[3] = d + a * (r[3] - d),
            i
        }
        ,
        e.random = function(a, e) {
            return e = e || 1,
            a[0] = C.RANDOM(),
            a[1] = C.RANDOM(),
            a[2] = C.RANDOM(),
            a[3] = C.RANDOM(),
            b(a, a),
            c(a, a, e),
            a
        }
        ,
        e.transformMat4 = function(n, e, t) {
            var a = e[0]
              , r = e[1]
              , i = e[2]
              , l = e[3];
            return n[0] = t[0] * a + t[4] * r + t[8] * i + t[12] * l,
            n[1] = t[1] * a + t[5] * r + t[9] * i + t[13] * l,
            n[2] = t[2] * a + t[6] * r + t[10] * i + t[14] * l,
            n[3] = t[3] * a + t[7] * r + t[11] * i + t[15] * l,
            n
        }
        ,
        e.transformQuat = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = t[0]
              , p = t[1]
              , n = t[2]
              , d = t[3]
              , u = d * a + p * g - n * r
              , i = d * r + n * a - l * g
              , c = d * g + l * r - p * a
              , m = -l * a - p * r - n * g;
            return _[0] = u * d + m * -l + i * -n - c * -p,
            _[1] = i * d + m * -p + c * -l - u * -n,
            _[2] = c * d + m * -n + u * -p - i * -l,
            _[3] = e[3],
            _
        }
        ,
        e.str = function(t) {
            return 'vec4(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ')'
        }
        ,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3]
        }
        ,
        e.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , _ = i[3]
              , l = e[0]
              , c = e[1]
              , n = e[2]
              , d = e[3];
            return F(t - l) <= C.EPSILON * w(1, F(t), F(l)) && F(a - c) <= C.EPSILON * w(1, F(a), F(c)) && F(r - n) <= C.EPSILON * w(1, F(r), F(n)) && F(_ - d) <= C.EPSILON * w(1, F(_), F(d))
        }
        ;
        var T = n(0)
          , C = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(T)
          , v = e.sub = l
          , S = e.mul = d
          , x = e.div = u
          , P = e.dist = m
          , I = e.sqrDist = h
          , A = e.len = f
          , R = e.sqrLen = y
          , g = e.forEach = function() {
            var r = i();
            return function(e, t, l, c, g, n) {
                var d, m;
                for (t || (t = 4),
                l || (l = 0),
                m = c ? _(c * t + l, e.length) : e.length,
                d = l; d < m; d += t)
                    r[0] = e[d],
                    r[1] = e[d + 1],
                    r[2] = e[d + 2],
                    r[3] = e[d + 3],
                    g(r, r, n),
                    e[d] = r[0],
                    e[d + 1] = r[1],
                    e[d + 2] = r[2],
                    e[d + 3] = r[3];
                return e
            }
        }()
    }
    , function(_, e, t) {
        'use strict';
        function a(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.vec4 = e.vec3 = e.vec2 = e.quat = e.mat4 = e.mat3 = e.mat2d = e.mat2 = e.glMatrix = void 0;
        var r = t(0)
          , g = a(r)
          , l = t(5)
          , h = a(l)
          , n = t(6)
          , d = a(n)
          , u = t(1)
          , i = a(u)
          , c = t(7)
          , m = a(c)
          , f = t(8)
          , S = a(f)
          , p = t(9)
          , G = a(p)
          , y = t(2)
          , b = a(y)
          , T = t(3)
          , I = a(T);
        e.glMatrix = g,
        e.mat2 = h,
        e.mat2d = d,
        e.mat3 = i,
        e.mat4 = m,
        e.quat = S,
        e.vec2 = G,
        e.vec3 = b,
        e.vec4 = I
    }
    , function(n, e, i) {
        'use strict';
        function a(_, e, t) {
            var a = e[0]
              , r = e[1]
              , c = e[2]
              , l = e[3]
              , g = t[0]
              , n = t[1]
              , d = t[2]
              , u = t[3];
            return _[0] = a * g + c * n,
            _[1] = r * g + l * n,
            _[2] = a * d + c * u,
            _[3] = r * d + l * u,
            _
        }
        function r(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n[3] = e[3] - t[3],
            n
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.sub = e.mul = void 0,
        e.create = function() {
            var t = new g.ARRAY_TYPE(4);
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        ,
        e.clone = function(a) {
            var e = new g.ARRAY_TYPE(4);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e[3] = a[3],
            e
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[3],
            a
        }
        ,
        e.identity = function(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        ,
        e.fromValues = function(n, e, t, a) {
            var r = new g.ARRAY_TYPE(4);
            return r[0] = n,
            r[1] = e,
            r[2] = t,
            r[3] = a,
            r
        }
        ,
        e.set = function(n, e, t, a, r) {
            return n[0] = e,
            n[1] = t,
            n[2] = a,
            n[3] = r,
            n
        }
        ,
        e.transpose = function(n, e) {
            if (n === e) {
                var t = e[1];
                n[1] = e[2],
                n[2] = t
            } else
                n[0] = e[0],
                n[1] = e[2],
                n[2] = e[1],
                n[3] = e[3];
            return n
        }
        ,
        e.invert = function(n, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , i = e[3]
              , l = t * i - r * a;
            return l ? (l = 1 / l,
            n[0] = i * l,
            n[1] = -a * l,
            n[2] = -r * l,
            n[3] = t * l,
            n) : null
        }
        ,
        e.adjoint = function(n, e) {
            var t = e[0];
            return n[0] = e[3],
            n[1] = -e[1],
            n[2] = -e[2],
            n[3] = t,
            n
        }
        ,
        e.determinant = function(t) {
            return t[0] * t[3] - t[2] * t[1]
        }
        ,
        e.multiply = a,
        e.rotate = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , d = e[2]
              , l = e[3]
              , n = B(t)
              , i = C(t);
            return _[0] = a * i + d * n,
            _[1] = r * i + l * n,
            _[2] = a * -n + d * i,
            _[3] = r * -n + l * i,
            _
        }
        ,
        e.scale = function(i, e, t) {
            var a = e[0]
              , r = e[1]
              , _ = e[2]
              , l = e[3]
              , u = t[0]
              , n = t[1];
            return i[0] = a * u,
            i[1] = r * u,
            i[2] = _ * n,
            i[3] = l * n,
            i
        }
        ,
        e.fromRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = a,
            n[1] = t,
            n[2] = -t,
            n[3] = a,
            n
        }
        ,
        e.fromScaling = function(a, e) {
            return a[0] = e[0],
            a[1] = 0,
            a[2] = 0,
            a[3] = e[1],
            a
        }
        ,
        e.str = function(t) {
            return 'mat2(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ')'
        }
        ,
        e.frob = function(a) {
            return G(t(a[0], 2) + t(a[1], 2) + t(a[2], 2) + t(a[3], 2))
        }
        ,
        e.LDU = function(a, e, t, n) {
            return a[2] = n[2] / n[0],
            t[0] = n[0],
            t[1] = n[1],
            t[3] = n[3] - a[2] * t[1],
            [a, e, t]
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n[3] = e[3] + t[3],
            n
        }
        ,
        e.subtract = r,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3]
        }
        ,
        e.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , _ = i[3]
              , l = e[0]
              , c = e[1]
              , n = e[2]
              , d = e[3];
            return F(t - l) <= g.EPSILON * w(1, F(t), F(l)) && F(a - c) <= g.EPSILON * w(1, F(a), F(c)) && F(r - n) <= g.EPSILON * w(1, F(r), F(n)) && F(_ - d) <= g.EPSILON * w(1, F(_), F(d))
        }
        ,
        e.multiplyScalar = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n[3] = e[3] * t,
            n
        }
        ,
        e.multiplyScalarAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n[3] = e[3] + t[3] * a,
            n
        }
        ;
        var _ = i(0)
          , g = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(_)
          , l = e.mul = a
          , d = e.sub = r
    }
    , function(n, e, i) {
        'use strict';
        function a(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = e[3]
              , p = e[4]
              , n = e[5]
              , d = t[0]
              , u = t[1]
              , i = t[2]
              , c = t[3]
              , m = t[4]
              , h = t[5];
            return _[0] = a * d + g * u,
            _[1] = r * d + l * u,
            _[2] = a * i + g * c,
            _[3] = r * i + l * c,
            _[4] = a * m + g * h + p,
            _[5] = r * m + l * h + n,
            _
        }
        function r(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n[3] = e[3] - t[3],
            n[4] = e[4] - t[4],
            n[5] = e[5] - t[5],
            n
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.sub = e.mul = void 0,
        e.create = function() {
            var t = new g.ARRAY_TYPE(6);
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t[4] = 0,
            t[5] = 0,
            t
        }
        ,
        e.clone = function(a) {
            var e = new g.ARRAY_TYPE(6);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e[3] = a[3],
            e[4] = a[4],
            e[5] = a[5],
            e
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[3],
            a[4] = e[4],
            a[5] = e[5],
            a
        }
        ,
        e.identity = function(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t[4] = 0,
            t[5] = 0,
            t
        }
        ,
        e.fromValues = function(n, e, t, a, r, i) {
            var l = new g.ARRAY_TYPE(6);
            return l[0] = n,
            l[1] = e,
            l[2] = t,
            l[3] = a,
            l[4] = r,
            l[5] = i,
            l
        }
        ,
        e.set = function(n, e, t, a, r, i, l) {
            return n[0] = e,
            n[1] = t,
            n[2] = a,
            n[3] = r,
            n[4] = i,
            n[5] = l,
            n
        }
        ,
        e.invert = function(i, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , _ = e[3]
              , l = e[4]
              , u = e[5]
              , n = t * _ - a * r;
            return n ? (n = 1 / n,
            i[0] = _ * n,
            i[1] = -a * n,
            i[2] = -r * n,
            i[3] = t * n,
            i[4] = (r * u - _ * l) * n,
            i[5] = (a * l - t * u) * n,
            i) : null
        }
        ,
        e.determinant = function(t) {
            return t[0] * t[3] - t[1] * t[2]
        }
        ,
        e.multiply = a,
        e.rotate = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , d = e[2]
              , l = e[3]
              , n = e[4]
              , i = e[5]
              , u = B(t)
              , c = C(t);
            return _[0] = a * c + d * u,
            _[1] = r * c + l * u,
            _[2] = a * -u + d * c,
            _[3] = r * -u + l * c,
            _[4] = n,
            _[5] = i,
            _
        }
        ,
        e.scale = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , c = e[2]
              , l = e[3]
              , g = e[4]
              , n = e[5]
              , d = t[0]
              , u = t[1];
            return _[0] = a * d,
            _[1] = r * d,
            _[2] = c * u,
            _[3] = l * u,
            _[4] = g,
            _[5] = n,
            _
        }
        ,
        e.translate = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , c = e[2]
              , l = e[3]
              , g = e[4]
              , n = e[5]
              , d = t[0]
              , u = t[1];
            return _[0] = a,
            _[1] = r,
            _[2] = c,
            _[3] = l,
            _[4] = a * d + c * u + g,
            _[5] = r * d + l * u + n,
            _
        }
        ,
        e.fromRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = a,
            n[1] = t,
            n[2] = -t,
            n[3] = a,
            n[4] = 0,
            n[5] = 0,
            n
        }
        ,
        e.fromScaling = function(a, e) {
            return a[0] = e[0],
            a[1] = 0,
            a[2] = 0,
            a[3] = e[1],
            a[4] = 0,
            a[5] = 0,
            a
        }
        ,
        e.fromTranslation = function(a, e) {
            return a[0] = 1,
            a[1] = 0,
            a[2] = 0,
            a[3] = 1,
            a[4] = e[0],
            a[5] = e[1],
            a
        }
        ,
        e.str = function(t) {
            return 'mat2d(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ', ' + t[4] + ', ' + t[5] + ')'
        }
        ,
        e.frob = function(a) {
            return G(t(a[0], 2) + t(a[1], 2) + t(a[2], 2) + t(a[3], 2) + t(a[4], 2) + t(a[5], 2) + 1)
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n[3] = e[3] + t[3],
            n[4] = e[4] + t[4],
            n[5] = e[5] + t[5],
            n
        }
        ,
        e.subtract = r,
        e.multiplyScalar = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n[3] = e[3] * t,
            n[4] = e[4] * t,
            n[5] = e[5] * t,
            n
        }
        ,
        e.multiplyScalarAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n[3] = e[3] + t[3] * a,
            n[4] = e[4] + t[4] * a,
            n[5] = e[5] + t[5] * a,
            n
        }
        ,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3] && a[4] === e[4] && a[5] === e[5]
        }
        ,
        e.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , _ = i[3]
              , l = i[4]
              , m = i[5]
              , n = e[0]
              , d = e[1]
              , u = e[2]
              , c = e[3]
              , h = e[4]
              , p = e[5];
            return F(t - n) <= g.EPSILON * w(1, F(t), F(n)) && F(a - d) <= g.EPSILON * w(1, F(a), F(d)) && F(r - u) <= g.EPSILON * w(1, F(r), F(u)) && F(_ - c) <= g.EPSILON * w(1, F(_), F(c)) && F(l - h) <= g.EPSILON * w(1, F(l), F(h)) && F(m - p) <= g.EPSILON * w(1, F(m), F(p))
        }
        ;
        var _ = i(0)
          , g = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(_)
          , l = e.mul = a
          , d = e.sub = r
    }
    , function(n, e, i) {
        'use strict';
        function a(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = e[3]
              , h = e[4]
              , n = e[5]
              , d = e[6]
              , u = e[7]
              , i = e[8]
              , c = e[9]
              , m = e[10]
              , f = e[11]
              , G = e[12]
              , p = e[13]
              , b = e[14]
              , y = e[15]
              , T = t[0]
              , I = t[1]
              , C = t[2]
              , v = t[3];
            return _[0] = T * a + I * h + C * i + v * G,
            _[1] = T * r + I * n + C * c + v * p,
            _[2] = T * g + I * d + C * m + v * b,
            _[3] = T * l + I * u + C * f + v * y,
            T = t[4],
            I = t[5],
            C = t[6],
            v = t[7],
            _[4] = T * a + I * h + C * i + v * G,
            _[5] = T * r + I * n + C * c + v * p,
            _[6] = T * g + I * d + C * m + v * b,
            _[7] = T * l + I * u + C * f + v * y,
            T = t[8],
            I = t[9],
            C = t[10],
            v = t[11],
            _[8] = T * a + I * h + C * i + v * G,
            _[9] = T * r + I * n + C * c + v * p,
            _[10] = T * g + I * d + C * m + v * b,
            _[11] = T * l + I * u + C * f + v * y,
            T = t[12],
            I = t[13],
            C = t[14],
            v = t[15],
            _[12] = T * a + I * h + C * i + v * G,
            _[13] = T * r + I * n + C * c + v * p,
            _[14] = T * g + I * d + C * m + v * b,
            _[15] = T * l + I * u + C * f + v * y,
            _
        }
        function r(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n[2] = e[2] - t[2],
            n[3] = e[3] - t[3],
            n[4] = e[4] - t[4],
            n[5] = e[5] - t[5],
            n[6] = e[6] - t[6],
            n[7] = e[7] - t[7],
            n[8] = e[8] - t[8],
            n[9] = e[9] - t[9],
            n[10] = e[10] - t[10],
            n[11] = e[11] - t[11],
            n[12] = e[12] - t[12],
            n[13] = e[13] - t[13],
            n[14] = e[14] - t[14],
            n[15] = e[15] - t[15],
            n
        }
        var _ = Math.tan;
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.sub = e.mul = void 0,
        e.create = function() {
            var t = new W.ARRAY_TYPE(16);
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = 1,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 1,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        ,
        e.clone = function(a) {
            var e = new W.ARRAY_TYPE(16);
            return e[0] = a[0],
            e[1] = a[1],
            e[2] = a[2],
            e[3] = a[3],
            e[4] = a[4],
            e[5] = a[5],
            e[6] = a[6],
            e[7] = a[7],
            e[8] = a[8],
            e[9] = a[9],
            e[10] = a[10],
            e[11] = a[11],
            e[12] = a[12],
            e[13] = a[13],
            e[14] = a[14],
            e[15] = a[15],
            e
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a[2] = e[2],
            a[3] = e[3],
            a[4] = e[4],
            a[5] = e[5],
            a[6] = e[6],
            a[7] = e[7],
            a[8] = e[8],
            a[9] = e[9],
            a[10] = e[10],
            a[11] = e[11],
            a[12] = e[12],
            a[13] = e[13],
            a[14] = e[14],
            a[15] = e[15],
            a
        }
        ,
        e.fromValues = function(_, e, t, a, r, g, l, h, n, d, u, i, c, m, f, p) {
            var S = new W.ARRAY_TYPE(16);
            return S[0] = _,
            S[1] = e,
            S[2] = t,
            S[3] = a,
            S[4] = r,
            S[5] = g,
            S[6] = l,
            S[7] = h,
            S[8] = n,
            S[9] = d,
            S[10] = u,
            S[11] = i,
            S[12] = c,
            S[13] = m,
            S[14] = f,
            S[15] = p,
            S
        }
        ,
        e.set = function(_, e, t, a, r, g, l, h, n, d, u, i, c, m, f, S, p) {
            return _[0] = e,
            _[1] = t,
            _[2] = a,
            _[3] = r,
            _[4] = g,
            _[5] = l,
            _[6] = h,
            _[7] = n,
            _[8] = d,
            _[9] = u,
            _[10] = i,
            _[11] = c,
            _[12] = m,
            _[13] = f,
            _[14] = S,
            _[15] = p,
            _
        }
        ,
        e.identity = function(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = 1,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 1,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        ,
        e.transpose = function(i, e) {
            if (i === e) {
                var t = e[1]
                  , a = e[2]
                  , r = e[3]
                  , _ = e[6]
                  , l = e[7]
                  , d = e[11];
                i[1] = e[4],
                i[2] = e[8],
                i[3] = e[12],
                i[4] = t,
                i[6] = e[9],
                i[7] = e[13],
                i[8] = a,
                i[9] = _,
                i[11] = e[14],
                i[12] = r,
                i[13] = l,
                i[14] = d
            } else
                i[0] = e[0],
                i[1] = e[4],
                i[2] = e[8],
                i[3] = e[12],
                i[4] = e[1],
                i[5] = e[5],
                i[6] = e[9],
                i[7] = e[13],
                i[8] = e[2],
                i[9] = e[6],
                i[10] = e[10],
                i[11] = e[14],
                i[12] = e[3],
                i[13] = e[7],
                i[14] = e[11],
                i[15] = e[15];
            return i
        }
        ,
        e.invert = function(h, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , G = e[3]
              , l = e[4]
              , b = e[5]
              , n = e[6]
              , d = e[7]
              , u = e[8]
              , i = e[9]
              , c = e[10]
              , m = e[11]
              , f = e[12]
              , T = e[13]
              , p = e[14]
              , C = e[15]
              , y = t * b - a * l
              , x = t * n - r * l
              , P = t * d - G * l
              , A = a * n - r * b
              , R = a * d - G * b
              , S = r * d - G * n
              , _ = u * T - i * f
              , E = u * p - c * f
              , I = u * C - m * f
              , D = i * p - c * T
              , B = i * C - m * T
              , g = c * C - m * p
              , k = y * g - x * B + P * D + A * I - R * E + S * _;
            return k ? (k = 1 / k,
            h[0] = (b * g - n * B + d * D) * k,
            h[1] = (r * B - a * g - G * D) * k,
            h[2] = (T * S - p * R + C * A) * k,
            h[3] = (c * R - i * S - m * A) * k,
            h[4] = (n * I - l * g - d * E) * k,
            h[5] = (t * g - r * I + G * E) * k,
            h[6] = (p * P - f * S - C * x) * k,
            h[7] = (u * S - c * P + m * x) * k,
            h[8] = (l * B - b * I + d * _) * k,
            h[9] = (a * I - t * B - G * _) * k,
            h[10] = (f * R - T * P + C * y) * k,
            h[11] = (i * P - u * R - m * y) * k,
            h[12] = (b * E - l * D - n * _) * k,
            h[13] = (t * D - a * E + r * _) * k,
            h[14] = (T * x - f * A - p * y) * k,
            h[15] = (u * A - i * x + c * y) * k,
            h) : null
        }
        ,
        e.adjoint = function(_, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , g = e[3]
              , l = e[4]
              , h = e[5]
              , n = e[6]
              , d = e[7]
              , u = e[8]
              , i = e[9]
              , c = e[10]
              , m = e[11]
              , f = e[12]
              , S = e[13]
              , p = e[14]
              , G = e[15];
            return _[0] = h * (c * G - m * p) - i * (n * G - d * p) + S * (n * m - d * c),
            _[1] = -(a * (c * G - m * p) - i * (r * G - g * p) + S * (r * m - g * c)),
            _[2] = a * (n * G - d * p) - h * (r * G - g * p) + S * (r * d - g * n),
            _[3] = -(a * (n * m - d * c) - h * (r * m - g * c) + i * (r * d - g * n)),
            _[4] = -(l * (c * G - m * p) - u * (n * G - d * p) + f * (n * m - d * c)),
            _[5] = t * (c * G - m * p) - u * (r * G - g * p) + f * (r * m - g * c),
            _[6] = -(t * (n * G - d * p) - l * (r * G - g * p) + f * (r * d - g * n)),
            _[7] = t * (n * m - d * c) - l * (r * m - g * c) + u * (r * d - g * n),
            _[8] = l * (i * G - m * S) - u * (h * G - d * S) + f * (h * m - d * i),
            _[9] = -(t * (i * G - m * S) - u * (a * G - g * S) + f * (a * m - g * i)),
            _[10] = t * (h * G - d * S) - l * (a * G - g * S) + f * (a * d - g * h),
            _[11] = -(t * (h * m - d * i) - l * (a * m - g * i) + u * (a * d - g * h)),
            _[12] = -(l * (i * p - c * S) - u * (h * p - n * S) + f * (h * c - n * i)),
            _[13] = t * (i * p - c * S) - u * (a * p - r * S) + f * (a * c - r * i),
            _[14] = -(t * (h * p - n * S) - l * (a * p - r * S) + f * (a * n - r * h)),
            _[15] = t * (h * c - n * i) - l * (a * c - r * i) + u * (a * n - r * h),
            _
        }
        ,
        e.determinant = function(_) {
            var e = _[0]
              , t = _[1]
              , a = _[2]
              , r = _[3]
              , g = _[4]
              , l = _[5]
              , h = _[6]
              , n = _[7]
              , d = _[8]
              , u = _[9]
              , i = _[10]
              , c = _[11]
              , m = _[12]
              , f = _[13]
              , S = _[14]
              , p = _[15];
            return (e * l - t * g) * (i * p - c * S) - (e * h - a * g) * (u * p - c * f) + (e * n - r * g) * (u * S - i * f) + (t * h - a * l) * (d * p - c * m) - (t * n - r * l) * (d * S - i * m) + (a * n - r * h) * (d * f - u * m)
        }
        ,
        e.multiply = a,
        e.translate = function(_, e, t) {
            var a = t[0], r = t[1], g = t[2], l, h, S, G, b, T, I, C, v, x, A, R;
            return e === _ ? (_[12] = e[0] * a + e[4] * r + e[8] * g + e[12],
            _[13] = e[1] * a + e[5] * r + e[9] * g + e[13],
            _[14] = e[2] * a + e[6] * r + e[10] * g + e[14],
            _[15] = e[3] * a + e[7] * r + e[11] * g + e[15]) : (l = e[0],
            h = e[1],
            S = e[2],
            G = e[3],
            b = e[4],
            T = e[5],
            I = e[6],
            C = e[7],
            v = e[8],
            x = e[9],
            A = e[10],
            R = e[11],
            _[0] = l,
            _[1] = h,
            _[2] = S,
            _[3] = G,
            _[4] = b,
            _[5] = T,
            _[6] = I,
            _[7] = C,
            _[8] = v,
            _[9] = x,
            _[10] = A,
            _[11] = R,
            _[12] = l * a + b * r + v * g + e[12],
            _[13] = h * a + T * r + x * g + e[13],
            _[14] = S * a + I * r + A * g + e[14],
            _[15] = G * a + C * r + R * g + e[15]),
            _
        }
        ,
        e.scale = function(n, e, t) {
            var a = t[0]
              , r = t[1]
              , i = t[2];
            return n[0] = e[0] * a,
            n[1] = e[1] * a,
            n[2] = e[2] * a,
            n[3] = e[3] * a,
            n[4] = e[4] * r,
            n[5] = e[5] * r,
            n[6] = e[6] * r,
            n[7] = e[7] * r,
            n[8] = e[8] * i,
            n[9] = e[9] * i,
            n[10] = e[10] * i,
            n[11] = e[11] * i,
            n[12] = e[12],
            n[13] = e[13],
            n[14] = e[14],
            n[15] = e[15],
            n
        }
        ,
        e.rotate = function(n, e, r, a) {
            var d = a[0], u = a[1], m = a[2], P = G(d * d + u * u + m * m), w, U, V, j, H, X, K, z, J, Q, Z, $, ee, te, ae, ne, re, ie, se, oe, le, _e, de, ue;
            return F(P) < W.EPSILON ? null : (P = 1 / P,
            d *= P,
            u *= P,
            m *= P,
            w = B(r),
            U = C(r),
            V = 1 - U,
            j = e[0],
            H = e[1],
            X = e[2],
            K = e[3],
            z = e[4],
            J = e[5],
            Q = e[6],
            Z = e[7],
            $ = e[8],
            ee = e[9],
            te = e[10],
            ae = e[11],
            ne = d * d * V + U,
            re = u * d * V + m * w,
            ie = m * d * V - u * w,
            se = d * u * V - m * w,
            oe = u * u * V + U,
            le = m * u * V + d * w,
            _e = d * m * V + u * w,
            de = u * m * V - d * w,
            ue = m * m * V + U,
            n[0] = j * ne + z * re + $ * ie,
            n[1] = H * ne + J * re + ee * ie,
            n[2] = X * ne + Q * re + te * ie,
            n[3] = K * ne + Z * re + ae * ie,
            n[4] = j * se + z * oe + $ * le,
            n[5] = H * se + J * oe + ee * le,
            n[6] = X * se + Q * oe + te * le,
            n[7] = K * se + Z * oe + ae * le,
            n[8] = j * _e + z * de + $ * ue,
            n[9] = H * _e + J * de + ee * ue,
            n[10] = X * _e + Q * de + te * ue,
            n[11] = K * _e + Z * de + ae * ue,
            e !== n && (n[12] = e[12],
            n[13] = e[13],
            n[14] = e[14],
            n[15] = e[15]),
            n)
        }
        ,
        e.rotateX = function(_, e, t) {
            var a = B(t)
              , r = C(t)
              , d = e[4]
              , l = e[5]
              , u = e[6]
              , n = e[7]
              , i = e[8]
              , c = e[9]
              , g = e[10]
              , m = e[11];
            return e !== _ && (_[0] = e[0],
            _[1] = e[1],
            _[2] = e[2],
            _[3] = e[3],
            _[12] = e[12],
            _[13] = e[13],
            _[14] = e[14],
            _[15] = e[15]),
            _[4] = d * r + i * a,
            _[5] = l * r + c * a,
            _[6] = u * r + g * a,
            _[7] = n * r + m * a,
            _[8] = i * r - d * a,
            _[9] = c * r - l * a,
            _[10] = g * r - u * a,
            _[11] = m * r - n * a,
            _
        }
        ,
        e.rotateY = function(_, e, t) {
            var a = B(t)
              , r = C(t)
              , d = e[0]
              , l = e[1]
              , u = e[2]
              , n = e[3]
              , i = e[8]
              , c = e[9]
              , g = e[10]
              , m = e[11];
            return e !== _ && (_[4] = e[4],
            _[5] = e[5],
            _[6] = e[6],
            _[7] = e[7],
            _[12] = e[12],
            _[13] = e[13],
            _[14] = e[14],
            _[15] = e[15]),
            _[0] = d * r - i * a,
            _[1] = l * r - c * a,
            _[2] = u * r - g * a,
            _[3] = n * r - m * a,
            _[8] = d * a + i * r,
            _[9] = l * a + c * r,
            _[10] = u * a + g * r,
            _[11] = n * a + m * r,
            _
        }
        ,
        e.rotateZ = function(_, e, t) {
            var a = B(t)
              , r = C(t)
              , d = e[0]
              , l = e[1]
              , u = e[2]
              , n = e[3]
              , i = e[4]
              , c = e[5]
              , g = e[6]
              , m = e[7];
            return e !== _ && (_[8] = e[8],
            _[9] = e[9],
            _[10] = e[10],
            _[11] = e[11],
            _[12] = e[12],
            _[13] = e[13],
            _[14] = e[14],
            _[15] = e[15]),
            _[0] = d * r + i * a,
            _[1] = l * r + c * a,
            _[2] = u * r + g * a,
            _[3] = n * r + m * a,
            _[4] = i * r - d * a,
            _[5] = c * r - l * a,
            _[6] = g * r - u * a,
            _[7] = m * r - n * a,
            _
        }
        ,
        e.fromTranslation = function(a, e) {
            return a[0] = 1,
            a[1] = 0,
            a[2] = 0,
            a[3] = 0,
            a[4] = 0,
            a[5] = 1,
            a[6] = 0,
            a[7] = 0,
            a[8] = 0,
            a[9] = 0,
            a[10] = 1,
            a[11] = 0,
            a[12] = e[0],
            a[13] = e[1],
            a[14] = e[2],
            a[15] = 1,
            a
        }
        ,
        e.fromScaling = function(a, e) {
            return a[0] = e[0],
            a[1] = 0,
            a[2] = 0,
            a[3] = 0,
            a[4] = 0,
            a[5] = e[1],
            a[6] = 0,
            a[7] = 0,
            a[8] = 0,
            a[9] = 0,
            a[10] = e[2],
            a[11] = 0,
            a[12] = 0,
            a[13] = 0,
            a[14] = 0,
            a[15] = 1,
            a
        }
        ,
        e.fromRotation = function(t, e, a) {
            var n = a[0], r = a[1], _ = a[2], d = G(n * n + r * r + _ * _), u, g, m;
            return F(d) < W.EPSILON ? null : (d = 1 / d,
            n *= d,
            r *= d,
            _ *= d,
            u = B(e),
            g = C(e),
            m = 1 - g,
            t[0] = n * n * m + g,
            t[1] = r * n * m + _ * u,
            t[2] = _ * n * m - r * u,
            t[3] = 0,
            t[4] = n * r * m - _ * u,
            t[5] = r * r * m + g,
            t[6] = _ * r * m + n * u,
            t[7] = 0,
            t[8] = n * _ * m + r * u,
            t[9] = r * _ * m - n * u,
            t[10] = _ * _ * m + g,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t)
        }
        ,
        e.fromXRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = 1,
            n[1] = 0,
            n[2] = 0,
            n[3] = 0,
            n[4] = 0,
            n[5] = a,
            n[6] = t,
            n[7] = 0,
            n[8] = 0,
            n[9] = -t,
            n[10] = a,
            n[11] = 0,
            n[12] = 0,
            n[13] = 0,
            n[14] = 0,
            n[15] = 1,
            n
        }
        ,
        e.fromYRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = a,
            n[1] = 0,
            n[2] = -t,
            n[3] = 0,
            n[4] = 0,
            n[5] = 1,
            n[6] = 0,
            n[7] = 0,
            n[8] = t,
            n[9] = 0,
            n[10] = a,
            n[11] = 0,
            n[12] = 0,
            n[13] = 0,
            n[14] = 0,
            n[15] = 1,
            n
        }
        ,
        e.fromZRotation = function(n, e) {
            var t = B(e)
              , a = C(e);
            return n[0] = a,
            n[1] = t,
            n[2] = 0,
            n[3] = 0,
            n[4] = -t,
            n[5] = a,
            n[6] = 0,
            n[7] = 0,
            n[8] = 0,
            n[9] = 0,
            n[10] = 1,
            n[11] = 0,
            n[12] = 0,
            n[13] = 0,
            n[14] = 0,
            n[15] = 1,
            n
        }
        ,
        e.fromRotationTranslation = function(_, e, t) {
            var a = e[0]
              , r = e[1]
              , g = e[2]
              , l = e[3]
              , h = a + a
              , n = r + r
              , d = g + g
              , u = a * h
              , i = a * n
              , c = a * d
              , m = r * n
              , f = r * d
              , S = g * d
              , p = l * h
              , G = l * n
              , y = l * d;
            return _[0] = 1 - (m + S),
            _[1] = i + y,
            _[2] = c - G,
            _[3] = 0,
            _[4] = i - y,
            _[5] = 1 - (u + S),
            _[6] = f + p,
            _[7] = 0,
            _[8] = c + G,
            _[9] = f - p,
            _[10] = 1 - (u + m),
            _[11] = 0,
            _[12] = t[0],
            _[13] = t[1],
            _[14] = t[2],
            _[15] = 1,
            _
        }
        ,
        e.getTranslation = function(a, e) {
            return a[0] = e[12],
            a[1] = e[13],
            a[2] = e[14],
            a
        }
        ,
        e.getScaling = function(n, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , _ = e[4]
              , l = e[5]
              , g = e[6]
              , d = e[8]
              , u = e[9]
              , i = e[10];
            return n[0] = G(t * t + a * a + r * r),
            n[1] = G(_ * _ + l * l + g * g),
            n[2] = G(d * d + u * u + i * i),
            n
        }
        ,
        e.getRotation = function(n, e) {
            var t = e[0] + e[5] + e[10]
              , a = 0;
            return 0 < t ? (a = 2 * G(t + 1),
            n[3] = .25 * a,
            n[0] = (e[6] - e[9]) / a,
            n[1] = (e[8] - e[2]) / a,
            n[2] = (e[1] - e[4]) / a) : e[0] > e[5] & e[0] > e[10] ? (a = 2 * G(1 + e[0] - e[5] - e[10]),
            n[3] = (e[6] - e[9]) / a,
            n[0] = .25 * a,
            n[1] = (e[1] + e[4]) / a,
            n[2] = (e[8] + e[2]) / a) : e[5] > e[10] ? (a = 2 * G(1 + e[5] - e[0] - e[10]),
            n[3] = (e[8] - e[2]) / a,
            n[0] = (e[1] + e[4]) / a,
            n[1] = .25 * a,
            n[2] = (e[6] + e[9]) / a) : (a = 2 * G(1 + e[10] - e[0] - e[5]),
            n[3] = (e[1] - e[4]) / a,
            n[0] = (e[8] + e[2]) / a,
            n[1] = (e[6] + e[9]) / a,
            n[2] = .25 * a),
            n
        }
        ,
        e.fromRotationTranslationScale = function(_, e, t, a) {
            var r = e[0]
              , g = e[1]
              , l = e[2]
              , h = e[3]
              , n = r + r
              , d = g + g
              , u = l + l
              , i = r * n
              , c = r * d
              , m = r * u
              , f = g * d
              , G = g * u
              , p = l * u
              , b = h * n
              , y = h * d
              , T = h * u
              , I = a[0]
              , C = a[1]
              , v = a[2];
            return _[0] = (1 - (f + p)) * I,
            _[1] = (c + T) * I,
            _[2] = (m - y) * I,
            _[3] = 0,
            _[4] = (c - T) * C,
            _[5] = (1 - (i + p)) * C,
            _[6] = (G + b) * C,
            _[7] = 0,
            _[8] = (m + y) * v,
            _[9] = (G - b) * v,
            _[10] = (1 - (i + f)) * v,
            _[11] = 0,
            _[12] = t[0],
            _[13] = t[1],
            _[14] = t[2],
            _[15] = 1,
            _
        }
        ,
        e.fromRotationTranslationScaleOrigin = function(g, e, t, a, r) {
            var l = e[0]
              , h = e[1]
              , G = e[2]
              , n = e[3]
              , d = l + l
              , u = h + h
              , i = G + G
              , c = l * d
              , m = l * u
              , f = l * i
              , b = h * u
              , p = h * i
              , T = G * i
              , y = n * d
              , C = n * u
              , v = n * i
              , x = a[0]
              , P = a[1]
              , S = a[2]
              , _ = r[0]
              , A = r[1]
              , I = r[2];
            return g[0] = (1 - (b + T)) * x,
            g[1] = (m + v) * x,
            g[2] = (f - C) * x,
            g[3] = 0,
            g[4] = (m - v) * P,
            g[5] = (1 - (c + T)) * P,
            g[6] = (p + y) * P,
            g[7] = 0,
            g[8] = (f + C) * S,
            g[9] = (p - y) * S,
            g[10] = (1 - (c + b)) * S,
            g[11] = 0,
            g[12] = t[0] + _ - (g[0] * _ + g[4] * A + g[8] * I),
            g[13] = t[1] + A - (g[1] * _ + g[5] * A + g[9] * I),
            g[14] = t[2] + I - (g[2] * _ + g[6] * A + g[10] * I),
            g[15] = 1,
            g
        }
        ,
        e.fromQuat = function(_, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , g = e[3]
              , l = t + t
              , h = a + a
              , n = r + r
              , d = t * l
              , u = a * l
              , i = a * h
              , c = r * l
              , m = r * h
              , f = r * n
              , S = g * l
              , p = g * h
              , G = g * n;
            return _[0] = 1 - i - f,
            _[1] = u + G,
            _[2] = c - p,
            _[3] = 0,
            _[4] = u - G,
            _[5] = 1 - d - f,
            _[6] = m + S,
            _[7] = 0,
            _[8] = c + p,
            _[9] = m - S,
            _[10] = 1 - d - i,
            _[11] = 0,
            _[12] = 0,
            _[13] = 0,
            _[14] = 0,
            _[15] = 1,
            _
        }
        ,
        e.frustum = function(i, e, t, a, r, _, l) {
            var c = 1 / (t - e)
              , n = 1 / (r - a)
              , d = 1 / (_ - l);
            return i[0] = 2 * _ * c,
            i[1] = 0,
            i[2] = 0,
            i[3] = 0,
            i[4] = 0,
            i[5] = 2 * _ * n,
            i[6] = 0,
            i[7] = 0,
            i[8] = (t + e) * c,
            i[9] = (r + a) * n,
            i[10] = (l + _) * d,
            i[11] = -1,
            i[12] = 0,
            i[13] = 0,
            i[14] = 2 * (l * _) * d,
            i[15] = 0,
            i
        }
        ,
        e.perspective = function(i, e, t, a, r) {
            var l = 1 / _(e / 2)
              , d = 1 / (a - r);
            return i[0] = l / t,
            i[1] = 0,
            i[2] = 0,
            i[3] = 0,
            i[4] = 0,
            i[5] = l,
            i[6] = 0,
            i[7] = 0,
            i[8] = 0,
            i[9] = 0,
            i[10] = (r + a) * d,
            i[11] = -1,
            i[12] = 0,
            i[13] = 0,
            i[14] = 2 * r * a * d,
            i[15] = 0,
            i
        }
        ,
        e.perspectiveFromFieldOfView = function(l, e, t, a) {
            var r = _(e.upDegrees * h / 180)
              , c = _(e.downDegrees * h / 180)
              , g = _(e.leftDegrees * h / 180)
              , n = _(e.rightDegrees * h / 180)
              , d = 2 / (g + n)
              , u = 2 / (r + c);
            return l[0] = d,
            l[1] = 0,
            l[2] = 0,
            l[3] = 0,
            l[4] = 0,
            l[5] = u,
            l[6] = 0,
            l[7] = 0,
            l[8] = -(.5 * ((g - n) * d)),
            l[9] = .5 * ((r - c) * u),
            l[10] = a / (t - a),
            l[11] = -1,
            l[12] = 0,
            l[13] = 0,
            l[14] = a * t / (t - a),
            l[15] = 0,
            l
        }
        ,
        e.ortho = function(i, e, t, a, r, _, l) {
            var c = 1 / (e - t)
              , n = 1 / (a - r)
              , d = 1 / (_ - l);
            return i[0] = -2 * c,
            i[1] = 0,
            i[2] = 0,
            i[3] = 0,
            i[4] = 0,
            i[5] = -2 * n,
            i[6] = 0,
            i[7] = 0,
            i[8] = 0,
            i[9] = 0,
            i[10] = 2 * d,
            i[11] = 0,
            i[12] = (e + t) * c,
            i[13] = (r + a) * n,
            i[14] = (l + _) * d,
            i[15] = 1,
            i
        }
        ,
        e.lookAt = function(n, e, t, a) {
            var r = e[0], g = e[1], m = e[2], h = a[0], y = a[1], b = a[2], S = t[0], _ = t[1], T = t[2], I, C, v, x, P, A, R, D, B, k;
            return F(r - S) < W.EPSILON && F(g - _) < W.EPSILON && F(m - T) < W.EPSILON ? mat4.identity(n) : (R = r - S,
            D = g - _,
            B = m - T,
            k = 1 / G(R * R + D * D + B * B),
            R *= k,
            D *= k,
            B *= k,
            I = y * B - b * D,
            C = b * R - h * B,
            v = h * D - y * R,
            k = G(I * I + C * C + v * v),
            k ? (k = 1 / k,
            I *= k,
            C *= k,
            v *= k) : (I = 0,
            C = 0,
            v = 0),
            x = D * v - B * C,
            P = B * I - R * v,
            A = R * C - D * I,
            k = G(x * x + P * P + A * A),
            k ? (k = 1 / k,
            x *= k,
            P *= k,
            A *= k) : (x = 0,
            P = 0,
            A = 0),
            n[0] = I,
            n[1] = x,
            n[2] = R,
            n[3] = 0,
            n[4] = C,
            n[5] = P,
            n[6] = D,
            n[7] = 0,
            n[8] = v,
            n[9] = A,
            n[10] = B,
            n[11] = 0,
            n[12] = -(I * r + C * g + v * m),
            n[13] = -(x * r + P * g + A * m),
            n[14] = -(R * r + D * g + B * m),
            n[15] = 1,
            n)
        }
        ,
        e.targetTo = function(n, e, t, a) {
            var r = e[0]
              , _ = e[1]
              , l = e[2]
              , g = a[0]
              , d = a[1]
              , u = a[2]
              , i = r - t[0]
              , h = _ - t[1]
              , S = l - t[2]
              , b = i * i + h * h + S * S;
            0 < b && (b = 1 / G(b),
            i *= b,
            h *= b,
            S *= b);
            var T = d * S - u * h
              , p = u * i - g * S
              , I = g * h - d * i;
            return n[0] = T,
            n[1] = p,
            n[2] = I,
            n[3] = 0,
            n[4] = h * I - S * p,
            n[5] = S * T - i * I,
            n[6] = i * p - h * T,
            n[7] = 0,
            n[8] = i,
            n[9] = h,
            n[10] = S,
            n[11] = 0,
            n[12] = r,
            n[13] = _,
            n[14] = l,
            n[15] = 1,
            n
        }
        ,
        e.str = function(t) {
            return 'mat4(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ', ' + t[4] + ', ' + t[5] + ', ' + t[6] + ', ' + t[7] + ', ' + t[8] + ', ' + t[9] + ', ' + t[10] + ', ' + t[11] + ', ' + t[12] + ', ' + t[13] + ', ' + t[14] + ', ' + t[15] + ')'
        }
        ,
        e.frob = function(a) {
            return G(t(a[0], 2) + t(a[1], 2) + t(a[2], 2) + t(a[3], 2) + t(a[4], 2) + t(a[5], 2) + t(a[6], 2) + t(a[7], 2) + t(a[8], 2) + t(a[9], 2) + t(a[10], 2) + t(a[11], 2) + t(a[12], 2) + t(a[13], 2) + t(a[14], 2) + t(a[15], 2))
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n[2] = e[2] + t[2],
            n[3] = e[3] + t[3],
            n[4] = e[4] + t[4],
            n[5] = e[5] + t[5],
            n[6] = e[6] + t[6],
            n[7] = e[7] + t[7],
            n[8] = e[8] + t[8],
            n[9] = e[9] + t[9],
            n[10] = e[10] + t[10],
            n[11] = e[11] + t[11],
            n[12] = e[12] + t[12],
            n[13] = e[13] + t[13],
            n[14] = e[14] + t[14],
            n[15] = e[15] + t[15],
            n
        }
        ,
        e.subtract = r,
        e.multiplyScalar = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n[2] = e[2] * t,
            n[3] = e[3] * t,
            n[4] = e[4] * t,
            n[5] = e[5] * t,
            n[6] = e[6] * t,
            n[7] = e[7] * t,
            n[8] = e[8] * t,
            n[9] = e[9] * t,
            n[10] = e[10] * t,
            n[11] = e[11] * t,
            n[12] = e[12] * t,
            n[13] = e[13] * t,
            n[14] = e[14] * t,
            n[15] = e[15] * t,
            n
        }
        ,
        e.multiplyScalarAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n[2] = e[2] + t[2] * a,
            n[3] = e[3] + t[3] * a,
            n[4] = e[4] + t[4] * a,
            n[5] = e[5] + t[5] * a,
            n[6] = e[6] + t[6] * a,
            n[7] = e[7] + t[7] * a,
            n[8] = e[8] + t[8] * a,
            n[9] = e[9] + t[9] * a,
            n[10] = e[10] + t[10] * a,
            n[11] = e[11] + t[11] * a,
            n[12] = e[12] + t[12] * a,
            n[13] = e[13] + t[13] * a,
            n[14] = e[14] + t[14] * a,
            n[15] = e[15] + t[15] * a,
            n
        }
        ,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3] && a[4] === e[4] && a[5] === e[5] && a[6] === e[6] && a[7] === e[7] && a[8] === e[8] && a[9] === e[9] && a[10] === e[10] && a[11] === e[11] && a[12] === e[12] && a[13] === e[13] && a[14] === e[14] && a[15] === e[15]
        }
        ,
        e.equals = function(i, e) {
            var t = i[0]
              , a = i[1]
              , r = i[2]
              , m = i[3]
              , l = i[4]
              , G = i[5]
              , n = i[6]
              , d = i[7]
              , u = i[8]
              , c = i[9]
              , f = i[10]
              , p = i[11]
              , C = i[12]
              , y = i[13]
              , P = i[14]
              , A = i[15]
              , R = e[0]
              , E = e[1]
              , S = e[2]
              , _ = e[3]
              , B = e[4]
              , I = e[5]
              , L = e[6]
              , O = e[7]
              , g = e[8]
              , M = e[9]
              , v = e[10]
              , h = e[11]
              , T = e[12]
              , b = e[13]
              , x = e[14]
              , D = e[15];
            return F(t - R) <= W.EPSILON * w(1, F(t), F(R)) && F(a - E) <= W.EPSILON * w(1, F(a), F(E)) && F(r - S) <= W.EPSILON * w(1, F(r), F(S)) && F(m - _) <= W.EPSILON * w(1, F(m), F(_)) && F(l - B) <= W.EPSILON * w(1, F(l), F(B)) && F(G - I) <= W.EPSILON * w(1, F(G), F(I)) && F(n - L) <= W.EPSILON * w(1, F(n), F(L)) && F(d - O) <= W.EPSILON * w(1, F(d), F(O)) && F(u - g) <= W.EPSILON * w(1, F(u), F(g)) && F(c - M) <= W.EPSILON * w(1, F(c), F(M)) && F(f - v) <= W.EPSILON * w(1, F(f), F(v)) && F(p - h) <= W.EPSILON * w(1, F(p), F(h)) && F(C - T) <= W.EPSILON * w(1, F(C), F(T)) && F(y - b) <= W.EPSILON * w(1, F(y), F(b)) && F(P - x) <= W.EPSILON * w(1, F(P), F(x)) && F(A - D) <= W.EPSILON * w(1, F(A), F(D))
        }
        ;
        var l = i(0)
          , W = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(l)
          , d = e.mul = a
          , u = e.sub = r
    }
    , function(e, t, a) {
        'use strict';
        function n(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }
        function d() {
            var t = new m.ARRAY_TYPE(4);
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        function u(n, e, t) {
            t *= .5;
            var i = B(t);
            return n[0] = i * e[0],
            n[1] = i * e[1],
            n[2] = i * e[2],
            n[3] = C(t),
            n
        }
        function r(_, e, t) {
            var a = e[0]
              , r = e[1]
              , c = e[2]
              , l = e[3]
              , g = t[0]
              , n = t[1]
              , d = t[2]
              , u = t[3];
            return _[0] = a * u + l * g + r * d - c * n,
            _[1] = r * u + l * n + c * g - a * d,
            _[2] = c * u + l * d + a * n - r * g,
            _[3] = l * u - a * g - r * n - c * d,
            _
        }
        function i(e, r, _, a) {
            var l = r[0], t = r[1], u = r[2], n = r[3], d = _[0], h = _[1], S = _[2], G = _[3], b, T, I, C, v;
            return T = l * d + t * h + u * S + n * G,
            0 > T && (T = -T,
            d = -d,
            h = -h,
            S = -S,
            G = -G),
            1e-6 < 1 - T ? (b = g(T),
            I = B(b),
            C = B((1 - a) * b) / I,
            v = B(a * b) / I) : (C = 1 - a,
            v = a),
            e[0] = C * l + v * d,
            e[1] = C * t + v * h,
            e[2] = C * u + v * S,
            e[3] = C * n + v * G,
            e
        }
        function l(n, e) {
            var t = e[0] + e[4] + e[8], a;
            if (0 < t)
                a = G(t + 1),
                n[3] = .5 * a,
                a = .5 / a,
                n[0] = (e[5] - e[7]) * a,
                n[1] = (e[6] - e[2]) * a,
                n[2] = (e[1] - e[3]) * a;
            else {
                var i = 0;
                e[4] > e[0] && (i = 1),
                e[8] > e[3 * i + i] && (i = 2);
                var _ = (i + 1) % 3
                  , l = (i + 2) % 3;
                a = G(e[3 * i + i] - e[3 * _ + _] - e[3 * l + l] + 1),
                n[i] = .5 * a,
                a = .5 / a,
                n[3] = (e[3 * _ + l] - e[3 * l + _]) * a,
                n[_] = (e[3 * _ + i] + e[3 * i + _]) * a,
                n[l] = (e[3 * l + i] + e[3 * i + l]) * a
            }
            return n
        }
        Object.defineProperty(t, '__esModule', {
            value: !0
        }),
        t.setAxes = t.sqlerp = t.rotationTo = t.equals = t.exactEquals = t.normalize = t.sqrLen = t.squaredLength = t.len = t.length = t.lerp = t.dot = t.scale = t.mul = t.add = t.set = t.copy = t.fromValues = t.clone = void 0,
        t.create = d,
        t.identity = function(t) {
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        ,
        t.setAxisAngle = u,
        t.getAxisAngle = function(e, t) {
            var a = 2 * g(t[3])
              , n = B(a / 2);
            return 0 == n ? (e[0] = 1,
            e[1] = 0,
            e[2] = 0) : (e[0] = t[0] / n,
            e[1] = t[1] / n,
            e[2] = t[2] / n),
            a
        }
        ,
        t.multiply = r,
        t.rotateX = function(_, e, t) {
            t *= .5;
            var d = e[0]
              , r = e[1]
              , u = e[2]
              , l = e[3]
              , c = B(t)
              , n = C(t);
            return _[0] = d * n + l * c,
            _[1] = r * n + u * c,
            _[2] = u * n - r * c,
            _[3] = l * n - d * c,
            _
        }
        ,
        t.rotateY = function(_, e, t) {
            t *= .5;
            var d = e[0]
              , r = e[1]
              , u = e[2]
              , l = e[3]
              , c = B(t)
              , n = C(t);
            return _[0] = d * n - u * c,
            _[1] = r * n + l * c,
            _[2] = u * n + d * c,
            _[3] = l * n - r * c,
            _
        }
        ,
        t.rotateZ = function(_, e, t) {
            t *= .5;
            var d = e[0]
              , r = e[1]
              , u = e[2]
              , l = e[3]
              , c = B(t)
              , n = C(t);
            return _[0] = d * n + r * c,
            _[1] = r * n - d * c,
            _[2] = u * n + l * c,
            _[3] = l * n - u * c,
            _
        }
        ,
        t.calculateW = function(n, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2];
            return n[0] = t,
            n[1] = a,
            n[2] = r,
            n[3] = G(F(1 - t * t - a * a - r * r)),
            n
        }
        ,
        t.slerp = i,
        t.invert = function(i, e) {
            var t = e[0]
              , a = e[1]
              , r = e[2]
              , _ = e[3]
              , l = t * t + a * a + r * r + _ * _
              , d = l ? 1 / l : 0;
            return i[0] = -t * d,
            i[1] = -a * d,
            i[2] = -r * d,
            i[3] = _ * d,
            i
        }
        ,
        t.conjugate = function(a, e) {
            return a[0] = -e[0],
            a[1] = -e[1],
            a[2] = -e[2],
            a[3] = e[3],
            a
        }
        ,
        t.fromMat3 = l,
        t.fromEuler = function(_, e, d, u) {
            var c = .5 * h / 180;
            e *= c,
            d *= c,
            u *= c;
            var g = B(e)
              , l = C(e)
              , p = B(d)
              , n = C(d)
              , i = B(u)
              , m = C(u);
            return _[0] = g * n * m - l * p * i,
            _[1] = l * p * m + g * n * i,
            _[2] = l * n * i - g * p * m,
            _[3] = l * n * m + g * p * i,
            _
        }
        ,
        t.str = function(t) {
            return 'quat(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + t[3] + ')'
        }
        ;
        var c = a(0)
          , m = n(c)
          , p = a(1)
          , f = n(p)
          , y = a(2)
          , P = n(y)
          , A = a(3)
          , R = n(A)
          , S = t.clone = R.clone
          , _ = t.fromValues = R.fromValues
          , E = t.copy = R.copy
          , I = t.set = R.set
          , L = t.add = R.add
          , O = t.mul = r
          , W = t.scale = R.scale
          , M = t.dot = R.dot
          , v = t.lerp = R.lerp
          , N = t.length = R.length
          , T = t.len = N
          , b = t.squaredLength = R.squaredLength
          , x = t.sqrLen = b
          , D = t.normalize = R.normalize
          , k = t.exactEquals = R.exactEquals
          , w = t.equals = R.equals
          , U = t.rotationTo = function() {
            var i = P.create()
              , e = P.fromValues(1, 0, 0)
              , t = P.fromValues(0, 1, 0);
            return function(r, _, l) {
                var a = P.dot(_, l);
                return -.999999 > a ? (P.cross(i, e, _),
                1e-6 > P.len(i) && P.cross(i, t, _),
                P.normalize(i, i),
                u(r, i, Math.PI),
                r) : .999999 < a ? (r[0] = 0,
                r[1] = 0,
                r[2] = 0,
                r[3] = 1,
                r) : (P.cross(i, _, l),
                r[0] = i[0],
                r[1] = i[1],
                r[2] = i[2],
                r[3] = 1 + a,
                D(r, r))
            }
        }()
          , V = t.sqlerp = function() {
            var t = d()
              , e = d();
            return function(r, _, l, a, u, n) {
                return i(t, _, u, n),
                i(e, l, a, n),
                i(r, t, e, 2 * n * (1 - n)),
                r
            }
        }()
          , j = t.setAxes = function() {
            var n = f.create();
            return function(e, t, a, r) {
                return n[0] = a[0],
                n[3] = a[1],
                n[6] = a[2],
                n[1] = r[0],
                n[4] = r[1],
                n[7] = r[2],
                n[2] = -t[0],
                n[5] = -t[1],
                n[8] = -t[2],
                D(e, l(e, n))
            }
        }()
    }
    , function(t, e, n) {
        'use strict';
        function i() {
            var t = new T.ARRAY_TYPE(2);
            return t[0] = 0,
            t[1] = 0,
            t
        }
        function l(n, e, t) {
            return n[0] = e[0] - t[0],
            n[1] = e[1] - t[1],
            n
        }
        function d(n, e, t) {
            return n[0] = e[0] * t[0],
            n[1] = e[1] * t[1],
            n
        }
        function u(n, e, t) {
            return n[0] = e[0] / t[0],
            n[1] = e[1] / t[1],
            n
        }
        function c(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1];
            return G(t * t + a * a)
        }
        function m(n, e) {
            var t = e[0] - n[0]
              , a = e[1] - n[1];
            return t * t + a * a
        }
        function f(n) {
            var e = n[0]
              , t = n[1];
            return G(e * e + t * t)
        }
        function y(n) {
            var e = n[0]
              , t = n[1];
            return e * e + t * t
        }
        Object.defineProperty(e, '__esModule', {
            value: !0
        }),
        e.forEach = e.sqrLen = e.sqrDist = e.dist = e.div = e.mul = e.sub = e.len = void 0,
        e.create = i,
        e.clone = function(a) {
            var e = new T.ARRAY_TYPE(2);
            return e[0] = a[0],
            e[1] = a[1],
            e
        }
        ,
        e.fromValues = function(n, e) {
            var t = new T.ARRAY_TYPE(2);
            return t[0] = n,
            t[1] = e,
            t
        }
        ,
        e.copy = function(a, e) {
            return a[0] = e[0],
            a[1] = e[1],
            a
        }
        ,
        e.set = function(n, e, t) {
            return n[0] = e,
            n[1] = t,
            n
        }
        ,
        e.add = function(n, e, t) {
            return n[0] = e[0] + t[0],
            n[1] = e[1] + t[1],
            n
        }
        ,
        e.subtract = l,
        e.multiply = d,
        e.divide = u,
        e.ceil = function(a, e) {
            return a[0] = p(e[0]),
            a[1] = p(e[1]),
            a
        }
        ,
        e.floor = function(a, e) {
            return a[0] = r(e[0]),
            a[1] = r(e[1]),
            a
        }
        ,
        e.min = function(n, e, t) {
            return n[0] = _(e[0], t[0]),
            n[1] = _(e[1], t[1]),
            n
        }
        ,
        e.max = function(n, e, t) {
            return n[0] = w(e[0], t[0]),
            n[1] = w(e[1], t[1]),
            n
        }
        ,
        e.round = function(t, e) {
            return t[0] = a(e[0]),
            t[1] = a(e[1]),
            t
        }
        ,
        e.scale = function(n, e, t) {
            return n[0] = e[0] * t,
            n[1] = e[1] * t,
            n
        }
        ,
        e.scaleAndAdd = function(n, e, t, a) {
            return n[0] = e[0] + t[0] * a,
            n[1] = e[1] + t[1] * a,
            n
        }
        ,
        e.distance = c,
        e.squaredDistance = m,
        e.length = f,
        e.squaredLength = y,
        e.negate = function(a, e) {
            return a[0] = -e[0],
            a[1] = -e[1],
            a
        }
        ,
        e.inverse = function(a, e) {
            return a[0] = 1 / e[0],
            a[1] = 1 / e[1],
            a
        }
        ,
        e.normalize = function(n, e) {
            var t = e[0]
              , a = e[1]
              , r = t * t + a * a;
            return 0 < r && (r = 1 / G(r),
            n[0] = e[0] * r,
            n[1] = e[1] * r),
            n
        }
        ,
        e.dot = function(a, e) {
            return a[0] * e[0] + a[1] * e[1]
        }
        ,
        e.cross = function(n, e, t) {
            var a = e[0] * t[1] - e[1] * t[0];
            return n[0] = n[1] = 0,
            n[2] = a,
            n
        }
        ,
        e.lerp = function(n, e, r, a) {
            var i = e[0]
              , t = e[1];
            return n[0] = i + a * (r[0] - i),
            n[1] = t + a * (r[1] - t),
            n
        }
        ,
        e.random = function(n, e) {
            e = e || 1;
            var r = 2 * T.RANDOM() * h;
            return n[0] = C(r) * e,
            n[1] = B(r) * e,
            n
        }
        ,
        e.transformMat2 = function(n, e, t) {
            var a = e[0]
              , r = e[1];
            return n[0] = t[0] * a + t[2] * r,
            n[1] = t[1] * a + t[3] * r,
            n
        }
        ,
        e.transformMat2d = function(n, e, t) {
            var a = e[0]
              , r = e[1];
            return n[0] = t[0] * a + t[2] * r + t[4],
            n[1] = t[1] * a + t[3] * r + t[5],
            n
        }
        ,
        e.transformMat3 = function(n, e, t) {
            var a = e[0]
              , r = e[1];
            return n[0] = t[0] * a + t[3] * r + t[6],
            n[1] = t[1] * a + t[4] * r + t[7],
            n
        }
        ,
        e.transformMat4 = function(n, e, t) {
            var a = e[0]
              , r = e[1];
            return n[0] = t[0] * a + t[4] * r + t[12],
            n[1] = t[1] * a + t[5] * r + t[13],
            n
        }
        ,
        e.str = function(t) {
            return 'vec2(' + t[0] + ', ' + t[1] + ')'
        }
        ,
        e.exactEquals = function(a, e) {
            return a[0] === e[0] && a[1] === e[1]
        }
        ,
        e.equals = function(n, e) {
            var t = n[0]
              , a = n[1]
              , r = e[0]
              , i = e[1];
            return F(t - r) <= T.EPSILON * w(1, F(t), F(r)) && F(a - i) <= T.EPSILON * w(1, F(a), F(i))
        }
        ;
        var b = n(0)
          , T = function(n) {
            if (n && n.__esModule)
                return n;
            var e = {};
            if (null != n)
                for (var t in n)
                    Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
            return e.default = n,
            e
        }(b)
          , S = e.len = f
          , x = e.sub = l
          , P = e.mul = d
          , I = e.div = u
          , A = e.dist = c
          , R = e.sqrDist = m
          , g = e.sqrLen = y
          , E = e.forEach = function() {
            var r = i();
            return function(e, t, l, c, g, n) {
                var d, m;
                for (t || (t = 2),
                l || (l = 0),
                m = c ? _(c * t + l, e.length) : e.length,
                d = l; d < m; d += t)
                    r[0] = e[d],
                    r[1] = e[d + 1],
                    g(r, r, n),
                    e[d] = r[0],
                    e[d + 1] = r[1];
                return e
            }
        }()
    }
    ])
}),
'use strict';
{
    function _(t, a, n) {
        n = n || 0;
        var r = [0, 0], i, l, _, m, p, S, y;
        return i = t[1][1] - t[0][1],
        l = t[0][0] - t[1][0],
        _ = i * t[0][0] + l * t[0][1],
        m = a[1][1] - a[0][1],
        p = a[0][0] - a[1][0],
        S = m * a[0][0] + p * a[0][1],
        y = i * p - m * l,
        u(y, 0, n) || (r[0] = (p * _ - l * S) / y,
        r[1] = (i * S - m * _) / y),
        r
    }
    function S(t, a, n, r) {
        var l = a[0] - t[0]
          , e = a[1] - t[1]
          , _ = r[0] - n[0]
          , d = r[1] - n[1];
        if (0 == _ * e - d * l)
            return !1;
        var u = (l * (n[1] - t[1]) + e * (t[0] - n[0])) / (_ * e - d * l)
          , i = (_ * (t[1] - n[1]) + d * (n[0] - t[0])) / (d * l - _ * e);
        return 0 <= u && 1 >= u && 0 <= i && 1 >= i
    }
    function y(e, t, a) {
        return (t[0] - e[0]) * (a[1] - e[1]) - (a[0] - e[0]) * (t[1] - e[1])
    }
    function G(e, t, a) {
        return 0 < y(e, t, a)
    }
    function T(e, t, a) {
        return 0 <= y(e, t, a)
    }
    function e(e, t, a) {
        return 0 > y(e, t, a)
    }
    function f(e, t, a) {
        return 0 >= y(e, t, a)
    }
    function g(e, t, a, n) {
        var r = Math.sqrt;
        if (!n)
            return 0 === y(e, t, a);
        var _ = tmpPoint1
          , d = tmpPoint2;
        _[0] = t[0] - e[0],
        _[1] = t[1] - e[1],
        d[0] = a[0] - t[0],
        d[1] = a[1] - t[1];
        var u = _[0] * d[0] + _[1] * d[1]
          , i = r(_[0] * _[0] + _[1] * _[1])
          , c = r(d[0] * d[0] + d[1] * d[1])
          , g = Math.acos(u / (i * c));
        return g < n
    }
    function x(e, t) {
        var a = t[0] - e[0]
          , n = t[1] - e[1];
        return a * a + n * n
    }
    function P(e, t) {
        var a = e.length;
        return e[0 > t ? t % a + a : t % a]
    }
    function l(e) {
        e.length = 0
    }
    function a(t, a, n, r) {
        for (var i = n; i < r; i++)
            t.push(a[i])
    }
    function n(e) {
        for (var t = [], a = e.length, n = 0; n !== a; n++)
            t.push(e.pop());
        for (var n = 0; n !== a; n++)
            e[n] = t[n]
    }
    function R(t, a) {
        return e(P(t, a - 1), P(t, a), P(t, a + 1))
    }
    function m(t, r, e) {
        var a = tmpLine1, i = tmpLine2, l, d;
        if (T(P(t, r + 1), P(t, r), P(t, e)) && f(P(t, r - 1), P(t, r), P(t, e)))
            return !1;
        d = x(P(t, r), P(t, e));
        for (var u = 0; u !== t.length; ++u)
            if ((u + 1) % t.length !== r && u !== r && T(P(t, r), P(t, e), P(t, u + 1)) && f(P(t, r), P(t, e), P(t, u)) && (a[0] = P(t, r),
            a[1] = P(t, e),
            i[0] = P(t, u),
            i[1] = P(t, u + 1),
            l = _(a, i),
            x(P(t, r), l) < d))
                return !1;
        return !0
    }
    function p(t, n, e) {
        for (var a = 0; a !== t.length; ++a)
            if (a !== n && a !== e && (a + 1) % t.length !== n && (a + 1) % t.length !== e && S(P(t, n), P(t, e), P(t, a), P(t, a + 1)))
                return !1;
        return !0
    }
    function I(t, a, n, r) {
        var i = r || [];
        if (l(i),
        a < n)
            for (var e = a; e <= n; e++)
                i.push(t[e]);
        else {
            for (var e = 0; e <= n; e++)
                i.push(t[e]);
            for (var e = a; e < t.length; e++)
                i.push(t[e])
        }
        return i
    }
    function r(t) {
        for (var a = [], n = [], l = [], _ = [], e = Number.MAX_VALUE, u = 0; u < t.length; ++u)
            if (R(t, u))
                for (var p = 0; p < t.length; ++p)
                    if (m(t, u, p)) {
                        n = r(I(t, u, p, _)),
                        l = r(I(t, p, u, _));
                        for (var S = 0; S < l.length; S++)
                            n.push(l[S]);
                        n.length < e && (a = n,
                        e = n.length,
                        a.push([P(t, u), P(t, p)]))
                    }
        return a
    }
    function C(t, a) {
        if (0 === a.length)
            return [t];
        if (a instanceof Array && a.length && a[0]instanceof Array && 2 === a[0].length && a[0][0]instanceof Array) {
            for (var n = [t], r = 0, i; r < a.length; r++) {
                i = a[r];
                for (var l = 0; l < n.length; l++) {
                    var _ = n[l]
                      , d = C(_, i);
                    if (d) {
                        n.splice(l, 1),
                        n.push(d[0], d[1]);
                        break
                    }
                }
            }
            return n
        }
        var i = a
          , r = t.indexOf(i[0])
          , l = t.indexOf(i[1]);
        return -1 !== r && -1 !== l && [I(t, r, l), I(t, l, r)]
    }
    function d(t, a, n, r, _) {
        _ = _ || 0;
        var d = a[1] - t[1]
          , c = t[0] - a[0]
          , g = d * t[0] + c * t[1]
          , m = r[1] - n[1]
          , i = n[0] - r[0]
          , p = m * n[0] + i * n[1]
          , h = d * i - m * c;
        return u(h, 0, _) ? [0, 0] : [(i * g - c * p) / h, (d * p - m * g) / h]
    }
    function t(n, l, _, u, c, g, S) {
        var b = Number.MAX_VALUE;
        g = g || 100,
        S = S || 0,
        c = c || 25,
        l = 'undefined' == typeof l ? [] : l,
        _ = _ || [],
        u = u || [];
        var k = [0, 0]
          , L = [0, 0]
          , O = [0, 0]
          , M = 0
          , W = 0
          , N = 0
          , U = 0
          , V = 0
          , j = 0
          , X = 0
          , Y = []
          , K = []
          , H = n
          , I = n;
        if (3 > I.length)
            return l;
        if (S++,
        S > g)
            return console.warn('quickDecomp: max level (' + g + ') reached.'),
            l;
        for (var q = 0; q < n.length; ++q)
            if (R(H, q)) {
                _.push(H[q]),
                M = W = b;
                for (var J = 0; J < n.length; ++J)
                    G(P(H, q - 1), P(H, q), P(H, J)) && f(P(H, q - 1), P(H, q), P(H, J - 1)) && (O = d(P(H, q - 1), P(H, q), P(H, J), P(H, J - 1)),
                    e(P(H, q + 1), P(H, q), O) && (N = x(H[q], O),
                    N < W && (W = N,
                    L = O,
                    j = J))),
                    G(P(H, q + 1), P(H, q), P(H, J + 1)) && f(P(H, q + 1), P(H, q), P(H, J)) && (O = d(P(H, q + 1), P(H, q), P(H, J), P(H, J + 1)),
                    G(P(H, q - 1), P(H, q), O) && (N = x(H[q], O),
                    N < M && (M = N,
                    k = O,
                    V = J)));
                if (j === (V + 1) % n.length)
                    O[0] = (L[0] + k[0]) / 2,
                    O[1] = (L[1] + k[1]) / 2,
                    u.push(O),
                    q < V ? (a(Y, H, q, V + 1),
                    Y.push(O),
                    K.push(O),
                    0 !== j && a(K, H, j, H.length),
                    a(K, H, 0, q + 1)) : (0 !== q && a(Y, H, q, H.length),
                    a(Y, H, 0, V + 1),
                    Y.push(O),
                    K.push(O),
                    a(K, H, j, q + 1));
                else {
                    if (j > V && (V += n.length),
                    U = b,
                    V < j)
                        return l;
                    for (var J = j; J <= V; ++J)
                        T(P(H, q - 1), P(H, q), P(H, J)) && f(P(H, q + 1), P(H, q), P(H, J)) && (N = x(P(H, q), P(H, J)),
                        N < U && p(H, q, J) && (U = N,
                        X = J % n.length));
                    q < X ? (a(Y, H, q, X + 1),
                    0 != X && a(K, H, X, I.length),
                    a(K, H, 0, q + 1)) : (0 !== q && a(Y, H, q, I.length),
                    a(Y, H, 0, X + 1),
                    a(K, H, X, q + 1))
                }
                return Y.length < K.length ? (t(Y, l, _, u, c, g, S),
                t(K, l, _, u, c, g, S)) : (t(K, l, _, u, c, g, S),
                t(Y, l, _, u, c, g, S)),
                l
            }
        return l.push(n),
        l
    }
    function u(e, t, a) {
        return a = a || 0,
        Math.abs(e - t) <= a
    }
    function i(e, t, a) {
        return u(e[0], t[0], a) && u(e[1], t[1], a)
    }
    var tmpPoint1 = []
      , tmpPoint2 = []
      , tmpLine1 = []
      , tmpLine2 = [];
    self.polyDecomp = {
        decomp: function(e) {
            var t = r(e);
            return 0 < t.length ? C(e, t) : [e]
        },
        quickDecomp: t,
        isSimple: function(t) {
            var a = t, n;
            for (n = 0; n < a.length - 1; n++)
                for (var r = 0; r < n - 1; r++)
                    if (S(a[n], a[n + 1], a[r], a[r + 1]))
                        return !1;
            for (n = 1; n < a.length - 2; n++)
                if (S(a[0], a[a.length - 1], a[n], a[n + 1]))
                    return !1;
            return !0
        },
        removeCollinearPoints: function(e, t) {
            for (var a = 0, n = e.length - 1; 3 < e.length && 0 <= n; --n)
                g(P(e, n - 1), P(e, n), P(e, n + 1), t) && (e.splice(n % e.length, 1),
                a++);
            return a
        },
        removeDuplicatePoints: function(t, a) {
            for (var n = t.length - 1, r; 1 <= n; --n) {
                r = t[n];
                for (var l = n - 1; 0 <= l; --l)
                    if (i(r, t[l], a)) {
                        t.splice(n, 1);
                        continue
                    }
            }
        },
        makeCCW: function(t) {
            for (var a = 0, r = t, i = 1; i < t.length; ++i)
                (r[i][1] < r[a][1] || r[i][1] === r[a][1] && r[i][0] > r[a][0]) && (a = i);
            return !G(P(t, a - 1), P(t, a), P(t, a + 1)) && (n(t),
            !0)
        }
    }
}
{
    let e = !1
      , t = !1
      , n = 'dev';
    self.C3 = class {
        constructor() {
            throw TypeError('static class can\'t be instantiated')
        }
        static SetReady() {
            e = !0
        }
        static IsReady() {
            return e
        }
        static SetAppStarted() {
            t = !0
        }
        static HasAppStarted() {
            return t
        }
        static SetBuildMode(e) {
            n = e
        }
        static GetBuildMode() {
            return n
        }
        static IsReleaseBuild() {
            return 'final' === n
        }
    }
    ,
    C3.isDebug = !1,
    C3.isDebugDefend = !1,
    C3.hardwareConcurrency = navigator.hardwareConcurrency || 2
}
'use strict',
C3.QueryParser = class {
    constructor(e) {
        this._queryString = e,
        this._parameters = new Map,
        this._Parse()
    }
    _Parse() {
        let e = this._queryString;
        (e.startsWith('?') || e.startsWith('#')) && (e = e.substr(1));
        const t = e.split('&');
        for (const e of t)
            this._ParseParameter(e)
    }
    _ParseParameter(e) {
        if (e) {
            if (!e.includes('='))
                return void this._parameters.set(e, null);
            const t = e.indexOf('=')
              , a = decodeURIComponent(e.substring(0, t))
              , n = decodeURIComponent(e.substring(t + 1));
            this._parameters.set(a, n)
        }
    }
    LogAll() {
        for (const e of this._parameters)
            console.log('[QueryParser] Parameter \'' + e[0] + '\' = ' + (null === e[1] ? 'null' : '\'' + e[1] + '\''))
    }
    Has(e) {
        return this._parameters.has(e)
    }
    Get(e) {
        const t = this._parameters.get(e);
        return 'undefined' == typeof t ? null : t
    }
    ClearHash() {
        history.replaceState('', document.title, location.pathname + location.search)
    }
    Reparse(e) {
        this._queryString = e,
        this._parameters.clear(),
        this._Parse()
    }
}
,
C3.QueryString = new C3.QueryParser(location.search),
C3.LocationHashString = new C3.QueryParser(location.hash),
'dev' !== C3.QueryString.Get('mode') && C3.SetBuildMode('final'),
'use strict';
{
    function t(e, t, a) {
        if (!0 === t)
            a(),
            n.set(e, !0);
        else if (t && t.length)
            a(t[0]),
            n.set(e, !0);
        else
            ;
    }
    const r = navigator.userAgent;
    let a = {
        linux: /linux|openbsd|freebsd|netbsd/i.test(r),
        chromeOS: /CrOS/.test(r),
        windowsTizen: /trident|iemobile|msie|tizen/i.test(r),
        genericMS: /trident|iemobile|msie|edge\//i.test(r),
        opera: /OPR\//.test(r),
        blackberry: /bb10/i.test(r),
        edge: /edge\//i.test(r),
        trident: /trident/i.test(r),
        webkit: /webkit/i.test(r),
        safari: /safari\//i.test(r),
        chrome: /chrome\//i.test(r),
        chromium: /chromium\//i.test(r),
        crosswalk: /crosswalk|xwalk/i.test(r),
        nwjs: /nwjs/i.test(r),
        amazonwebapp: /amazonwebappplatform/i.test(r),
        webview: /wv\)/.test(r),
        android: /android/i.test(r),
        nokia: /nokiabrowser\/[0-9.]+/i.test(r)
    }
      , _ = {
        windows: /windows\s+nt\s+\d+\.\d+/i.exec(r),
        OSX: /mac\s+os\s+x\s+[0-9_]+/i.exec(r),
        android: /android\s+[0-9.]+/i.exec(r),
        opera: /OPR\/[0-9.]+/.exec(r),
        tizen: /tizen\s+[0-9.]+/i.exec(r),
        iphone: /iphone\s+os\s+[0-9_]+/i.exec(r),
        ipad: /ipad[^)]*os\s+[0-9_]+/i.exec(r),
        winPhone: /windows\s+phone\s+[0-9.]+/i.exec(r),
        winPhoneOS: /windows\s+phone\s+os\s+[0-9.]+/i.exec(r),
        chrome: /chrome\/[0-9.]+/i.exec(r),
        chromium: /chromium\/[0-9.]+/i.exec(r),
        nwjs: /nwjs\/[0-9.]+/i.exec(r),
        firefox: /firefox\/[0-9.]+/i.exec(r),
        ie: /msie\s+[0-9.]+/i.exec(r),
        edge: /edge\/[0-9.]+/i.exec(r),
        edgeChromium: /edg\/[0-9.]+/i.exec(r),
        silk: /silk\/[0-9.]+/i.exec(r)
    }
      , d = '(unknown)'
      , e = '(unknown)'
      , u = '(unknown)'
      , g = '(unknown)'
      , h = '(unknown)'
      , i = '(unknown)'
      , f = '(unknown)'
      , c = 'browser'
      , l = !1
      , m = !1
      , n = new Map;
    t('isWindows', _.windows, t=>{
        d = 'Windows';
        const a = t.split(' ')[2];
        a && ('5.0' === a ? e = '2000' : '5.1' === a ? e = 'XP' : '5.2' === a ? e = 'XP' : '6.0' === a ? e = 'Vista' : '6.1' === a ? e = '7' : '6.2' === a ? e = '8' : '6.3' === a ? e = '8.1' : '10.0' === a ? e = '10' : void 0)
    }
    ),
    t('isOSX', _.OSX, t=>{
        d = 'Mac OS X';
        const a = t.split(' ')[3];
        a && (e = a.replace('_', '.'))
    }
    ),
    t('isLinux', a.linux, ()=>{
        d = 'Linux'
    }
    ),
    t('isChromeOS', a.chromeOS, ()=>{
        d = 'Chrome OS'
    }
    ),
    t('isAndroid', !a.windowsTizen && _.android, t=>{
        d = 'Android';
        const a = t.split(' ')[1];
        a && (e = a)
    }
    ),
    t('isTizen', _.tizen, t=>{
        d = 'Tizen';
        const a = t.split(' ')[1];
        a && (e = a)
    }
    ),
    t('isIPhone', !a.windowsTizen && _.iphone, t=>{
        d = 'iOS';
        const a = t.split(' ')[2];
        a && (e = a.replace('_', '.'))
    }
    ),
    t('isIPad', !a.windowsTizen && _.ipad, t=>{
        d = 'iOS';
        const a = t.split(' ')[3];
        a && (e = a.replace('_', '.'))
    }
    ),
    t('isWindowsPhone', _.winPhone, t=>{
        d = 'Windows Phone';
        const a = t.split(' ')[2];
        a && (e = a)
    }
    ),
    t('isWindowsPhoneOS', _.winPhoneOS, t=>{
        d = 'Windows Phone';
        const a = t.split(' ')[3];
        a && (e = a)
    }
    ),
    t('isBlackberry', a.blackberry, ()=>{
        d = 'Blackberry',
        e = '10',
        g = 'stock',
        f = 'webkit'
    }
    ),
    t('isChrome', !a.edge && !a.opera && _.chrome, e=>{
        g = 'Chrome',
        f = 'Chromium';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isOpera', _.opera, e=>{
        g = 'Opera',
        f = 'Chromium';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isChromium', _.chromium, e=>{
        g = 'Chromium',
        f = 'Chromium';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isFirefox', _.firefox, e=>{
        g = 'Firefox',
        f = 'Gecko';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isInternetExplorer', _.ie, e=>{
        g = 'Internet Explorer',
        f = 'Trident';
        const t = e.split(' ')[1];
        t && (h = t)
    }
    ),
    t('isTrident', 'Internet Explorer' != g && a.trident, ()=>{
        f = 'Trident';
        const e = /rv:[0-9.]+/i.exec(r);
        if (e && e.length) {
            g = 'Internet Explorer';
            const t = e[0].split(':')[1];
            t && (h = t)
        }
    }
    ),
    t('isEdge', _.edge, e=>{
        g = 'Edge',
        f = 'Edge';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isEdgeChromium', _.edgeChromium, e=>{
        g = 'Edge',
        f = 'Chromium';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isSafari', a.safari && !a.nokia && !a.chrome && !a.chromium && !a.genericIE && !a.blackberry, ()=>{
        g = 'Safari',
        f = 'WebKit';
        const e = /version\/[0-9.]+/i.exec(r)
          , t = /crios\/[0-9.]+/i.exec(r)
          , n = /fxios\/[0-9.]+/i.exec(r);
        if (e && e.length) {
            const t = e[0].split('/')[1];
            t && (h = t)
        }
        if (t && t.length) {
            g = 'Chrome for iOS';
            const e = t[0].split('/')[1];
            e && (h = e)
        }
        if (n && n.length) {
            g = 'Firefox for iOS';
            const e = n[0].split('/')[1];
            e && (h = e)
        }
    }
    ),
    t('isSilk', _.silk, e=>{
        g = 'Silk';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isCrosswalk', a.crosswalk, ()=>c = 'crosswalk'),
    t('isCordova', self.device && (self.device.cordova || self.device.phonegap), ()=>c = 'cordova'),
    t('isNWJS', _.nwjs, e=>{
        c = 'nwjs',
        g = 'NW.js',
        f = 'Chromium';
        const t = e.split('/')[1];
        t && (h = t)
    }
    ),
    t('isAmazonWebApp', a.amazonwebapp, ()=>c = 'webapp'),
    t('isHomeScreenWebApp', 'nwjs' != c && 'undefined' != typeof window && (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches || navigator.standalone), ()=>c = 'webapp'),
    t('isFalseSafari', 'Safari' == g && ('Android' == d || 'Tizen' == d || 'Blackberry' == d), ()=>g = 'stock'),
    t('isAndroidWebview', 'Chrome' == g && 'browser' == c && a.webview, ()=>c = 'webview'),
    t('isFirefoxOS', 'Firefox' == g && '(unknown)' == d, ()=>d = 'Firefox OS'),
    t('isAndroidFallback', '(unknown)' == d && !a.windowsTizen && a.android, ()=>d = 'Android'),
    t('isTridentFallback', '(unknown)' == d && a.trident, ()=>f = 'Trident'),
    t('isWebkitFallback', '(unknown)' == d && a.webkit, ()=>f = 'WebKit'),
    t('is64Bit', (e=>e.test(r) || e.test(navigator.platform) || 'x64' === navigator.cpuClass)(/x86_64|x86-64|win64|x64;|x64\)|x64_|amd64|wow64|ia64|arm64|arch64|sparc64|ppc64|irix64/i), ()=>u = '64-bit'),
    t('is32Bit', (e=>e.test(r) || e.test(navigator.platform) || 'x86' === navigator.cpuClass)(/x86;|x86\)|i86|i386|i486|i586|i686|armv1|armv2|armv3|armv4|armv5|armv6|armv7/i), ()=>u = '32-bit'),
    t('is64BitFallback', '(unknown)' == u && 'Mac OS X' == d && 10.7 <= parseFloat(e), ()=>u = '64-bit'),
    t('is32BitFallback', '(unknown)' == u && 'Windows' == d || 'Android' == d && 5 > parseFloat(e), ()=>u = '32-bit'),
    t('is32BitBrowser', '32-bit' == u || /wow64/i.test(r), ()=>i = '32-bit'),
    t('is64BitBrowser', /win64/i.test(r), ()=>i = '64-bit'),
    t('isDesktop', (()=>'Windows' == d || 'Mac OS X' == d || 'Linux' == d || 'Chrome OS' == d || 'nwjs' == c)(), ()=>l = !0),
    'Edge' == f && 'undefined' != typeof Windows && 'undefined' != typeof Windows.System && (c = 'windows-store'),
    m = 'nwjs' == c;
    const S = 'Mac OS X' == d && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
    S && (d = 'iOS',
    e = h,
    l = !1,
    m = !1),
    C3.Platform = {
        OS: d,
        OSVersion: e,
        OSArchitecture: u,
        Browser: g,
        BrowserVersion: h,
        BrowserVersionNumber: parseFloat(h),
        BrowserArchitecture: i,
        BrowserEngine: f,
        Context: c,
        IsDesktop: l,
        IsMobile: !l,
        IsDesktopApp: m,
        IsChromeWebStore: !!(self.chrome && self.chrome.runtime && self.chrome.runtime.id),
        IsAppleOS: 'Mac OS X' == d || 'iOS' == d,
        IsIpadOS: S
    }
}
{
    function t(e) {
        return new Promise((t,a)=>{
            e.onsuccess = ()=>t(e.result),
            e.onerror = ()=>a(e.error)
        }
        )
    }
    function r(e) {
        return new Promise((t,a)=>{
            e.oncomplete = ()=>t(),
            e.onerror = ()=>a(e.error),
            e.onabort = ()=>a(e.error)
        }
        )
    }
    function a(e, t) {
        return u(e, t)
    }
    function _(e, t) {
        return u(e, t, !0)
    }
    async function u(t, n, r=!1, a=!0) {
        const i = await e(t);
        try {
            const e = i.transaction([h], r ? 'readwrite' : 'readonly');
            return n(e)
        } catch (e) {
            if (a && 'InvalidStateError' === e.name)
                return S.delete(t),
                u(t, n, r, !1);
            throw e
        }
    }
    function e(e) {
        g(e);
        let t = S.get(e);
        return t instanceof Promise || (t = d(e),
        S.set(e, t),
        t.catch(()=>S.delete(e))),
        t
    }
    async function d(e) {
        g(e);
        const a = indexedDB.open(e, i);
        return a.addEventListener('upgradeneeded', t=>{
            try {
                const e = t.target.result;
                e.createObjectStore(h)
            } catch (t) {
                console.error(`Failed to create objectstore for database ${e}`, t)
            }
        }
        ),
        t(a)
    }
    function g(e) {
        if ('string' != typeof e)
            throw new TypeError('expected string')
    }
    function p(e, t) {
        const n = e.objectStore(h).openCursor();
        return new Promise(r=>{
            const a = [];
            n.onsuccess = n=>{
                const i = n.target.result;
                i ? ('entries' === t ? a.push([i.key, i.value]) : 'keys' === t ? a.push(i.key) : 'values' === t ? a.push(i.value) : void 0,
                i.continue()) : r(a)
            }
        }
        )
    }
    const i = 2
      , h = 'keyvaluepairs'
      , S = new Map
      , l = 'undefined' != typeof IDBObjectStore && 'function' == typeof IDBObjectStore.prototype.getAll
      , m = 'undefined' != typeof IDBObjectStore && 'function' == typeof IDBObjectStore.prototype.getAllKeys;
    self.KVStorageContainer = class {
        constructor(e) {
            g(e),
            this.name = e
        }
        async ready() {
            await e(this.name)
        }
        set(a, n) {
            return g(a),
            _(this.name, async e=>{
                const i = e.objectStore('keyvaluepairs').put(n, a)
                  , l = t(i)
                  , _ = r(e);
                await Promise.all([_, l])
            }
            )
        }
        get(n) {
            return g(n),
            a(this.name, async a=>{
                const l = a.objectStore('keyvaluepairs').get(n)
                  , e = t(l)
                  , _ = r(a)
                  , [d,u] = await Promise.all([_, e]);
                return u
            }
            )
        }
        delete(a) {
            return g(a),
            _(this.name, async n=>{
                const i = n.objectStore('keyvaluepairs').delete(a)
                  , e = t(i)
                  , l = r(n);
                await Promise.all([l, e])
            }
            )
        }
        clear() {
            return _(this.name, async a=>{
                const n = a.objectStore('keyvaluepairs').clear()
                  , i = t(n)
                  , e = r(a);
                await Promise.all([e, i])
            }
            )
        }
        keys() {
            return a(this.name, async a=>{
                let n;
                if (m) {
                    const e = a.objectStore('keyvaluepairs').getAllKeys();
                    n = t(e)
                } else
                    n = p(a, 'keys');
                const i = r(a)
                  , [e,l] = await Promise.all([i, n]);
                return l
            }
            )
        }
        values() {
            return a(this.name, async a=>{
                let n;
                if (l) {
                    const e = a.objectStore('keyvaluepairs').getAll();
                    n = t(e)
                } else
                    n = p(a, 'values');
                const i = r(a)
                  , [e,_] = await Promise.all([i, n]);
                return _
            }
            )
        }
        entries() {
            return a(this.name, async t=>{
                const a = p(t, 'entries')
                  , n = r(t)
                  , [i,e] = await Promise.all([n, a]);
                return e
            }
            )
        }
    }
}
{
    function t(e) {
        throw new Error(`"${e}" is not implemented`)
    }
    function n(e) {
        if ('function' == typeof e)
            throw new Error(`localforage callback API is not implemented; please use the promise API instead`)
    }
    function r(e) {
        return 'object' == typeof e ? new Promise(t=>{
            const {port1: a, port2: n} = new MessageChannel;
            n.onmessage = e=>t(e.data),
            a.postMessage(e)
        }
        ) : Promise.resolve(e)
    }
    const i = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i]
      , l = new WeakMap;
    let e = !1;
    'undefined' == typeof indexedDB && (e = !0,
    console.warn('Unable to use local storage because indexedDB is not defined'));
    class _ {
        constructor(e) {
            this._inst = e,
            l.set(this, new Map)
        }
        _MaybeSwitchToMemoryFallback(t) {
            if (!e)
                for (const a of i)
                    if (t && a.test(t.message)) {
                        console.error('Unable to use local storage, reverting to in-memory store: ', t, t.message),
                        e = !0;
                        break
                    }
        }
        async _getItemFallback(e) {
            const t = l.get(this).get(e)
              , a = await r(t);
            return 'undefined' == typeof a ? null : a
        }
        async _setItemFallback(e, t) {
            t = await r(t),
            l.get(this).set(e, t)
        }
        _removeItemFallback(e) {
            l.get(this).delete(e)
        }
        _clearFallback() {
            l.get(this).clear()
        }
        _keysFallback() {
            return Array.from(l.get(this).keys())
        }
        IsUsingFallback() {
            return e
        }
        async getItem(t, a) {
            if (n(a),
            e)
                return await this._getItemFallback(t);
            let r;
            try {
                r = await this._inst.get(t)
            } catch (a) {
                return this._MaybeSwitchToMemoryFallback(a),
                e ? await this._getItemFallback(t) : (console.error(`Error reading '${t}' from storage, returning null: `, a),
                null)
            }
            return 'undefined' == typeof r ? null : r
        }
        async setItem(t, a, r) {
            if (n(r),
            'undefined' == typeof a && (a = null),
            e)
                return void (await this._setItemFallback(t, a));
            try {
                await this._inst.set(t, a)
            } catch (n) {
                if (this._MaybeSwitchToMemoryFallback(n),
                e)
                    await this._setItemFallback(t, a);
                else
                    throw n
            }
        }
        async removeItem(t, a) {
            if (n(a),
            e)
                return void this._removeItemFallback(t);
            try {
                await this._inst.delete(t)
            } catch (a) {
                this._MaybeSwitchToMemoryFallback(a),
                e ? this._removeItemFallback(t) : console.error(`Error removing '${t}' from storage: `, a)
            }
        }
        async clear(t) {
            if (n(t),
            e)
                return void this._clearFallback();
            try {
                await this._inst.clear()
            } catch (t) {
                this._MaybeSwitchToMemoryFallback(t),
                e ? this._clearFallback() : console.error(`Error clearing storage: `, t)
            }
        }
        async keys(t) {
            if (n(t),
            e)
                return this._keysFallback();
            let a = [];
            try {
                a = await this._inst.keys()
            } catch (t) {
                if (this._MaybeSwitchToMemoryFallback(t),
                e)
                    return this._keysFallback();
                console.error(`Error getting storage keys: `, t)
            }
            return a
        }
        ready(t) {
            return n(t),
            e ? Promise.resolve(!0) : this._inst.ready()
        }
        createInstance(e) {
            if ('object' != typeof e)
                throw new TypeError('invalid options object');
            const t = e.name;
            if ('string' != typeof t)
                throw new TypeError('invalid store name');
            const a = new KVStorageContainer(t);
            return new _(a)
        }
        length() {
            t('localforage.length()')
        }
        key() {
            t('localforage.key()')
        }
        iterate() {
            t('localforage.iterate()')
        }
        setDriver() {
            t('localforage.setDriver()')
        }
        config() {
            t('localforage.config()')
        }
        defineDriver() {
            t('localforage.defineDriver()')
        }
        driver() {
            t('localforage.driver()')
        }
        supports() {
            t('localforage.supports()')
        }
        dropInstance() {
            t('localforage.dropInstance()')
        }
        disableMemoryMode() {
            e = !1
        }
    }
    self.localforage = new _(new KVStorageContainer('localforage'))
}
{
    if (C3.Supports = {},
    C3.Supports.WebAnimations = (()=>{
        try {
            if ('Safari' === C3.Platform.Browser)
                return !1;
            if ('undefined' == typeof document)
                return !1;
            const e = document.createElement('div');
            if ('undefined' == typeof e.animate)
                return !1;
            const t = e.animate([{
                opacity: '0'
            }, {
                opacity: '1'
            }], 1e3);
            return 'undefined' != typeof t.reverse
        } catch (e) {
            return !1
        }
    }
    )(),
    C3.Supports.DialogElement = 'undefined' != typeof HTMLDialogElement,
    C3.Supports.RequestIdleCallback = !!self.requestIdleCallback,
    // C3.Supports.ImageBitmap = !!self.createImageBitmap,   //-ouley
    C3.Supports.ImageBitmapOptions = !1,
    C3.Supports.ImageBitmap)
        try {
            self.createImageBitmap(new ImageData(32,32), {
                premultiplyAlpha: 'none'
            }).then(()=>{
                C3.Supports.ImageBitmapOptions = !1  //#ouley
            }
            ).catch(()=>{
                C3.Supports.ImageBitmapOptions = !1
            }
            )
        } catch (e) {
            C3.Supports.ImageBitmapOptions = !1
        }

    C3.Supports.ClipboardReadText = !!(navigator.clipboard && navigator.clipboard.readText && 'Firefox' !== C3.Platform.Browser),
    C3.Supports.Proxies = 'undefined' != typeof Proxy,
    C3.Supports.DownloadAttribute = (()=>{
        if ('undefined' == typeof document)
            return !1;
        const e = document.createElement('a');
        return 'undefined' != typeof e.download
    }
    )(),
    C3.Supports.CanvasToBlob = (()=>'undefined' != typeof HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob)(),
    C3.Supports.CSSElement = 'undefined' != typeof CSS && CSS.supports('background', 'element(#test)'),
    C3.Supports.Fetch = 'function' == typeof fetch,
    C3.Supports.PersistentStorage = !!(self.isSecureContext && 'Opera' !== C3.Platform.Browser && navigator.storage && navigator.storage.persist),
    C3.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate),
    C3.Supports.Fullscreen = (()=>{
        if ('undefined' == typeof document)
            return !1;
        if ('iOS' === C3.Platform.OS)
            return !1;
        const e = document.documentElement;
        return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen)
    }
    )();
    const t = [{
        name: 'A',
        value: 12
    }, {
        name: 'B',
        value: 13
    }, {
        name: 'C',
        value: 13
    }, {
        name: 'D',
        value: 13
    }, {
        name: 'E',
        value: 13
    }, {
        name: 'F',
        value: 13
    }, {
        name: 'G',
        value: 14
    }, {
        name: 'H',
        value: 12
    }, {
        name: 'I',
        value: 12
    }, {
        name: 'J',
        value: 13
    }, {
        name: 'K',
        value: 14
    }]
      , n = Math.ceil(496 / t.length)
      , r = (n + '').length
      , i = [];
    for (const l of t)
        for (let e = 0; e <= n; e++)
            i.push({
                name: l.name + (e + '').padStart(r, '0'),
                value: l.value
            });
    i.sort((e,t)=>t.value - e.value);
    const a = i.reduce((e,t)=>{
        const a = t.name.slice(0, 1)
          , n = e.slice(-1);
        return n === a ? e : e + a
    }
    , '');
    C3.Supports.ArraySortProbablyStable = 'GKBCDEFJAHI' === a
}
{
    if (!String.prototype.trimStart) {
        const e = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(e, '')
        }
    }
    if (!String.prototype.trimEnd) {
        const e = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(e, '')
        }
    }
    if (Array.prototype.values || (Array.prototype.values = function*() {
        for (const e of this)
            yield e
    }
    ),
    !Array.prototype.flat) {
        function e(t, a) {
            return t.reduce((t,n)=>0 < a && Array.isArray(n) ? (Array.prototype.push.apply(t, e(n, a - 1)),
            t) : (t.push(n),
            t), [])
        }
        Array.prototype.flat = function(t=1) {
            return e(this, t)
        }
    }
    if (RegExp.escape || (RegExp.escape = function(e) {
        return (e + '').replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
    }
    ),
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise((e,t)=>navigator.webkitTemporaryStorage.queryUsageAndQuota((t,a)=>e({
            usage: t,
            quota: a
        }), t))
    }
    ),
    'undefined' == typeof HTMLCollection || HTMLCollection.prototype[Symbol.iterator] || (HTMLCollection.prototype[Symbol.iterator] = function() {
        let e = 0;
        return {
            next: ()=>e >= this.length ? {
                done: !0
            } : {
                value: this.item(e++),
                done: !1
            }
        }
    }
    ),
    'undefined' == typeof NodeList || NodeList.prototype[Symbol.iterator] || (NodeList.prototype[Symbol.iterator] = function() {
        let e = 0;
        return {
            next: ()=>e >= this.length ? {
                done: !0
            } : {
                value: this.item(e++),
                done: !1
            }
        }
    }
    ),
    'undefined' == typeof DOMTokenList || DOMTokenList.prototype[Symbol.iterator] || (DOMTokenList.prototype[Symbol.iterator] = function() {
        let e = 0;
        return {
            next: ()=>e >= this.length ? {
                done: !0
            } : {
                value: this.item(e++),
                done: !1
            }
        }
    }
    ),
    ('undefined' == typeof FileList || FileList.prototype[Symbol.iterator] || (FileList.prototype[Symbol.iterator] = function() {
        let e = 0;
        return {
            next: ()=>e >= this.length ? {
                done: !0
            } : {
                value: this.item(e++),
                done: !1
            }
        }
    }
    ),
    'undefined' == typeof TextEncoder && (self.TextEncoder = class {
        constructor() {
            Object.defineProperty(this, 'encoding', {
                value: 'utf-8',
                writable: !1
            })
        }
        encode(t) {
            for (var a = t.length, n = -1, r = new Uint8Array(3 * a), i = 0, l = 0, _ = 0; _ !== a; ) {
                if (i = t.charCodeAt(_),
                _ += 1,
                55296 <= i && 56319 >= i) {
                    if (_ === a) {
                        r[n += 1] = 239,
                        r[n += 1] = 191,
                        r[n += 1] = 189;
                        break
                    }
                    if (l = t.charCodeAt(_),
                    !(56320 <= l && 57343 >= l)) {
                        r[n += 1] = 239,
                        r[n += 1] = 191,
                        r[n += 1] = 189;
                        continue
                    } else if (i = 1024 * (i - 55296) + l - 56320 + 65536,
                    _ += 1,
                    65535 < i) {
                        r[n += 1] = 240 | i >>> 18,
                        r[n += 1] = 128 | 63 & i >>> 12,
                        r[n += 1] = 128 | 63 & i >>> 6,
                        r[n += 1] = 128 | 63 & i;
                        continue
                    }
                }
                127 >= i ? r[n += 1] = 0 | i : 2047 >= i ? (r[n += 1] = 192 | i >>> 6,
                r[n += 1] = 128 | 63 & i) : (r[n += 1] = 224 | i >>> 12,
                r[n += 1] = 128 | 63 & i >>> 6,
                r[n += 1] = 128 | 63 & i)
            }
            return new Uint8Array(r.buffer.slice(0, n + 1))
        }
        toString() {
            return '[object TextEncoder]'
        }
    }
    ,
    TextEncoder[Symbol.toStringTag] = 'TextEncoder'),
    'undefined' == typeof TextDecoder)) {
        function t(e) {
            const t = e[Symbol.iterator]();
            return {
                next: ()=>t.next(),
                [Symbol.iterator]() {
                    return this
                }
            }
        }
        function e(e) {
            const t = e.next();
            if (t.done)
                throw new Error('unexpected end of input');
            if (0 != (128 ^ 192 & t.value))
                throw new Error('invalid byte');
            return 63 & t.value
        }
        const n = new Map;
        n.set('utf-8', (a,n)=>{
            let r;
            if (a.buffer)
                r = new Uint8Array(a.buffer,a.byteOffset,a.byteLength);
            else if (r instanceof ArrayBuffer)
                r = new Uint8Array(a);
            else
                throw new Error('Invalid parameter');
            const i = t(r)
              , l = [];
            try {
                for (const t of i) {
                    let a;
                    if (127 > t)
                        a = 127 & t;
                    else if (223 > t)
                        a = (31 & t) << 6 | e(i);
                    else if (239 > t)
                        a = (15 & t) << 12 | e(i) << 6 | e(i);
                    else if (247 > t)
                        a = (7 & t) << 18 | e(i) << 12 | e(i) << 6 | e(i);
                    else
                        throw new Error('Invalid character');
                    l.push(String.fromCodePoint(a))
                }
            } catch (e) {
                if (n)
                    throw e;
                l.push('\uFFFD')
            }
            return l.join('')
        }
        ),
        n.set('utf8', n.get('utf-8')),
        n.set('utf-16le', ()=>{
            throw new Error('utf-16le decoder not implemented')
        }
        ),
        self.TextDecoder = class {
            constructor(e='utf-8', t={}) {
                const a = n.get(e);
                if (!a)
                    throw new Error(`TextDecoder polyfill does not support "${e}"`);
                Object.defineProperty(this, 'fatal', {
                    value: !0 === t.fatal,
                    writable: !1
                }),
                Object.defineProperty(this, '_decoder', {
                    value: a,
                    writable: !1
                }),
                Object.defineProperty(this, 'encoding', {
                    value: e,
                    writable: !1
                })
            }
            decode(e) {
                return this._decoder(e, this.fatal)
            }
            toString() {
                return '[object TextDecoder]'
            }
        }
        ,
        TextDecoder[Symbol.toStringTag] = 'TextDecoder'
    }
    'undefined' == typeof self.isSecureContext && (self.isSecureContext = 'https:' === location.protocol),
    'undefined' == typeof self.globalThis && (self.globalThis = self)
}
{
    function e(e) {
        let t = C3.GetCallStack();
        console.error('Assertion failure: ' + e + '\n\nStack trace:\n' + t)
    }
    self.assert = function(t, a) {
        t || e(a)
    }
}
{
    C3.IsNumber = function(e) {
        return 'number' == typeof e
    }
    ,
    C3.IsFiniteNumber = function(e) {
        return C3.IsNumber(e) && isFinite(e)
    }
    ,
    C3.RequireNumber = function(e) {
        if (!C3.IsNumber(e))
            throw new TypeError('expected number')
    }
    ,
    C3.RequireOptionalNumber = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireNumberInRange = function(e, t, a) {
        if (!C3.IsNumber(e) || isNaN(e) || t > e || a < e)
            throw new RangeError('number outside of range')
    }
    ,
    C3.RequireAllNumber = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.RequireFiniteNumber = function(e) {
        if (!C3.IsFiniteNumber(e))
            throw new TypeError('expected finite number')
    }
    ,
    C3.RequireOptionalFiniteNumber = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllFiniteNumber = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.IsString = function(e) {
        return 'string' == typeof e
    }
    ,
    C3.RequireString = function(e) {
        if (!C3.IsString(e))
            throw new TypeError('expected string')
    }
    ,
    C3.RequireOptionalString = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllString = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.IsSimpleObject = function(e) {
        if ('object' != typeof e || null === e)
            return !1;
        let t = Object.getPrototypeOf(e);
        return t ? t.constructor === Object : null === t
    }
    ,
    C3.RequireSimpleObject = function(e) {
        if (!C3.IsSimpleObject(e))
            throw new TypeError('expected simple object')
    }
    ,
    C3.RequireOptionalSimpleObject = function(e) {
        if (!C3.IsNullOrUndefined(e) && !C3.IsSimpleObject(e))
            throw new TypeError('expected simple object')
    }
    ,
    C3.IsObject = function(e) {
        return 'object' == typeof e && null !== e && !Array.isArray(e)
    }
    ,
    C3.RequireObject = function(e) {
        if (!C3.IsObject(e))
            throw new TypeError('expected object')
    }
    ,
    C3.RequireOptionalObject = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllObject = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.IsFileLike = function(e) {
        return C3.IsInstanceOf(e, Blob) && 'string' == typeof e.name
    }
    ,
    C3.RequireFileLike = function(e) {
        if (!C3.IsFileLike(e))
            throw new TypeError('expected file')
    }
    ,
    C3.RequireOptionalFileLike = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.IsArray = function(e) {
        return Array.isArray(e)
    }
    ,
    C3.RequireArray = function(e) {
        if (!C3.IsArray(e))
            throw new TypeError('expected array')
    }
    ,
    C3.RequireOptionalArray = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllArray = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.Is2DArray = function(e) {
        return !!C3.IsArray(e) && (!e.length || !!C3.IsArray(e[0]))
    }
    ,
    C3.Require2DArray = function(e) {
        if (!C3.Is2DArray(e))
            throw new TypeError('expected 2d array');
        for (let t of e)
            if (!C3.IsArray(t))
                throw new TypeError('expected 2d array')
    }
    ,
    C3.RequireOptional2DArray = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.IsFunction = function(e) {
        return 'function' == typeof e
    }
    ,
    C3.RequireFunction = function(e, t) {
        if (!C3.IsFunction(e))
            throw new TypeError('expected function');
        if (!C3.IsNullOrUndefined(t) && e !== t)
            throw new TypeError('expected same function reference')
    }
    ,
    C3.RequireOptionalFunction = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllFunction = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.RequireAnyFunction = function(e, ...t) {
        if (!C3.IsFunction(e))
            throw new TypeError('expected function');
        if (!t.length)
            throw new Error('missing comparison functions');
        for (let a of t)
            if (!C3.IsNullOrUndefined(a) && e === a)
                return;
        throw new TypeError('expected same function reference')
    }
    ,
    C3.RequireOptionalAllFunction = function(...e) {
        if (!C3.IsNullOrUndefined(e))
            for (let t of e)
                ;
    }
    ,
    C3.IsInstanceOf = function(e, t) {
        return e instanceof t
    }
    ,
    C3.IsInstanceOfAny = function(e, ...t) {
        for (let a of t)
            if (C3.IsInstanceOf(e, a))
                return !0;
        return !1
    }
    ,
    C3.RequireInstanceOf = function(e, t) {
        if (!C3.IsInstanceOf(e, t))
            throw new TypeError('unexpected type')
    }
    ,
    C3.RequireOptionalInstanceOf = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllInstanceOf = function(e, ...t) {
        for (let a of t)
            ;
    }
    ,
    C3.RequireAnyInstanceOf = function(e, ...t) {
        if (!C3.IsInstanceOfAny(e, ...t))
            throw new TypeError('unexpected type')
    }
    ,
    C3.RequireAnyOptionalInstanceOf = function(e, ...t) {
        if (!C3.IsNullOrUndefined(e) && !C3.IsInstanceOfAny(e, ...t))
            throw new TypeError('unexpected type')
    }
    ,
    C3.IsArrayOf = function(e, t) {
        for (let a of e)
            if (!C3.IsInstanceOf(a, t))
                return !1;
        return !0
    }
    ,
    C3.IsArrayOfFiniteNumbers = function(e) {
        for (let t of e)
            if (!C3.IsFiniteNumber(t))
                return !1;
        return !0
    }
    ,
    C3.RequireArrayOf = function(e) {
        for (let t of e)
            ;
    }
    ,
    C3.RequireOptionalArrayOf = function(e) {
        if (!C3.IsNullOrUndefined(e))
            for (let t of e)
                ;
    }
    ,
    C3.RequireArrayOfAny = function(e, ...t) {
        for (let a of e)
            ;
    }
    ,
    C3.RequireOptionalArrayOfAny = function(e, ...t) {
        if (!C3.IsNullOrUndefined(e))
            for (let t of e)
                ;
    }
    ,
    C3.IsDOMNode = function(e, t) {
        return !C3.IsNullOrUndefined(e) && C3.IsString(e.nodeName) && (!t || C3.equalsNoCase(e.nodeName, t))
    }
    ,
    C3.RequireDOMNode = function(e, t) {
        if (C3.IsNullOrUndefined(e) || !C3.IsString(e.nodeName))
            throw new TypeError('expected DOM node');
        if (t && !C3.equalsNoCase(e.nodeName, t))
            throw new TypeError(`expected DOM '${t}' node`)
    }
    ,
    C3.RequireOptionalDOMNode = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.IsHTMLElement = function(e, t) {
        return !C3.IsNullOrUndefined(e) && C3.IsString(e.tagName) && (!t || C3.equalsNoCase(e.tagName, t))
    }
    ,
    C3.RequireHTMLElement = function(e, t) {
        if (C3.IsNullOrUndefined(e) || !C3.IsString(e.tagName))
            throw new TypeError('expected HTML element');
        if (t && !C3.equalsNoCase(e.tagName, t))
            throw new TypeError(`expected HTML '${t}' element`)
    }
    ,
    C3.RequireOptionalHTMLElement = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.IsDrawable = function(e) {
        return C3.IsHTMLElement(e, 'img') || C3.IsHTMLElement(e, 'canvas') || C3.IsHTMLElement(e, 'video') || 'undefined' != typeof OffscreenCanvas && e instanceof OffscreenCanvas || 'undefined' != typeof ImageBitmap && e instanceof ImageBitmap
    }
    ,
    C3.RequireDrawable = function(e) {
        if (!C3.IsDrawable(e))
            throw new TypeError('expected drawable')
    }
    ,
    C3.RequireOptionalDrawable = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.IsDrawableOrImageData = function(e) {
        return !!(e instanceof ImageData) || C3.IsDrawable(e)
    }
    ,
    C3.RequireDrawableOrImageData = function(e) {
        if (!C3.IsDrawableOrImageData(e))
            throw new TypeError('expected drawable or image data')
    }
    ,
    C3.RequireOptionalDrawableOrImageData = function(e) {
        if (!C3.IsNullOrUndefined(e) && !C3.IsDrawableOrImageData(e))
            throw new TypeError('expected drawable or image data')
    }
    ,
    C3.IsStringLike = function(e) {
        return 'string' == typeof e || e instanceof C3.HtmlString || e instanceof C3.BBString
    }
    ,
    C3.RequireStringLike = function(e) {
        if (!C3.IsStringLike(e))
            throw new TypeError('expected string-like')
    }
    ,
    C3.RequireOptionalStringLike = function(e) {
        C3.IsNullOrUndefined(e)
    }
    ,
    C3.RequireAllStringLike = function(...e) {
        for (let t of e)
            ;
    }
    ,
    C3.RequireOverride = function() {
        throw new Error('must be overridden')
    }
    ,
    C3.NotYetImplemented = function() {
        throw new Error('not yet implemented')
    }
    ,
    C3.IsDefined = function(e, ...t) {
        let a = e;
        if ('undefined' == typeof a)
            return !1;
        for (let n of t) {
            if ('undefined' == typeof a[n])
                return !1;
            a = a[n]
        }
        return !0
    }
    ,
    C3.IsNullOrUndefined = function(e) {
        return 'undefined' == typeof e || null === e
    }
    ,
    C3.AreArrayElementsOfSameType = function(e) {
        let t = e[0].constructor;
        for (let a of e)
            if (a.constructor !== t)
                return !1;
        return t
    }
    ,
    C3.AreArrayElementsOfType = function(e, t) {
        for (let a of e)
            if (!(a instanceof t))
                return !1;
        return !0
    }
    ;
    const e = Object.getPrototypeOf(Uint8Array);
    C3.IsTypedArray = function(t) {
        return C3.IsInstanceOf(t, e)
    }
    ,
    C3.RequireTypedArray = function() {}
    ,
    C3.WeakRequireTypedArray = function(t) {
        C3.WeakRequireInstanceOf(t, e)
    }
    ,
    C3.WeakRequireAnyInstanceOf = function(e, ...t) {
        if (!C3.WeakIsAnyInstanceOf(e, ...t))
            throw new TypeError('unexpected type')
    }
    ,
    C3.WeakIsAnyInstanceOf = function(e, ...t) {
        for (const a of t)
            if (C3.WeakIsInstanceOf(e, a))
                return !0;
        return !1
    }
    ,
    C3.WeakRequireInstanceOf = function(e, t) {
        if (!C3.WeakIsInstanceOf(e, t))
            throw new TypeError('unexpected type')
    }
    ,
    C3.WeakIsInstanceOf = function(e, t) {
        for (; e = Object.getPrototypeOf(e); )
            if (e.constructor.name === t.name)
                return !0;
        return !1
    }
}
{
    function t(e, t) {
        let a = C3.getType(e)
          , n = C3.getType(t);
        return 'null' === a || 'null' === n || 'undefined' !== a && 'undefined' !== n && a === n
    }
    function n(e) {
        console.warn('[Defence] ' + e + ' @', C3.GetCallStack())
    }
    function r() {
        if (m = -1,
        0 < u.size || 0 < e.size) {
            let t = new Set([...u.keys()].map(e=>C3.getName(e)))
              , a = [...t].join(',');
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${a}`),
            u.clear(),
            e.clear()
        }
    }
    function _(e) {
        let t = new Set;
        for (let a in e)
            t.add(a);
        return t
    }
    function d(t, a) {
        let n = _(a)
          , r = p.get(t);
        if (r) {
            let e = [];
            for (let t of r.values())
                n.has(t) ? n.delete(t) : e.push(t);
            C3.appendArray(e, [...n]),
            e.length && console.warn(`[Defence] '${C3.getName(t)}' constructor creates inconsistent properties: ${e.join(', ')}`)
        } else
            p.set(t, n)
    }
    C3.GetCallStack = function() {
        return new Error().stack
    }
    ,
    C3.Debugger = function() {
        debugger
    }
    ,
    C3.cast = function(e, t) {
        return e && e instanceof t ? e : null
    }
    ,
    C3.getName = function(e) {
        return 'undefined' == typeof e ? 'undefined' : null === e ? 'null' : 'boolean' == typeof e ? '<boolean>' : C3.IsNumber(e) ? '<number>' : C3.IsString(e) ? '<string>' : C3.IsArray(e) ? '<array>' : 'symbol' == typeof e ? '<' + e.toString() + '>' : C3.IsFunction(e) ? e.name && 'Function' !== e.name ? e.name : '<anonymous function>' : 'object' == typeof e ? e.constructor && e.constructor.name && 'Object' !== e.constructor.name ? e.constructor.name : '<anonymous object>' : '<unknown>'
    }
    ,
    C3.getType = function(e) {
        return null === e ? 'null' : Array.isArray(e) ? 'array' : typeof e
    }
    ,
    C3.range = function*(e, t) {
        if (!isFinite(Math.abs(e - t)))
            throw new Error('Invalid parameters');
        if (e > t)
            for (let a = e - 1; a >= t; a--)
                yield a;
        else
            for (let a = e; a < t; a++)
                yield a
    }
    ;
    let u = new Map
      , e = new Map
      , c = new WeakMap
      , g = new WeakMap;
    C3.DefendHandler = {};
    const i = new Set(['then', 'splice']);
    C3.DefendHandler.get = function(e, t) {
        return t in e || 'symbol' == typeof t || i.has(t) || n(`Accessed missing property '${t}' from defended object '${C3.getName(e)}', returning undefined`),
        g.has(e) && 'symbol' != typeof t && !i.has(t) && n(`Accessed property '${t}' on a released object '${C3.getName(e)}'\nObject was originally released at: ${g.get(e)})\nCall stack at access: `),
        e[t]
    }
    ,
    C3.DefendHandler.set = function(a, r, i) {
        return r in a || u.has(a) || n(`Set non-existent property '${r}' to '${i}' on defended object '${C3.getName(a)}'`),
        t(a[r], i) || u.has(a) || n(`Set '${C3.getType(a[r])}' property '${r}' to type '${C3.getType(i)}' on defended object '${C3.getName(a)}'`),
        g.has(a) && n(`Set property '${r}' on a released object '${C3.getName(a)}'\nObject was originally released at: ${g.get(a)})\nCall stack at access: `),
        a[r] = i,
        !0
    }
    ,
    C3.DefendHandler.deleteProperty = function(e, t) {
        throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C3.getName(e)}'`)
    }
    ,
    C3.DefendHandler.defineProperty = function(e, t) {
        throw new ReferenceError(`Cannot define property '${t}' on defended object '${C3.getName(e)}'`)
    }
    ,
    C3.DefendHandler.enumerate = function(e) {
        throw new ReferenceError(`Cannot enumerate defended object '${C3.getName(e)}'`)
    }
    ;
    let m = -1;
    C3.DefendedBase = class {
        constructor() {
            if (C3.isDebugDefend && C3.Supports.Proxies) {
                let t = new.target
                  , a = Object.create(t.prototype)
                  , n = new Proxy(a,C3.DefendHandler);
                return u.set(a, n),
                e.set(n, a),
                c.set(n, a),
                -1 === m && (m = requestAnimationFrame(r)),
                n
            }
        }
    }
    ,
    C3.debugDefend = function(t) {
        if (C3.isDebugDefend && C3.Supports.Proxies && t instanceof C3.DefendedBase) {
            if (!e.has(t))
                return t;
            let a = e.get(t);
            return e.delete(t),
            u.delete(a),
            t
        }
        return C3.isDebug ? Object.seal(t) : t
    }
    ,
    C3.New = function(t, ...a) {
        let n;
        try {
            n = new t(...a)
        } catch (t) {
            throw e.clear(),
            u.clear(),
            t
        }
        return C3.isDebugDefend && d(t, n),
        C3.debugDefend(n)
    }
    ,
    C3.Release = function(e) {
        let t = c.get(e);
        t && g.set(t, C3.GetCallStack())
    }
    ,
    C3.WasReleased = function(e) {
        let t = c.get(e);
        return !!t && !!g.get(t)
    }
    ;
    let p = new Map;
    C3.PerfMark = class {
        constructor(e) {
            this._name = '',
            e && this.start(e)
        }
        start(e) {
            this._name = e,
            performance.mark(this._name + '-Start')
        }
        end() {
            performance.mark(this._name + '-End'),
            performance.measure(this._name, this._name + '-Start', this._name + '-End')
        }
        next(e) {
            this.end(),
            this._name = e,
            performance.mark(this._name + '-Start')
        }
    }
}
{
    function t(e) {
        return 0 === e && 0 > 1 / e
    }
    const a = 2 * Math.PI
      , n = Math.PI / 180
      , r = 180 / Math.PI;
    C3.wrap = function(e, t, n) {
        var r = Math.floor;
        if (e = r(e),
        t = r(t),
        n = r(n),
        e < t) {
            let a = n - (t - e) % (n - t);
            return a === n ? 0 : a
        }
        return t + (e - t) % (n - t)
    }
    ,
    C3.mapToRange = function(t, a, n, r, i) {
        return (t - a) * (i - r) / (n - a) + r
    }
    ,
    C3.normalize = function(e, t, a) {
        return (e - t) / (a - t)
    }
    ,
    C3.clamp = function(e, t, n) {
        return e < t ? t : e > n ? n : e
    }
    ,
    C3.clampAngle = function(e) {
        return e %= a,
        0 > e && (e += a),
        e
    }
    ,
    C3.toRadians = function(e) {
        return e * n
    }
    ,
    C3.toDegrees = function(e) {
        return e * r
    }
    ,
    C3.distanceTo = function(e, t, a, n) {
        return Math.hypot(a - e, n - t)
    }
    ,
    C3.distanceSquared = function(t, a, n, r) {
        const i = n - t
          , e = r - a;
        return i * i + e * e
    }
    ,
    C3.angleTo = function(e, t, a, n) {
        return Math.atan2(n - t, a - e)
    }
    ,
    C3.angleDiff = function(t, a) {
        var n = Math.cos
          , r = Math.sin;
        if (t === a)
            return 0;
        let l = r(t)
          , e = n(t)
          , _ = r(a)
          , d = n(a)
          , u = l * _ + e * d;
        return 1 <= u ? 0 : -1 >= u ? Math.PI : Math.acos(u)
    }
    ,
    C3.angleRotate = function(t, a, n) {
        var r = Math.cos
          , l = Math.sin;
        let e = l(t)
          , _ = r(t)
          , d = l(a)
          , u = r(a);
        return Math.acos(e * d + _ * u) > n ? 0 < _ * d - e * u ? C3.clampAngle(t + n) : C3.clampAngle(t - n) : C3.clampAngle(a)
    }
    ,
    C3.angleClockwise = function(t, a) {
        var n = Math.cos
          , r = Math.sin;
        let i = r(t)
          , e = n(t)
          , l = r(a)
          , _ = n(a);
        return 0 >= e * l - i * _
    }
    ,
    C3.angleLerp = function(e, t, a) {
        let n = C3.angleDiff(e, t);
        return C3.angleClockwise(t, e) ? C3.clampAngle(e + n * a) : C3.clampAngle(e - n * a)
    }
    ,
    C3.lerp = function(e, t, a) {
        return e + a * (t - e)
    }
    ,
    C3.unlerp = function(e, t, a) {
        return e === t ? 0 : (a - e) / (t - e)
    }
    ,
    C3.relerp = function(t, e, a, n, r) {
        return C3.lerp(n, r, C3.unlerp(t, e, a))
    }
    ,
    C3.qarp = function(e, t, a, n) {
        return C3.lerp(C3.lerp(e, t, n), C3.lerp(t, a, n), n)
    }
    ,
    C3.cubic = function(t, e, a, n, r) {
        return C3.lerp(C3.qarp(t, e, a, r), C3.qarp(e, a, n, r), r)
    }
    ,
    C3.cosp = function(e, t, a) {
        return (e + t + (e - t) * Math.cos(a * Math.PI)) / 2
    }
    ,
    C3.isPOT = function(e) {
        return 0 < e && 0 == (e - 1 & e)
    }
    ,
    C3.nextHighestPowerOfTwo = function(e) {
        --e;
        for (let t = 1; 32 > t; t <<= 1)
            e |= e >> t;
        return e + 1
    }
    ,
    C3.roundToNearestFraction = function(e, t) {
        return Math.round(e * t) / t
    }
    ,
    C3.floorToNearestFraction = function(e, t) {
        return Math.floor(e * t) / t
    }
    ,
    C3.round6dp = function(e) {
        return Math.round(1e6 * e) / 1e6
    }
    ,
    C3.toFixed = function(e, t) {
        let a = e.toFixed(t)
          , n = a.length - 1;
        for (; 0 <= n && '0' === a.charAt(n); --n)
            ;
        return 0 <= n && '.' === a.charAt(n) && --n,
        0 > n ? a : a.substr(0, n + 1)
    }
    ,
    C3.PackRGB = function(e, t, a) {
        return C3.clamp(e, 0, 255) | C3.clamp(t, 0, 255) << 8 | C3.clamp(a, 0, 255) << 16
    }
    ;
    const i = 1024;
    C3.PackRGBAEx = function(e, t, n, r) {
        var l = Math.floor;
        return e = C3.clamp(l(1024 * e), -8192, 8191),
        t = C3.clamp(l(1024 * t), -8192, 8191),
        n = C3.clamp(l(1024 * n), -8192, 8191),
        r = C3.clamp(l(1023 * r), 0, 1023),
        0 > e && (e += 16384),
        0 > t && (t += 16384),
        0 > n && (n += 16384),
        -(16384 * (16384 * e) * i + 16384 * t * i + n * i + r)
    }
    ,
    C3.PackRGBEx = function(e, t, a) {
        return C3.PackRGBAEx(e, t, a, 1)
    }
    ,
    C3.GetRValue = function(e) {
        if (0 <= e)
            return (255 & e) / 255;
        else {
            let t = Math.floor(-e / 274877906944);
            return 8191 < t && (t -= 16384),
            t / 1024
        }
    }
    ,
    C3.GetGValue = function(e) {
        if (0 <= e)
            return ((65280 & e) >> 8) / 255;
        else {
            let t = Math.floor(-e % 274877906944 / 16777216);
            return 8191 < t && (t -= 16384),
            t / 1024
        }
    }
    ,
    C3.GetBValue = function(e) {
        if (0 <= e)
            return ((16711680 & e) >> 16) / 255;
        else {
            let t = Math.floor(-e % 16777216 / i);
            return 8191 < t && (t -= 16384),
            t / 1024
        }
    }
    ,
    C3.GetAValue = function(e) {
        if (t(e))
            return 0;
        if (0 <= e)
            return 1;
        else {
            const t = Math.floor(-e % i);
            return t / 1023
        }
    }
    ,
    C3.greatestCommonDivisor = function(e, t) {
        var n = Math.floor;
        for (e = n(e),
        t = n(t); 0 !== t; ) {
            let a = t;
            t = e % t,
            e = a
        }
        return e
    }
    ;
    const e = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
    C3.getAspectRatio = function(t, n) {
        var r = Math.abs
          , i = Math.floor;
        if (t = i(t),
        n = i(n),
        t === n)
            return [1, 1];
        for (let a of e) {
            let i = t / a[0] * a[1];
            if (1 > r(n - i))
                return a.slice(0);
            if (i = t / a[1] * a[0],
            1 > r(n - i))
                return [a[1], a[0]]
        }
        let l = C3.greatestCommonDivisor(t, n);
        return [t / l, n / l]
    }
    ,
    C3.segmentsIntersect = function(_, a, d, c, e, f, g, h) {
        var i = Math.abs;
        let S = 0
          , G = 0
          , b = 0
          , T = 0
          , I = 0
          , C = 0
          , P = 0
          , A = 0;
        if (_ < d ? (G = _,
        S = d) : (G = d,
        S = _),
        e < g ? (C = e,
        I = g) : (C = g,
        I = e),
        S < C || G > I)
            return !1;
        if (a < c ? (T = a,
        b = c) : (T = c,
        b = a),
        f < h ? (A = f,
        P = h) : (A = h,
        P = f),
        b < A || T > P)
            return !1;
        let R = e - _ + g - d
          , E = f - a + h - c
          , t = d - _
          , u = c - a
          , v = g - e
          , D = h - f
          , x = i(u * v - D * t);
        return !(i(v * E - D * R) > x) && i(t * E - u * R) <= x
    }
    ,
    C3.segmentsIntersectPreCalc = function(_, a, d, c, e, f, g, h, i, S, G, l) {
        var m = Math.abs;
        let n = 0
          , b = 0
          , T = 0
          , I = 0;
        if (i < G ? (b = i,
        n = G) : (b = G,
        n = i),
        f < b || e > n)
            return !1;
        if (S < l ? (I = S,
        T = l) : (I = l,
        T = S),
        h < I || g > T)
            return !1;
        let C = i - _ + G - d
          , P = S - a + l - c
          , t = d - _
          , u = c - a
          , v = G - i
          , A = l - S
          , x = m(u * v - A * t);
        return !(m(v * P - A * C) > x) && m(t * P - u * C) <= x
    }
    ,
    C3.segmentIntersectsQuad = function(t, a, r, _, d) {
        let e = 0
          , u = 0
          , c = 0
          , S = 0;
        t < r ? (e = t,
        u = r) : (e = r,
        u = t),
        a < _ ? (c = a,
        S = _) : (c = _,
        S = a);
        const y = d.getTlx()
          , G = d.getTly()
          , b = d.getTrx()
          , l = d.getTry()
          , m = d.getBrx()
          , n = d.getBry()
          , T = d.getBlx()
          , p = d.getBly();
        return C3.segmentsIntersectPreCalc(t, a, r, _, e, u, c, S, y, G, b, l) || C3.segmentsIntersectPreCalc(t, a, r, _, e, u, c, S, b, l, m, n) || C3.segmentsIntersectPreCalc(t, a, r, _, e, u, c, S, m, n, T, p) || C3.segmentsIntersectPreCalc(t, a, r, _, e, u, c, S, T, p, y, G)
    }
    ,
    C3.segmentIntersectsAnyN = function(t, a, n, r, l) {
        let e = 0
          , _ = 0
          , d = 0
          , u = 0;
        t < n ? (e = t,
        _ = n) : (e = n,
        _ = t),
        a < r ? (d = a,
        u = r) : (d = r,
        u = a);
        let c = 0;
        for (let g = l.length - 4; c <= g; c += 2)
            if (C3.segmentsIntersectPreCalc(t, a, n, r, e, _, d, u, l[c], l[c + 1], l[c + 2], l[c + 3]))
                return !0;
        return C3.segmentsIntersectPreCalc(t, a, n, r, e, _, d, u, l[c], l[c + 1], l[0], l[1])
    }
    ,
    C3.rayIntersect = function(t, a, n, r, _, e, d, u) {
        const c = n - t
          , i = u - e
          , g = c * i - (r - a) * (d - _);
        if (0 == g)
            return 2;
        const m = ((a - r) * (d - t) + c * (u - a)) / g;
        return 0 < m && m < 1 + 1e-6 ? (i * (d - t) + (_ - d) * (u - a)) / g : 2
    }
}
{
    let t = null
      , a = '';
    if ('undefined' != typeof document) {
        t = document;
        const e = document.querySelector('base');
        a = e && e.hasAttribute('href') ? e.getAttribute('href') : '',
        a && (a.startsWith('/') && (a = a.substr(1)),
        !a.endsWith('/') && (a += '/'))
    }
    C3.GetBaseURL = function() {
        if (!t)
            return '';
        const e = t.location;
        return C3.GetPathFromURL(e.origin + e.pathname) + a
    }
    ,
    C3.GetPathFromURL = function(e) {
        if (!e.length)
            return e;
        if (e.endsWith('/') || e.endsWith('\\'))
            return e;
        const t = Math.max(e.lastIndexOf('/'), e.lastIndexOf('\\'));
        return -1 === t ? '' : e.substr(0, t + 1)
    }
    ,
    C3.GetFilenameFromURL = function(e) {
        if (!e.length)
            return e;
        if (e.endsWith('/') || e.endsWith('\\'))
            return '';
        const t = Math.max(e.lastIndexOf('/'), e.lastIndexOf('\\'));
        return -1 === t ? e : e.substr(t + 1)
    }
    ,
    C3.DataTransferHasFiles = function(e) {
        if (e.types)
            for (let t = 0; t < e.types.length; t++)
                if ('Files' === e.types[t] || 'application/x-c3-file' === e.types[t])
                    return !0;
        return !1
    }
    ,
    C3.DataTransferFilterFiles = async function(e, t) {
        const a = Array.from(e.files).filter(e=>0 !== e.size).filter(e=>t(e)).map(async e=>{
            try {
                return await C3.CloneFile(e)
            } catch (e) {
                return null
            }
        }
        )
          , n = await Promise.all(a);
        return n.filter(e=>e)
    }
    ,
    C3.IsFileAnImage = function(e) {
        return -1 !== e.type.search(/image\/.*/)
    }
    ,
    C3.IsFileAnSVG = function(e) {
        return 'image/svg+xml' === e.type
    }
    ,
    C3.GetFileExtension = function(e) {
        let t = e.lastIndexOf('.');
        return 1 > t ? '' : e.substr(t)
    }
    ,
    C3.GetFileNamePart = function(e) {
        let t = e.lastIndexOf('.');
        return 1 > t ? e : e.substr(0, t)
    }
    ,
    C3.NormalizeFileSeparator = function(e) {
        return e.replace(/\\/g, '/')
    }
    ,
    C3.ParseFilePath = function(t) {
        t = C3.NormalizeFileSeparator(t);
        let n = /^\w\:\//.exec(t);
        n ? (n = n[0],
        t = t.slice(3),
        '/' !== t[0] && (t = '/' + t)) : n = '',
        t = t.replace(/\/{2,}/g, '/'),
        1 < t.length && '/' === t.slice(-1) && (t = t.slice(0, -1));
        const r = t.lastIndexOf('/') + 1;
        let l = '', _ = t, u = '', c;
        0 < r && (l = t.slice(0, r),
        _ = t.slice(r)),
        c = _;
        const m = _.lastIndexOf('.');
        0 < m && (u = _.slice(m),
        c = _.slice(0, -u.length));
        const p = n + l + _;
        return {
            dir: l,
            base: _,
            name: c,
            root: n,
            ext: u,
            full: p
        }
    }
    ,
    C3.Wait = function(e, t) {
        return new Promise(a=>{
            self.setTimeout(a, e, t)
        }
        )
    }
    ,
    C3.swallowException = function(e) {
        try {
            e()
        } catch (e) {
            C3.isDebug && console.warn('Swallowed exception: ', e)
        }
    }
    ,
    C3.noop = function() {}
    ,
    C3.equalsNoCase = function(e, t) {
        return 'string' == typeof e && 'string' == typeof t && (e === t || (e = e.normalize(),
        t = t.normalize(),
        e.length === t.length && e.toLowerCase() === t.toLowerCase()))
    }
    ,
    C3.equalsCase = function(e, t) {
        return 'string' == typeof e && 'string' == typeof t && (e === t || e.normalize() === t.normalize())
    }
    ,
    C3.stableSort = function(t, e) {
        if (C3.Supports.ArraySortProbablyStable)
            return void t.sort(e);
        const a = t.map((e,t)=>[e, t]);
        a.sort((t,n)=>{
            const a = e(t[0], n[0]);
            return 0 === a ? t[1] - n[1] : a
        }
        );
        for (let n = 0, r = t.length; n < r; ++n)
            t[n] = a[n][0]
    }
    ,
    C3.typedArraySet16 = function(e, t, a) {
        e[a++] = t[0],
        e[a++] = t[1],
        e[a++] = t[2],
        e[a++] = t[3],
        e[a++] = t[4],
        e[a++] = t[5],
        e[a++] = t[6],
        e[a++] = t[7],
        e[a++] = t[8],
        e[a++] = t[9],
        e[a++] = t[10],
        e[a++] = t[11],
        e[a++] = t[12],
        e[a++] = t[13],
        e[a++] = t[14],
        e[a] = t[15]
    }
    ,
    C3.truncateArray = function(e, t) {
        e.length = t
    }
    ,
    C3.clearArray = function(e) {
        e && 0 !== e.length && C3.truncateArray(e, 0)
    }
    ,
    C3.clear2DArray = function(e) {
        if (e) {
            for (let t = 0, a; t < e.length; t++)
                a = e[t],
                C3.truncateArray(a, 0);
            C3.truncateArray(e, 0)
        }
    }
    ,
    C3.extendArray = function(t, a, n) {
        a |= 0;
        const r = t.length;
        if (!(a <= r))
            for (let i = r; i < a; ++i)
                t.push(n)
    }
    ,
    C3.resizeArray = function(e, t, a) {
        t |= 0;
        const n = e.length;
        t < n ? C3.truncateArray(e, t) : t > n && C3.extendArray(e, t, a)
    }
    ,
    C3.shallowAssignArray = function(e, t) {
        C3.clearArray(e),
        C3.appendArray(e, t)
    }
    ,
    C3.appendArray = function(e, t) {
        if (1e4 > t.length)
            e.push(...t);
        else
            for (let a = 0, n = t.length; a < n; ++a)
                e.push(t[a])
    }
    ,
    C3.arrayRemove = function(e, t) {
        if (t = Math.floor(t),
        !(0 > t || t >= e.length)) {
            let a = e.length - 1;
            for (let n = t; n < a; ++n)
                e[n] = e[n + 1];
            C3.truncateArray(e, a)
        }
    }
    ,
    C3.arrayFindRemove = function(e, t) {
        let a = e.indexOf(t);
        0 <= a && e.splice(a, 1)
    }
    ,
    C3.arraysEqual = function(e, t) {
        let a = e.length;
        if (t.length !== a)
            return !1;
        for (let n = 0; n < a; ++n)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    ,
    C3.arrayFilterOut = function(t, a) {
        let n = []
          , r = 0;
        for (let i = 0, l = t.length, _; i < l; ++i)
            _ = t[i],
            a(_) ? n.push(_) : (t[r] = _,
            ++r);
        return C3.truncateArray(t, r),
        n
    }
    ,
    C3.arrayRemoveAllInSet = function(t, a) {
        const e = t.length;
        let n = 0;
        for (let r = 0, e = t.length, i; r < e; ++r)
            i = t[r],
            a.has(i) || (t[n++] = i);
        return C3.truncateArray(t, n),
        e - n
    }
    ,
    C3.isArrayIndexInBounds = function(e, t) {
        return e === Math.floor(e) && 0 <= e && e < t.length
    }
    ,
    C3.validateArrayIndex = function(e, t) {
        if (!C3.isArrayIndexInBounds(e, t))
            throw new RangeError('array index out of bounds')
    }
    ,
    C3.cloneArray = function(e) {
        return e.slice()
    }
    ,
    C3.deepCloneArray = function(e, t) {
        let n = [];
        for (let r of e)
            if (C3.IsObject(r)) {
                let e = t(r);
                if (!e)
                    throw new Error('missing clone');
                if (e.constructor !== r.constructor)
                    throw new Error('object is not a clone');
                n.push(e)
            } else
                C3.IsArray(r) ? n.push(C3.deepCloneArray(r, t)) : n.push(r);
        return n
    }
    ,
    C3.clone2DArray = function(e) {
        let t = [];
        for (let a of e)
            t.push(a.slice());
        return t
    }
    ,
    C3.mergeSets = function(e, t) {
        return new Set([...e, ...t])
    }
    ,
    C3.first = function(e) {
        for (let t of e)
            return t;
        return null
    }
    ,
    C3.xor = function(e, t) {
        return !e != !t
    }
    ,
    C3.compare = function(e, t, a) {
        return 0 === t ? e === a : 1 === t ? e !== a : 2 === t ? e < a : 3 === t ? e <= a : 4 === t ? e > a : 5 == t && e >= a
    }
    ,
    C3.hasAnyOwnProperty = function(e) {
        for (let t in e)
            if (e.hasOwnProperty(t))
                return !0;
        return !1
    }
    ,
    C3.PromiseAllWithProgress = function(t, a) {
        return t.length ? new Promise((n,r)=>{
            const l = [];
            let e = 0
              , i = !1;
            for (let _ = 0, d = t.length; _ < d; ++_)
                l.push(void 0),
                t[_].then(r=>{
                    i || (l[_] = r,
                    ++e,
                    e === t.length ? n(l) : a(e, t.length))
                }
                ).catch(e=>{
                    i = !0,
                    r(e)
                }
                )
        }
        ) : Promise.resolve([])
    }
    ;
    let n = [];
    C3.AddLibraryMemoryCallback = function(e) {
        n.push(e)
    }
    ,
    C3.GetEstimatedLibraryMemoryUsage = function() {
        let e = 0;
        for (let t of n) {
            let a = t();
            e += a
        }
        return Math.floor(e)
    }
    ;
    const r = new MessageChannel;
    r.port2.onmessage = function(t) {
        const a = t.data
          , n = e.get(a);
        e.delete(a),
        n && n(t.timeStamp)
    }
    ;
    let i = 1;
    const e = new Map;
    C3.RequestUnlimitedAnimationFrame = function(t) {
        const a = i++;
        return e.set(a, t),
        r.port1.postMessage(a),
        a
    }
    ,
    C3.CancelUnlimitedAnimationFrame = function(t) {
        e.delete(t)
    }
    ,
    C3.PostTask = C3.RequestUnlimitedAnimationFrame,
    C3.WaitForNextTask = function() {
        return new Promise(e=>C3.PostTask(e))
    }
    ;
    const l = new Set;
    C3.RequestPostAnimationFrame = function(e) {
        const t = self.requestAnimationFrame(async a=>{
            await C3.WaitForNextTask(),
            l.has(t) && (l.delete(t),
            e(a))
        }
        );
        return l.add(t),
        t
    }
    ,
    C3.CancelPostAnimationFrame = function(e) {
        l.has(e) && (self.cancelAnimationFrame(e),
        l.delete(e))
    }
}
'use strict',
C3.IsAbsoluteURL = function(e) {
    return /^(?:[a-z]+:)?\/\//.test(e) || 'data:' === e.substr(0, 5) || 'blob:' === e.substr(0, 5)
}
,
C3.IsRelativeURL = function(e) {
    return !C3.IsAbsoluteURL(e)
}
,
C3.ThrowIfNotOk = function(e) {
    if (!e.ok)
        throw new Error(`fetch '${e.url}' response returned ${e.status} ${e.statusText}`)
}
,
C3.FetchOk = function(e, t) {
    return fetch(e, t).then(e=>(C3.ThrowIfNotOk(e),
    e))
}
,
C3.FetchText = function(e) {
    return C3.FetchOk(e).then(e=>e.text())
}
,
C3.FetchJson = function(e) {
    return C3.FetchOk(e).then(e=>e.json())
}
,
C3.FetchBlob = function(e) {
    return C3.FetchOk(e).then(
		e=>e.blob()
	)
}
,
C3.FetchArrayBuffer = function(e) {
    return C3.FetchOk(e).then(e=>e.arrayBuffer())
}
,
C3.FetchImage = function(e) {
    return new Promise((t,n)=>{
        const a = new Image;
        a.onload = ()=>t(a),
        a.onerror = e=>n(e),
        a.src = e
    }
    )
}
,
C3.BlobToArrayBuffer = function(e) {
    return new Promise((t,a)=>{
        const n = new FileReader;
        n.onload = ()=>t(n.result),
        n.onerror = ()=>a(n.error),
        n.readAsArrayBuffer(e)
    }
    )
}
,
C3.BlobToString = function(e) {
    return new Promise((t,a)=>{
        const n = new FileReader;
        n.onload = ()=>t(n.result),
        n.onerror = ()=>a(n.error),
        n.readAsText(e)
    }
    )
}
,
C3.BlobToJson = function(e) {
    return C3.BlobToString(e).then(e=>JSON.parse(e))
}
,
C3.BlobToImage = async function(e, t) {
    let n = URL.createObjectURL(e);
    try {
        const e = await C3.FetchImage(n);
        return URL.revokeObjectURL(n),
        n = '',
        t && 'function' == typeof e.decode && (await e.decode()),
        e
    } finally {
        n && URL.revokeObjectURL(n)
    }
}
,
C3.CreateCanvas = function(e, t) {
    if ('undefined' != typeof document && 'function' == typeof document.createElement) {
        const a = document.createElement('canvas');
        return a.width = e,
        a.height = t,
        a
    }
    return new OffscreenCanvas(e,t)
}
,
C3.CanvasToBlob = function(e, t, a) {
    return 'number' != typeof a && (a = 1),
    t = t || 'image/png',
    a = C3.clamp(a, 0, 1),
    e.toBlob ? new Promise(n=>e.toBlob(n, t, a)) : e.convertToBlob ? e.convertToBlob({
        type: t,
        quality: a
    }) : C3.Asyncify(()=>C3.CanvasToBlobSync(e, t, a))
}
,
C3.CanvasToBlobSync = function(e, t, a) {
    return 'number' != typeof a && (a = 1),
    t = t || 'image/png',
    a = C3.clamp(a, 0, 1),
    C3.DataURIToBinaryBlobSync(e.toDataURL(t, a))
}
,
C3.DataURIToBinaryBlobSync = function(e) {
    const t = C3.ParseDataURI(e);
    return C3.BinaryStringToBlob(t.data, t.mime_type)
}
,
C3.ParseDataURI = function(t) {
    if ('data:' !== t.substr(0, 5))
        throw new URIError('expected data: uri');
    let a = t.indexOf(',');
    if (0 > a)
        throw new URIError('expected comma in data: uri');
    let n = t.substring(5, a), r = t.substring(a + 1), e = n.split(';'), l = e[0] || '', _ = e[1], d = e[2], i;
    return i = 'base64' === _ || 'base64' === d ? atob(r) : decodeURIComponent(r),
    {
        mime_type: l,
        data: i
    }
}
,
C3.BinaryStringToBlob = function(t, a) {
    let n = t.length, e = n >> 2, r = new Uint8Array(n), i = new Uint32Array(r.buffer,0,e), l, _;
    for (l = 0,
    _ = 0; l < e; ++l)
        i[l] = t.charCodeAt(_++) | t.charCodeAt(_++) << 8 | t.charCodeAt(_++) << 16 | t.charCodeAt(_++) << 24;
    for (let e = 3 & n; e--; )
        r[_] = t.charCodeAt(_),
        ++_;
    return a ? new Blob([r],{
        type: a
    }) : new Blob([r])
}
,
C3.DrawableToBlob = function(t, a, n) {
    const r = C3.CreateCanvas(t.width, t.height)
      , i = r.getContext('2d');
    return i.drawImage(t, 0, 0),
    C3.CanvasToBlob(r, a, n)
}
,
C3.ImageDataToBlobSync = function(t, a, n) {
    const r = C3.CreateCanvas(t.width, t.height)
      , i = r.getContext('2d');
    return i.putImageData(t, 0, 0),
    C3.CanvasToBlobSync(r, a, n)
}
,
C3.ImageDataToBlob = function(t, n, r) {
    if (C3.Supports.ImageBitmapOptions)
        return createImageBitmap(t, {
            premultiplyAlpha: 'none'
        }).then(e=>C3.DrawableToBlob(e, n, r));
    if (C3.Supports.ImageBitmap)
        return createImageBitmap(t).then(e=>C3.DrawableToBlob(e, n, r));
    else {
        const a = C3.CreateCanvas(t.width, t.height)
          , i = a.getContext('2d');
        return i.putImageData(t, 0, 0),
        C3.CanvasToBlob(a, n, r)
    }
}
,
C3.CopySet = function(e, t) {
    e.clear();
    for (const a of t)
        e.add(a)
}
,
C3.MapToObject = function(e) {
    const t = Object.create(null);
    for (const [a,n] of e.entries())
        t[a] = n;
    return t
}
,
C3.ObjectToMap = function(e, t) {
    t.clear();
    for (const [a,n] of Object.entries(e))
        t.set(a, n)
}
,
C3.ToSuperJSON = function t(a) {
    if ('object' == typeof a && null !== a) {
        if (a instanceof Set)
            return {
                _c3type_: 'set',
                data: [...a].map(e=>t(e))
            };
        if (a instanceof Map)
            return {
                _c3type_: 'map',
                data: [...a].map(e=>[e[0], t(e[1])])
            };
        else {
            const n = Object.create(null);
            for (const [r,i] of Object.entries(a))
                n[r] = t(i);
            return n
        }
    }
    return a
}
,
C3.FromSuperJSON = function t(a) {
    if ('object' == typeof a & null !== a) {
        if ('set' === a._c3type_)
            return new Set(a.data.map(e=>t(e)));
        if ('map' === a._c3type_)
            return new Map(a.data.map(e=>[e[0], t(e[1])]));
        else {
            const n = Object.create(null);
            for (const [r,i] of Object.entries(a))
                n[r] = t(i);
            return n
        }
    }
    return a
}
,
C3.CSSToCamelCase = function(e) {
    let t = ''
      , a = !1;
    for (const n of e)
        '-' === n ? a = !0 : a ? (t += n.toUpperCase(),
        a = !1) : t += n;
    return t
}
,
C3.IsIterator = function(e) {
    return 'object' == typeof e && 'function' == typeof e.next
}
,
'use strict';
{
    function t(e) {
        return 0 === e.length ? '00' : 1 === e.length ? '0' + e : e
    }
    function a(e, t, a) {
        return 0 > a && (a += 1),
        1 < a && (a -= 1),
        a < 1 / 6 ? e + 6 * (t - e) * a : a < 1 / 2 ? t : a < 2 / 3 ? e + 6 * ((t - e) * (2 / 3 - a)) : e
    }
    const n = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i
      , r = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
    C3.Color = class {
        constructor(t, a, n, e) {
            this._r = NaN,
            this._g = NaN,
            this._b = NaN,
            this._a = NaN,
            this._r = 0,
            this._g = 0,
            this._b = 0,
            this._a = 0,
            t instanceof C3.Color ? this.set(t) : this.setRgba(t || 0, a || 0, n || 0, e || 0)
        }
        setRgb(e, t, a) {
            return this._r = +e,
            this._g = +t,
            this._b = +a,
            this.clamp(),
            this
        }
        setRgba(t, a, n, e) {
            return this._r = +t,
            this._g = +a,
            this._b = +n,
            this._a = +e,
            this.clamp(),
            this
        }
        set(e) {
            return this._r = e._r,
            this._g = e._g,
            this._b = e._b,
            this._a = e._a,
            this
        }
        copy(e) {
            return this.set(e)
        }
        add(e) {
            this._r += e._r,
            this._g += e._g,
            this._b += e._b,
            this._a += e._a,
            this.clamp()
        }
        addRgb(t, a, n, e=0) {
            this._r += +t,
            this._g += +a,
            this._b += +n,
            this._a += +e,
            this.clamp()
        }
        diff(e) {
            var t = Math.min
              , a = Math.max;
            this.setR(a(this._r, e._r) - t(this._r, e._r)),
            this.setG(a(this._g, e._g) - t(this._g, e._g)),
            this.setB(a(this._b, e._b) - t(this._b, e._b)),
            this.setA(a(this._a, e._a) - t(this._a, e._a)),
            this.clamp()
        }
        copyRgb(e) {
            this._r = e._r,
            this._g = e._g,
            this._b = e._b
        }
        setR(e) {
            this._r = C3.clamp(+e, 0, 1)
        }
        getR() {
            return this._r
        }
        setG(e) {
            this._g = C3.clamp(+e, 0, 1)
        }
        getG() {
            return this._g
        }
        setB(e) {
            this._b = C3.clamp(+e, 0, 1)
        }
        getB() {
            return this._b
        }
        setA(e) {
            this._a = C3.clamp(+e, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return C3.New(C3.Color, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._r,
            e[t++] = this._g,
            e[t++] = this._b,
            e[t] = this._a
        }
        equals(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b && this._a === e._a
        }
        equalsIgnoringAlpha(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b
        }
        equalsRgb(e, t, a) {
            return this._r === e && this._g === t && this._b === a
        }
        equalsRgba(t, a, n, e) {
            return this._r === t && this._g === a && this._b === n && this._a === e
        }
        multiply(e) {
            this._r *= e._r,
            this._g *= e._g,
            this._b *= e._b,
            this._a *= e._a
        }
        multiplyAlpha(e) {
            this._r *= e,
            this._g *= e,
            this._b *= e,
            this._a *= e
        }
        premultiply() {
            return this._r *= this._a,
            this._g *= this._a,
            this._b *= this._a,
            this
        }
        unpremultiply() {
            return this._r /= this._a,
            this._g /= this._a,
            this._b /= this._a,
            this
        }
        clamp() {
            return this._r = C3.clamp(this._r, 0, 1),
            this._g = C3.clamp(this._g, 0, 1),
            this._b = C3.clamp(this._b, 0, 1),
            this._a = C3.clamp(this._a, 0, 1),
            this
        }
        setFromRgbValue(e) {
            this._r = C3.GetRValue(e),
            this._g = C3.GetGValue(e),
            this._b = C3.GetBValue(e),
            this._a = C3.GetAValue(e)
        }
        getCssRgb(t, a, n) {
            const r = C3.IsFiniteNumber(t) ? t : this.getR()
              , e = C3.IsFiniteNumber(a) ? a : this.getG()
              , i = C3.IsFiniteNumber(n) ? n : this.getB();
            return `rgb(${100 * r}%, ${100 * e}%, ${100 * i}%)`
        }
        getCssRgba(t, a, n, e) {
            const r = C3.IsFiniteNumber(t) ? t : this.getR()
              , l = C3.IsFiniteNumber(a) ? a : this.getG()
              , i = C3.IsFiniteNumber(n) ? n : this.getB()
              , _ = C3.IsFiniteNumber(e) ? e : this.getA();
            return `rgba(${100 * r}%, ${100 * l}%, ${100 * i}%, ${_})`
        }
        toHexString() {
            var a = Math.round;
            const n = a(255 * this.getR())
              , r = a(255 * this.getG())
              , i = a(255 * this.getB());
            return '#' + t(n.toString(16)) + t(r.toString(16)) + t(i.toString(16))
        }
        parseHexString(e) {
            if ('string' != typeof e)
                return !1;
            e = e.trim(),
            '#' === e.charAt(0) && (e = e.substr(1));
            let t, n, r;
            if (3 === e.length)
                t = parseInt(e[0], 16) / 15,
                n = parseInt(e[1], 16) / 15,
                r = parseInt(e[2], 16) / 15;
            else if (6 === e.length)
                t = parseInt(e.substr(0, 2), 16) / 255,
                n = parseInt(e.substr(2, 2), 16) / 255,
                r = parseInt(e.substr(4, 2), 16) / 255;
            else
                return !1;
            return isFinite(t) && this.setR(t),
            isFinite(n) && this.setG(n),
            isFinite(r) && this.setB(r),
            this.setA(1),
            !0
        }
        toCommaSeparatedRgb() {
            var e = Math.round;
            const t = e(255 * this.getR())
              , a = e(255 * this.getG())
              , n = e(255 * this.getB());
            return `${t}, ${a}, ${n}`
        }
        toRgbArray() {
            var e = Math.round;
            const t = e(255 * this.getR())
              , a = e(255 * this.getG())
              , n = e(255 * this.getB());
            return [t, a, n]
        }
        parseCommaSeparatedRgb(t) {
            if ('string' != typeof t)
                return !1;
            t = t.replace(/^rgb\(|\)|%/, '');
            const n = t.split(',');
            if (3 > n.length)
                return !1;
            const r = parseInt(n[0].trim(), 10) / 255
              , i = parseInt(n[1].trim(), 10) / 255
              , l = parseInt(n[2].trim(), 10) / 255;
            return isFinite(r) && this.setR(r),
            isFinite(i) && this.setG(i),
            isFinite(l) && this.setB(l),
            this.setA(1),
            !0
        }
        parseCommaSeparatedPercentageRgb(t) {
            if ('string' != typeof t)
                return !1;
            t = t.replace(/^rgb\(|\)|%/, '');
            const n = t.split(',');
            if (3 > n.length)
                return !1;
            const r = parseInt(n[0].trim(), 10) / 100
              , i = parseInt(n[1].trim(), 10) / 100
              , l = parseInt(n[2].trim(), 10) / 100;
            return isFinite(r) && this.setR(r),
            isFinite(i) && this.setG(i),
            isFinite(l) && this.setB(l),
            this.setA(1),
            !0
        }
        parseCommaSeparatedRgba(t) {
            if ('string' != typeof t)
                return !1;
            t = t.replace(/^rgba\(|\)|%/, '');
            const n = t.split(',');
            if (4 > n.length)
                return !1;
            const r = parseInt(n[0].trim(), 10) / 255
              , i = parseInt(n[1].trim(), 10) / 255
              , l = parseInt(n[2].trim(), 10) / 255
              , e = parseFloat(n[3].trim());
            return isFinite(r) && this.setR(r),
            isFinite(i) && this.setG(i),
            isFinite(l) && this.setB(l),
            isFinite(e) && this.setA(e),
            !0
        }
        parseCommaSeparatedPercentageRgba(t) {
            if ('string' != typeof t)
                return !1;
            t = t.replace(/^rgba\(|\)|%/, '');
            const n = t.split(',');
            if (4 > n.length)
                return !1;
            const r = parseInt(n[0].trim(), 10) / 100
              , i = parseInt(n[1].trim(), 10) / 100
              , l = parseInt(n[2].trim(), 10) / 100
              , e = parseFloat(n[3].trim());
            return isFinite(r) && this.setR(r),
            isFinite(i) && this.setG(i),
            isFinite(l) && this.setB(l),
            isFinite(e) && this.setA(e),
            !0
        }
        parseString(e) {
            if ('string' != typeof e)
                return !1;
            if (e = e.replace(/\s+/, ''),
            e.includes(',')) {
                if (e.startsWith('rgb('))
                    return e.includes('%') ? this.parseCommaSeparatedPercentageRgb(e) : this.parseCommaSeparatedRgb(e);
                if (e.startsWith('rgba('))
                    return e.includes('%') ? this.parseCommaSeparatedPercentageRgba(e) : this.parseCommaSeparatedRgba(e);
                if (e.startsWith('hsl(') || e.startsWith('hsla('))
                    return this.parseHSLString(e);
                else {
                    const t = e.split(',');
                    return e.includes('%') ? 3 === t.length ? this.parseCommaSeparatedPercentageRgb(e) : 4 === t.length && this.parseCommaSeparatedPercentageRgba(e) : 3 === t.length ? this.parseCommaSeparatedRgb(e) : 4 === t.length && this.parseCommaSeparatedRgba(e)
                }
            } else
                return this.parseHexString(e)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        setFromHSLA(t, n, r, l) {
            let _, u, c;
            if (t %= 360,
            n = C3.clamp(n, 0, 100),
            r = C3.clamp(r, 0, 100),
            l = C3.clamp(l, 0, 1),
            t /= 360,
            n /= 100,
            r /= 100,
            0 === n)
                _ = u = c = r;
            else {
                const e = .5 > r ? r * (1 + n) : r + n - r * n
                  , i = 2 * r - e;
                _ = a(i, e, t + 1 / 3),
                u = a(i, e, t),
                c = a(i, e, t - 1 / 3)
            }
            return this.setR(_),
            this.setG(u),
            this.setB(c),
            this.setA(l),
            this
        }
        parseHSLString(t) {
            const a = t.replace(/ |hsl|hsla|\(|\)|;/gi, '')
              , i = n.exec(a)
              , e = r.exec(a);
            return i && 4 === i.length ? (this.setFromHSLA(+i[1], +i[2], +i[3], 1),
            !0) : !!(e && 5 === e.length) && (this.setFromHSLA(+i[1], +i[2], +i[3], +i[4]),
            !0)
        }
        toHSLAString() {
            const t = this._r
              , n = this._g
              , r = this._b
              , e = this._a
              , i = C3.Color.GetHue(t, n, r)
              , a = C3.Color.GetSaturation(t, n, r)
              , l = C3.Color.GetLuminosity(t, n, r);
            return `hsla(${i}, ${a}%, ${l}%, ${e})`
        }
        toHSLAArray() {
            const e = this._r
              , t = this._g
              , a = this._b;
            return [C3.Color.GetHue(e, t, a), C3.Color.GetSaturation(e, t, a), C3.Color.GetLuminosity(e, t, a), this._a]
        }
        setFromJSON(e) {
            !Array.isArray(e) || 3 > e.length || (this._r = e[0],
            this._g = e[1],
            this._b = e[2],
            this._a = 4 <= e.length ? e[3] : 1)
        }
        set r(e) {
            this.setR(e)
        }
        get r() {
            return this.getR()
        }
        set g(e) {
            this.setG(e)
        }
        get g() {
            return this.getG()
        }
        set b(e) {
            this.setB(e)
        }
        get b() {
            return this.getB()
        }
        set a(e) {
            this.setA(e)
        }
        get a() {
            return this.getA()
        }
        setAtIndex(e, t) {
            switch (e) {
            case 0:
                this.setR(t);
                break;
            case 1:
                this.setG(t);
                break;
            case 2:
                this.setB(t);
                break;
            case 3:
                this.setA(t);
                break;
            default:
                throw new RangeError('invalid color index');
            }
        }
        getAtIndex(e) {
            switch (e) {
            case 0:
                return this.getR();
            case 1:
                return this.getG();
            case 2:
                return this.getB();
            case 3:
                return this.getA();
            default:
                throw new RangeError('invalid color index');
            }
        }
        static Diff(t, a) {
            var n = Math.min
              , r = Math.max;
            const i = new C3.Color;
            return i.setR(r(t._r, a._r) - n(t._r, a._r)),
            i.setG(r(t._g, a._g) - n(t._g, a._g)),
            i.setB(r(t._b, a._b) - n(t._b, a._b)),
            i.setA(r(t._a, a._a) - n(t._a, a._a)),
            i
        }
        static GetHue(t, a, n) {
            const r = Math.max(t, a, n)
              , i = Math.min(t, a, n);
            if (r === i)
                return 0;
            let e = 0;
            return r === t ? e = (a - n) / (r - i) + (a < n ? 6 : 0) : r === a ? e = (n - t) / (r - i) + 2 : r === n ? e = (t - a) / (r - i) + 4 : void 0,
            Math.round(360 * (e / 6))
        }
        static GetSaturation(t, a, n) {
            const e = Math.max(t, a, n)
              , r = Math.min(t, a, n);
            if (e === r)
                return 0;
            const i = e - r
              , l = .5 < (e + r) / 2 ? i / (2 - e - r) : i / (e + r);
            return Math.round(100 * l)
        }
        static GetLuminosity(t, a, n) {
            const r = Math.max(t, a, n)
              , i = Math.min(t, a, n);
            return r ? Math.round(100 * ((r + i) / 2)) : 0
        }
    }
    ,
    C3.Color.White = Object.freeze(C3.New(C3.Color, 1, 1, 1, 1)),
    C3.Color.Black = Object.freeze(C3.New(C3.Color, 0, 0, 0, 1)),
    C3.Color.TransparentBlack = Object.freeze(C3.New(C3.Color, 0, 0, 0, 0))
}
'use strict',
C3.Vector2 = class {
    constructor(e, t) {
        this._x = 0,
        this._y = 0,
        e instanceof C3.Vector2 ? this.copy(e) : this.set(e || 0, t || 0)
    }
    set(e, t) {
        this._x = +e,
        this._y = +t
    }
    copy(e) {
        this._x = e._x,
        this._y = e._y
    }
    equals(e) {
        return this._x === e._x && this._y === e._y
    }
    setX(e) {
        this._x = +e
    }
    getX() {
        return this._x
    }
    setY(e) {
        this._y = +e
    }
    getY() {
        return this._y
    }
    toArray() {
        return [this._x, this._y]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(e, t) {
        e[t++] = this._x,
        e[t] = this._y
    }
    offset(e, t) {
        this._x += +e,
        this._y += +t
    }
    scale(e, t) {
        this._x *= e,
        this._y *= t
    }
    round() {
        var e = Math.round;
        this._x = e(this._x),
        this._y = e(this._y)
    }
    floor() {
        var e = Math.floor;
        this._x = e(this._x),
        this._y = e(this._y)
    }
    ceil() {
        var e = Math.ceil;
        this._x = e(this._x),
        this._y = e(this._y)
    }
    angle() {
        return C3.angleTo(0, 0, this._x, this._y)
    }
    lengthSquared() {
        return this._x * this._x + this._y * this._y
    }
    length() {
        return Math.sqrt(this.lengthSquared())
    }
    rotatePrecalc(e, t) {
        const a = this._x * t - this._y * e;
        this._y = this._y * t + this._x * e,
        this._x = a
    }
    rotate(e) {
        0 === e || this.rotatePrecalc(Math.sin(e), Math.cos(e))
    }
    rotateAbout(e, t, a) {
        0 === e || t === this._x && a === this._y || (this._x -= t,
        this._y -= a,
        this.rotatePrecalc(Math.sin(e), Math.cos(e)),
        this._x += +t,
        this._y += +a)
    }
    move(e, t) {
        0 === t || (this._x += Math.cos(e) * t,
        this._y += Math.sin(e) * t)
    }
    normalize() {
        const e = this.length();
        0 !== e && 1 !== e && (this._x /= e,
        this._y /= e)
    }
    clamp(e, t) {
        this._x = C3.clamp(this._x, e, t),
        this._y = C3.clamp(this._y, e, t)
    }
}
,
'use strict',
C3.Rect = class {
    constructor(e, t, a, n) {
        this._left = NaN,
        this._top = NaN,
        this._right = NaN,
        this._bottom = NaN,
        this._left = 0,
        this._top = 0,
        this._right = 0,
        this._bottom = 0,
        e instanceof C3.Rect ? this.copy(e) : this.set(e || 0, t || 0, a || 0, n || 0)
    }
    set(e, t, a, n) {
        this._left = +e,
        this._top = +t,
        this._right = +a,
        this._bottom = +n
    }
    setWH(e, t, n, r) {
        e = +e,
        t = +t,
        this._left = e,
        this._top = t,
        this._right = e + +n,
        this._bottom = t + +r
    }
    copy(e) {
        this._left = +e._left,
        this._top = +e._top,
        this._right = +e._right,
        this._bottom = +e._bottom
    }
    clone() {
        return new C3.Rect(this._left,this._top,this._right,this._bottom)
    }
    static Merge(t, a) {
        var n = Math.max
          , r = Math.min;
        const i = new C3.Rect;
        return i.setLeft(r(t._left, a._left)),
        i.setTop(r(t._top, a._top)),
        i.setRight(n(t._right, a._right)),
        i.setBottom(n(t._bottom, a._bottom)),
        i
    }
    static FromObject(e) {
        return new C3.Rect(e.left,e.top,e.right,e.bottom)
    }
    equals(e) {
        return this._left === e._left && this._top === e._top && this._right === e._right && this._bottom === e._bottom
    }
    setLeft(e) {
        this._left = +e
    }
    getLeft() {
        return this._left
    }
    setTop(e) {
        this._top = +e
    }
    getTop() {
        return this._top
    }
    setRight(e) {
        this._right = +e
    }
    getRight() {
        return this._right
    }
    setBottom(e) {
        this._bottom = +e
    }
    getBottom() {
        return this._bottom
    }
    toArray() {
        return [this._left, this._top, this._right, this._bottom]
    }
    toTypedArray() {
        return new Float64Array(this.toArray())
    }
    toDOMRect() {
        return new DOMRect(this._left,this._top,this.width(),this.height())
    }
    writeToTypedArray(e, t) {
        e[t++] = this._left,
        e[t++] = this._top,
        e[t++] = this._right,
        e[t] = this._bottom
    }
    writeAsQuadToTypedArray(e, t) {
        e[t++] = this._left,
        e[t++] = this._top,
        e[t++] = this._right,
        e[t++] = this._top,
        e[t++] = this._right,
        e[t++] = this._bottom,
        e[t++] = this._left,
        e[t] = this._bottom
    }
    width() {
        return this._right - this._left
    }
    height() {
        return this._bottom - this._top
    }
    midX() {
        return (this._left + this._right) / 2
    }
    midY() {
        return (this._top + this._bottom) / 2
    }
    offset(e, t) {
        this._left += +e,
        this._top += +t,
        this._right += +e,
        this._bottom += +t
    }
    offsetLeft(e) {
        this._left += +e
    }
    offsetTop(e) {
        this._top += +e
    }
    offsetRight(e) {
        this._right += +e
    }
    offsetBottom(e) {
        this._bottom += +e
    }
    toSquare(e) {
        if ('x' !== e)
            throw new Error('invalid axis, only \'x\' supported');
        this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() : this._left < this._right ? this._top - this.width() : this._top + this.width()
    }
    inflate(e, t) {
        this._left -= e,
        this._top -= t,
        this._right += +e,
        this._bottom += +t
    }
    deflate(e, t) {
        this._left += +e,
        this._top += +t,
        this._right -= e,
        this._bottom -= t
    }
    multiply(e, t) {
        this._left *= e,
        this._top *= t,
        this._right *= e,
        this._bottom *= t
    }
    divide(e, t) {
        this._left /= e,
        this._top /= t,
        this._right /= e,
        this._bottom /= t
    }
    mirrorAround(e) {
        this._left = +e - this._left,
        this._right = +e - this._right
    }
    flipAround(e) {
        this._top = +e - this._top,
        this._bottom = +e - this._bottom
    }
    swapLeftRight() {
        const e = this._left;
        this._left = this._right,
        this._right = e
    }
    swapTopBottom() {
        const e = this._top;
        this._top = this._bottom,
        this._bottom = e
    }
    shuntY(e) {
        const t = this._top;
        this._top = +e - this._bottom,
        this._bottom = +e - t
    }
    round() {
        var e = Math.round;
        this._left = e(this._left),
        this._top = e(this._top),
        this._right = e(this._right),
        this._bottom = e(this._bottom)
    }
    roundInner() {
        var e = Math.floor
          , t = Math.ceil;
        this._left = t(this._left),
        this._top = t(this._top),
        this._right = e(this._right),
        this._bottom = e(this._bottom)
    }
    roundOuter() {
        var e = Math.floor
          , t = Math.ceil;
        this._left = e(this._left),
        this._top = e(this._top),
        this._right = t(this._right),
        this._bottom = t(this._bottom)
    }
    floor() {
        var e = Math.floor;
        this._left = e(this._left),
        this._top = e(this._top),
        this._right = e(this._right),
        this._bottom = e(this._bottom)
    }
    ceil() {
        var e = Math.ceil;
        this._left = e(this._left),
        this._top = e(this._top),
        this._right = e(this._right),
        this._bottom = e(this._bottom)
    }
    clamp(t, a, n, r) {
        this._left < t && (this._left = +t),
        this._top < a && (this._top = +a),
        this._right > n && (this._right = +n),
        this._bottom > r && (this._bottom = +r)
    }
    clampFlipped(t, a, n, r) {
        this._left < t && (this._left = +t),
        this._top > a && (this._top = +a),
        this._right > n && (this._right = +n),
        this._bottom < r && (this._bottom = +r)
    }
    normalize() {
        this._left > this._right && this.swapLeftRight(),
        this._top > this._bottom && this.swapTopBottom()
    }
    intersectsRect(e) {
        return !(e._right < this._left || e._bottom < this._top || e._left > this._right || e._top > this._bottom)
    }
    intersectsRectOffset(e, t, a) {
        return !(e._right + t < this._left || e._bottom + a < this._top || e._left + t > this._right || e._top + a > this._bottom)
    }
    containsPoint(e, t) {
        return e >= this._left && e <= this._right && t >= this._top && t <= this._bottom
    }
    containsRect(e) {
        return e._left >= this._left && e._top >= this._top && e._right <= this._right && e._bottom <= this._bottom
    }
    expandToContain(e) {
        e._left < this._left && (this._left = +e._left),
        e._top < this._top && (this._top = +e._top),
        e._right > this._right && (this._right = +e._right),
        e._bottom > this._bottom && (this._bottom = +e._bottom)
    }
    lerpInto(e) {
        this._left = C3.lerp(e._left, e._right, this._left),
        this._top = C3.lerp(e._top, e._bottom, this._top),
        this._right = C3.lerp(e._left, e._right, this._right),
        this._bottom = C3.lerp(e._top, e._bottom, this._bottom)
    }
}
,
'use strict';
{
    function t(t, r, a, i) {
        t < r ? a < i ? (n = t < a ? t : a,
        e = r > i ? r : i) : (n = t < i ? t : i,
        e = r > a ? r : a) : a < i ? (n = r < a ? r : a,
        e = t > i ? t : i) : (n = r < i ? r : i,
        e = t > a ? t : a)
    }
    let n = 0
      , e = 0;
    C3.Quad = class {
        constructor(t, a, n, r, i, e, l, _) {
            this._tlx = NaN,
            this._tly = NaN,
            this._trx = NaN,
            this._try = NaN,
            this._brx = NaN,
            this._bry = NaN,
            this._blx = NaN,
            this._bly = NaN,
            this._tlx = 0,
            this._tly = 0,
            this._trx = 0,
            this._try = 0,
            this._brx = 0,
            this._bry = 0,
            this._blx = 0,
            this._bly = 0,
            t instanceof C3.Quad ? this.copy(t) : this.set(t || 0, a || 0, n || 0, r || 0, i || 0, e || 0, l || 0, _ || 0)
        }
        set(t, a, n, r, i, e, l, _) {
            this._tlx = +t,
            this._tly = +a,
            this._trx = +n,
            this._try = +r,
            this._brx = +i,
            this._bry = +e,
            this._blx = +l,
            this._bly = +_
        }
        setRect(e, t, a, n) {
            this.set(e, t, a, t, a, n, e, n)
        }
        copy(e) {
            this._tlx = e._tlx,
            this._tly = e._tly,
            this._trx = e._trx,
            this._try = e._try,
            this._brx = e._brx,
            this._bry = e._bry,
            this._blx = e._blx,
            this._bly = e._bly
        }
        equals(e) {
            return this._tlx === e._tlx && this._tly === e._tly && this._trx === e._trx && this._try === e._try && this._brx === e._brx && this._bry === e._bry && this._blx === e._blx && this._bly === e._bly
        }
        setTlx(e) {
            this._tlx = +e
        }
        getTlx() {
            return this._tlx
        }
        setTly(e) {
            this._tly = +e
        }
        getTly() {
            return this._tly
        }
        setTrx(e) {
            this._trx = +e
        }
        getTrx() {
            return this._trx
        }
        setTry(e) {
            this._try = +e
        }
        getTry() {
            return this._try
        }
        setBrx(e) {
            this._brx = +e
        }
        getBrx() {
            return this._brx
        }
        setBry(e) {
            this._bry = +e
        }
        getBry() {
            return this._bry
        }
        setBlx(e) {
            this._blx = +e
        }
        getBlx() {
            return this._blx
        }
        setBly(e) {
            this._bly = +e
        }
        getBly() {
            return this._bly
        }
        toDOMQuad() {
            return new DOMQuad(new DOMPoint(this._tlx,this._tly),new DOMPoint(this._trx,this._try),new DOMPoint(this._brx,this._bry),new DOMPoint(this._blx,this._bly))
        }
        toArray() {
            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._tlx,
            e[t++] = this._tly,
            e[t++] = this._trx,
            e[t++] = this._try,
            e[t++] = this._brx,
            e[t++] = this._bry,
            e[t++] = this._blx,
            e[t] = this._bly
        }
        writeToTypedArray3D(e, t, a) {
            e[t++] = this._tlx,
            e[t++] = this._tly,
            e[t++] = a,
            e[t++] = this._trx,
            e[t++] = this._try,
            e[t++] = a,
            e[t++] = this._brx,
            e[t++] = this._bry,
            e[t++] = a,
            e[t++] = this._blx,
            e[t++] = this._bly,
            e[t] = a
        }
        offset(e, t) {
            this._tlx += +e,
            this._tly += +t,
            this._trx += +e,
            this._try += +t,
            this._brx += +e,
            this._bry += +t,
            this._blx += +e,
            this._bly += +t
        }
        round() {
            var e = Math.round;
            this._tlx = e(this._tlx),
            this._tly = e(this._tly),
            this._trx = e(this._trx),
            this._try = e(this._try),
            this._brx = e(this._brx),
            this._bry = e(this._bry),
            this._blx = e(this._blx),
            this._bly = e(this._bly)
        }
        floor() {
            var e = Math.floor;
            this._tlx = e(this._tlx),
            this._tly = e(this._tly),
            this._trx = e(this._trx),
            this._try = e(this._try),
            this._brx = e(this._brx),
            this._bry = e(this._bry),
            this._blx = e(this._blx),
            this._bly = e(this._bly)
        }
        ceil() {
            var e = Math.ceil;
            this._tlx = e(this._tlx),
            this._tly = e(this._tly),
            this._trx = e(this._trx),
            this._try = e(this._try),
            this._brx = e(this._brx),
            this._bry = e(this._bry),
            this._blx = e(this._blx),
            this._bly = e(this._bly)
        }
        setFromRect(e) {
            this._tlx = e._left,
            this._tly = e._top,
            this._trx = e._right,
            this._try = e._top,
            this._brx = e._right,
            this._bry = e._bottom,
            this._blx = e._left,
            this._bly = e._bottom
        }
        setFromRotatedRect(e, t) {
            0 === t ? this.setFromRect(e) : this.setFromRotatedRectPrecalc(e, Math.sin(t), Math.cos(t))
        }
        setFromRotatedRectPrecalc(t, a, n) {
            const r = t._left * a
              , l = t._top * a
              , e = t._right * a
              , _ = t._bottom * a
              , d = t._left * n
              , u = t._top * n
              , i = t._right * n
              , c = t._bottom * n;
            this._tlx = d - l,
            this._tly = u + r,
            this._trx = i - l,
            this._try = u + e,
            this._brx = i - _,
            this._bry = c + e,
            this._blx = d - _,
            this._bly = c + r
        }
        getBoundingBox(a) {
            t(this._tlx, this._trx, this._brx, this._blx),
            a._left = n,
            a._right = e,
            t(this._tly, this._try, this._bry, this._bly),
            a._top = n,
            a._bottom = e
        }
        containsPoint(t, a) {
            let r = this._trx - this._tlx
              , _ = this._try - this._tly;
            const u = this._brx - this._tlx
              , e = this._bry - this._tly
              , f = t - this._tlx
              , g = a - this._tly;
            let h = r * r + _ * _
              , S = r * u + _ * e
              , y = r * f + _ * g;
            const G = u * u + e * e
              , l = u * f + e * g;
            let m = 1 / (h * G - S * S)
              , b = (G * y - S * l) * m
              , T = (h * l - S * y) * m;
            return !!(0 <= b && 0 < T && 1 > b + T) || (r = this._blx - this._tlx,
            _ = this._bly - this._tly,
            h = r * r + _ * _,
            S = r * u + _ * e,
            y = r * f + _ * g,
            m = 1 / (h * G - S * S),
            b = (G * y - S * l) * m,
            T = (h * l - S * y) * m,
            0 <= b && 0 < T && 1 > b + T)
        }
        midX() {
            return (this._tlx + this._trx + this._brx + this._blx) / 4
        }
        midY() {
            return (this._tly + this._try + this._bry + this._bly) / 4
        }
        intersectsSegment(e, t, a, n) {
            return !!(this.containsPoint(e, t) || this.containsPoint(a, n)) || C3.segmentIntersectsQuad(e, t, a, n, this)
        }
        intersectsQuad(t) {
            let a = t.midX()
              , n = t.midY();
            if (this.containsPoint(a, n))
                return !0;
            if (a = this.midX(),
            n = this.midY(),
            t.containsPoint(a, n))
                return !0;
            const r = this._tlx
              , l = this._tly
              , e = this._trx
              , _ = this._try
              , d = this._brx
              , u = this._bry
              , i = this._blx
              , g = this._bly;
            return C3.segmentIntersectsQuad(r, l, e, _, t) || C3.segmentIntersectsQuad(e, _, d, u, t) || C3.segmentIntersectsQuad(d, u, i, g, t) || C3.segmentIntersectsQuad(i, g, r, l, t)
        }
        mirror() {
            this._swap(0, 2),
            this._swap(1, 3),
            this._swap(6, 4),
            this._swap(7, 5)
        }
        flip() {
            this._swap(0, 6),
            this._swap(1, 7),
            this._swap(2, 4),
            this._swap(3, 5)
        }
        diag() {
            this._swap(2, 6),
            this._swap(3, 7)
        }
        _swap(e, t) {
            const a = this._getAtIndex(e);
            this._setAtIndex(e, this._getAtIndex(t)),
            this._setAtIndex(t, a)
        }
        _getAtIndex(e) {
            switch (e) {
            case 0:
                return this._tlx;
            case 1:
                return this._tly;
            case 2:
                return this._trx;
            case 3:
                return this._try;
            case 4:
                return this._brx;
            case 5:
                return this._bry;
            case 6:
                return this._blx;
            case 7:
                return this._bly;
            default:
                throw new RangeError('invalid quad point index');
            }
        }
        _setAtIndex(e, t) {
            switch (t = +t,
            e) {
            case 0:
                this._tlx = t;
                break;
            case 1:
                this._tly = t;
                break;
            case 2:
                this._trx = t;
                break;
            case 3:
                this._try = t;
                break;
            case 4:
                this._brx = t;
                break;
            case 5:
                this._bry = t;
                break;
            case 6:
                this._blx = t;
                break;
            case 7:
                this._bly = t;
                break;
            default:
                throw new RangeError('invalid quad point index');
            }
        }
    }
}
{
    const e = [0, 0, 1, 0, 1, 1, 0, 1]
      , t = C3.New(C3.Quad);
    C3.CollisionPoly = class extends C3.DefendedBase {
        constructor(t, a=!0) {
            super(),
            t || (t = e),
            this._ptsArr = Float64Array.from(t),
            this._bbox = new C3.Rect,
            this._isBboxChanged = !0,
            this._enabled = a
        }
        Release() {}
        pointsArr() {
            return this._ptsArr
        }
        pointCount() {
            return this._ptsArr.length / 2
        }
        setPoints(e) {
            this._ptsArr.length === e.length ? this._ptsArr.set(e) : this._ptsArr = Float64Array.from(e),
            this._isBboxChanged = !0
        }
        copy(e) {
            this.setPoints(e._ptsArr)
        }
        setBboxChanged() {
            this._isBboxChanged = !0
        }
        _updateBbox() {
            if (!this._isBboxChanged)
                return;
            const t = this._ptsArr;
            let a = t[0]
              , n = t[1]
              , r = a
              , i = n;
            for (let e = 0, l = t.length; e < l; e += 2) {
                const l = t[e]
                  , _ = t[e + 1];
                l < a && (a = l),
                l > r && (r = l),
                _ < n && (n = _),
                _ > i && (i = _)
            }
            this._bbox.set(a, n, r, i),
            this._isBboxChanged = !1
        }
        setFromRect(e, t, a) {
            let n = this._ptsArr;
            8 !== n.length && (n = new Float64Array(8),
            this._ptsArr = n),
            n[0] = e.getLeft() - t,
            n[1] = e.getTop() - a,
            n[2] = e.getRight() - t,
            n[3] = e.getTop() - a,
            n[4] = e.getRight() - t,
            n[5] = e.getBottom() - a,
            n[6] = e.getLeft() - t,
            n[7] = e.getBottom() - a,
            this._bbox.copy(e),
            (0 !== t || 0 !== a) && this._bbox.offset(-t, -a),
            this._isBboxChanged = !1
        }
        setFromQuad(e, a, n) {
            t.copy(e),
            t.offset(a, n),
            this.setPoints(t.toArray()),
            this._isBboxChanged = !0
        }
        transform(t, n, r) {
            let i = 0
              , l = 1;
            0 !== r && (i = Math.sin(r),
            l = Math.cos(r)),
            this.transformPrecalc(t, n, i, l)
        }
        transformPrecalc(t, a, n, r) {
            const l = this._ptsArr;
            for (let e = 0, i = l.length; e < i; e += 2) {
                const _ = e + 1
                  , d = l[e] * t
                  , u = l[_] * a;
                l[e] = d * r - u * n,
                l[_] = u * r + d * n
            }
            this._isBboxChanged = !0
        }
        offset(t, a) {
            const n = this._ptsArr;
            for (let r = 0, i = n.length; r < i; r += 2)
                n[r] += t,
                n[r + 1] += a
        }
        containsPoint(_, a) {
            const S = this._ptsArr;
            if (_ === S[0] && a === S[1])
                return !0;
            this._updateBbox();
            const i = this._bbox
              , c = i.getLeft() - 110
              , e = i.getTop() - 101
              , f = i.getRight() + 131
              , g = i.getBottom() + 120;
            let h = 0
              , y = 0
              , G = 0
              , b = 0
              , T = 0
              , I = 0
              , C = 0
              , P = 0;
            c < _ ? (h = c,
            G = _) : (h = _,
            G = c),
            e < a ? (y = e,
            b = a) : (y = a,
            b = e),
            f < _ ? (T = f,
            C = _) : (T = _,
            C = f),
            g < a ? (I = g,
            P = a) : (I = a,
            P = g);
            let A = 0
              , R = 0;
            for (let t = 0, n = S.length; t < n; t += 2) {
                const r = (t + 2) % n
                  , i = S[t]
                  , l = S[t + 1]
                  , d = S[r]
                  , u = S[r + 1];
                C3.segmentsIntersectPreCalc(c, e, _, a, h, G, y, b, i, l, d, u) && ++A,
                C3.segmentsIntersectPreCalc(f, g, _, a, T, C, I, P, i, l, d, u) && ++R
            }
            return 1 == A % 2 || 1 == R % 2
        }
        intersectsPoly(t, _, u) {
            const c = t._ptsArr
              , r = this._ptsArr;
            if (this.containsPoint(c[0] + _, c[1] + u))
                return !0;
            if (t.containsPoint(r[0] - _, r[1] - u))
                return !0;
            for (let e = 0, l = r.length; e < l; e += 2) {
                const t = (e + 2) % l
                  , d = r[e]
                  , h = r[e + 1]
                  , i = r[t]
                  , S = r[t + 1];
                let m = 0
                  , n = 0
                  , y = 0
                  , p = 0;
                d < i ? (m = d,
                y = i) : (m = i,
                y = d),
                h < S ? (n = h,
                p = S) : (n = S,
                p = h);
                for (let t = 0, a = c.length; t < a; t += 2) {
                    const e = (t + 2) % a
                      , f = c[t] + _
                      , g = c[t + 1] + u
                      , G = c[e] + _
                      , l = c[e + 1] + u;
                    if (C3.segmentsIntersectPreCalc(d, h, i, S, m, y, n, p, f, g, G, l))
                        return !0
                }
            }
            return !1
        }
        intersectsSegment(t, a, _, u, d, e) {
            if (this.containsPoint(_ - t, u - a))
                return !0;
            if (this.containsPoint(d - t, e - a))
                return !0;
            let c = 0
              , f = 0
              , S = 0
              , y = 0;
            _ < d ? (c = _,
            S = d) : (c = d,
            S = _),
            u < e ? (f = u,
            y = e) : (f = e,
            y = u);
            const G = this._ptsArr;
            for (let l = 0, n = G.length; l < n; l += 2) {
                const i = (l + 2) % n
                  , g = G[l] + t
                  , m = G[l + 1] + a
                  , p = G[i] + t
                  , h = G[i + 1] + a;
                if (C3.segmentsIntersectPreCalc(_, u, d, e, c, S, f, y, g, m, p, h))
                    return !0
            }
            return !1
        }
        mirror(e) {
            const t = this._ptsArr;
            for (let a = 0, n = t.length; a < n; a += 2)
                t[a] = 2 * e - t[a];
            this._isBboxChanged = !0
        }
        flip(e) {
            const t = this._ptsArr;
            for (let a = 0, n = t.length; a < n; a += 2) {
                const n = a + 1;
                t[n] = 2 * e - t[n]
            }
            this._isBboxChanged = !0
        }
        diag() {
            const e = this._ptsArr;
            for (let t = 0, a = e.length; t < a; t += 2) {
                const a = t + 1
                  , n = e[t];
                e[t] = e[a],
                e[a] = n
            }
            this._isBboxChanged = !0
        }
        GetMidX() {
            const e = this._ptsArr;
            let t = 0;
            for (let a = 0, n = e.length; a < n; a += 2)
                t += e[a];
            return t / this.pointCount()
        }
        GetMidY() {
            const e = this._ptsArr;
            let t = 0;
            for (let a = 0, n = e.length; a < n; a += 2)
                t += e[a + 1];
            return t / this.pointCount()
        }
        GetPointsArray() {
            return this._ptsArr
        }
        GetPointCount() {
            return this.pointCount()
        }
        IsEnabled() {
            return this._enabled
        }
    }
}
'use strict',
C3.PairMap = class extends C3.DefendedBase {
    constructor(e) {
        if (super(),
        this._firstMap = new Map,
        e)
            for (const [t,a,n] of e)
                this.Set(t, a, n)
    }
    Release() {
        this.Clear(),
        this._firstMap = null
    }
    Clear() {
        const e = this._firstMap;
        for (const t of e.values())
            t.clear();
        e.clear()
    }
    Set(t, a, n) {
        const r = this._firstMap;
        let i = r.get(t);
        i || (i = new Map,
        r.set(t, i)),
        i.set(a, n)
    }
    Get(e, t) {
        const a = this._firstMap.get(e);
        return a ? a.get(t) : a
    }
    Has(e, t) {
        const a = this._firstMap.get(e);
        return !!a && a.has(t)
    }
    Delete(t, a) {
        const n = this._firstMap
          , r = n.get(t);
        if (!r)
            return !1;
        const i = r.delete(a);
        return i && 0 === r.size && n.delete(t),
        i
    }
    DeleteEither(e) {
        const t = this._firstMap
          , a = t.get(e);
        a && (a.clear(),
        t.delete(e));
        for (const [a,n] of t.entries())
            n.delete(e) && 0 === n.size && t.delete(a)
    }
    GetSize() {
        let e = 0;
        for (const t of this._firstMap.values())
            e += t.size;
        return e
    }
    *values() {
        for (const e of this._firstMap.values())
            yield*e.values()
    }
    *keyPairs() {
        for (const [e,t] of this._firstMap.entries())
            for (const a of t.keys())
                yield[e, a]
    }
    *entries() {
        for (const [e,t] of this._firstMap.entries())
            for (const [a,n] of t.entries())
                yield[e, a, n]
    }
}
,
'use strict',
C3.ArraySet = class extends C3.DefendedBase {
    constructor() {
        super(),
        this._set = new Set,
        this._arr = [],
        this._needToRebuildArray = !1
    }
    Release() {
        this.Clear()
    }
    Clear() {
        this._set.clear(),
        C3.clearArray(this._arr),
        this._needToRebuildArray = !1
    }
    Add(e) {
        this._set.has(e) || (this._set.add(e),
        !this._needToRebuildArray && this._arr.push(e))
    }
    Has(e) {
        return this._set.has(e)
    }
    Delete(e) {
        this._set.delete(e) && (this._needToRebuildArray = !0)
    }
    GetSize() {
        return this._set.size
    }
    IsEmpty() {
        return 0 === this._set.size
    }
    GetArray() {
        return this._needToRebuildArray && (this._RebuildArray(),
        this._needToRebuildArray = !1),
        this._arr
    }
    _RebuildArray() {
        const e = this._arr;
        C3.clearArray(e);
        for (const t of this._set)
            e.push(t)
    }
}
,
'use strict',
function() {
    var t = Math.asin
      , _ = Math.abs
      , S = Math.sqrt
      , f = Math.pow
      , h = Math.sin
      , i = Math.cos
      , y = Math.PI;
    const e = new Map
      , d = new Map
      , l = new Map
      , g = new Map
      , n = new Map;
    n.set('linear', 'noease'),
    n.set('default', 'noease'),
    self.Ease = class u {
        constructor() {}
        static InheritEase() {
            return 'default'
        }
        static DefaultEase() {
            return 'noease'
        }
        static GetEaseNames(...e) {
            return this._CreateEaseMap(),
            [...d.keys()].concat([...l.keys()]).filter(t=>!e.includes(t))
        }
        static IsNamePredefined(e) {
            return this._CreateEaseMap(),
            [...d.keys()].includes(e)
        }
        static GetEase(t) {
            this._CreateEaseMap();
            const a = n.get(t);
            return a ? e.get(a) : e.get(t)
        }
        static GetEaseFromIndex(e) {
            this._CreateEaseMap();
            const t = this.GetEaseNames();
            return t[e]
        }
        static GetIndexForEase(e) {
            this._CreateEaseMap();
            const t = this.GetEaseNames();
            return t.indexOf(e)
        }
        static _CreateEaseMap() {
            0 !== e.size || (this._AddPredifinedEase('default', ()=>{}
            ),
            this._AddPredifinedEase('noease', this.NoEase),
            this._AddPredifinedEase('easeinsine', this.EaseInSine),
            this._AddPredifinedEase('easeoutsine', this.EaseOutSine),
            this._AddPredifinedEase('easeinoutsine', this.EaseInOutSine),
            this._AddPredifinedEase('easeinelastic', this.EaseInElastic),
            this._AddPredifinedEase('easeoutelastic', this.EaseOutElastic),
            this._AddPredifinedEase('easeinoutelastic', this.EaseInOutElastic),
            this._AddPredifinedEase('easeinback', this.EaseInBack),
            this._AddPredifinedEase('easeoutback', this.EaseOutBack),
            this._AddPredifinedEase('easeinoutback', this.EaseInOutBack),
            this._AddPredifinedEase('easeinbounce', this.EaseInBounce),
            this._AddPredifinedEase('easeoutbounce', this.EaseOutBounce),
            this._AddPredifinedEase('easeinoutbounce', this.EaseInOutBounce),
            this._AddPredifinedEase('easeincubic', this.EaseInCubic),
            this._AddPredifinedEase('easeoutcubic', this.EaseOutCubic),
            this._AddPredifinedEase('easeinoutcubic', this.EaseInOutCubic),
            this._AddPredifinedEase('easeinquad', this.EaseInQuad),
            this._AddPredifinedEase('easeoutquad', this.EaseOutQuad),
            this._AddPredifinedEase('easeinoutquad', this.EaseInOutQuad),
            this._AddPredifinedEase('easeinquart', this.EaseInQuart),
            this._AddPredifinedEase('easeoutquart', this.EaseOutQuart),
            this._AddPredifinedEase('easeinoutquart', this.EaseInOutQuart),
            this._AddPredifinedEase('easeinquint', this.EaseInQuint),
            this._AddPredifinedEase('easeoutquint', this.EaseOutQuint),
            this._AddPredifinedEase('easeinoutquint', this.EaseInOutQuint),
            this._AddPredifinedEase('easeincirc', this.EaseInCirc),
            this._AddPredifinedEase('easeoutcirc', this.EaseOutCirc),
            this._AddPredifinedEase('easeinoutcirc', this.EaseInOutCirc),
            this._AddPredifinedEase('easeinexpo', this.EaseInExpo),
            this._AddPredifinedEase('easeoutexpo', this.EaseOutExpo),
            this._AddPredifinedEase('easeinoutexpo', this.EaseInOutExpo),
            this._AddPrivateCustomEase('cubicbezier', this.EaseCubicBezier),
            this._AddPrivateCustomEase('spline', this.EaseSpline))
        }
        static _AddPredifinedEase(e, t) {
            u._AddEase(e, t, 'predefined')
        }
        static _AddPrivateCustomEase(e, t) {
            u._AddEase(e, t, 'private')
        }
        static AddCustomEase(e, t) {
            this._CreateEaseMap(),
            u._AddEase(e, t, 'custom')
        }
        static RemoveCustomEase(t) {
            this.IsNamePredefined(t) || [...g.keys()].includes(t) || (l.delete(t),
            e.delete(t))
        }
        static _AddEase(t, a, n) {
            switch (e.set(t, a),
            n) {
            case 'predefined':
                d.set(t, a);
                break;
            case 'custom':
                l.set(t, a);
                break;
            case 'private':
                g.set(t, a);
                break;
            default:
                throw new Error('unexpected ease mode');
            }
        }
        static NoEase(t, a, e, n) {
            return e * t / n + a
        }
        static EaseInQuad(t, n, e, r) {
            return e * (t /= r) * t + n
        }
        static EaseOutQuad(t, n, e, r) {
            return -e * (t /= r) * (t - 2) + n
        }
        static EaseInOutQuad(t, n, e, r) {
            return 1 > (t /= r / 2) ? e / 2 * t * t + n : -e / 2 * (--t * (t - 2) - 1) + n
        }
        static EaseInCubic(t, n, e, r) {
            return e * (t /= r) * t * t + n
        }
        static EaseOutCubic(t, n, e, r) {
            return e * ((t = t / r - 1) * t * t + 1) + n
        }
        static EaseInOutCubic(t, n, e, r) {
            return 1 > (t /= r / 2) ? e / 2 * t * t * t + n : e / 2 * ((t -= 2) * t * t + 2) + n
        }
        static EaseInQuart(t, n, e, r) {
            return e * (t /= r) * t * t * t + n
        }
        static EaseOutQuart(t, n, e, r) {
            return -e * ((t = t / r - 1) * t * t * t - 1) + n
        }
        static EaseInOutQuart(t, n, e, r) {
            return 1 > (t /= r / 2) ? e / 2 * t * t * t * t + n : -e / 2 * ((t -= 2) * t * t * t - 2) + n
        }
        static EaseInQuint(t, n, e, r) {
            return e * (t /= r) * t * t * t * t + n
        }
        static EaseOutQuint(t, n, e, r) {
            return e * ((t = t / r - 1) * t * t * t * t + 1) + n
        }
        static EaseInOutQuint(t, n, e, r) {
            return 1 > (t /= r / 2) ? e / 2 * t * t * t * t * t + n : e / 2 * ((t -= 2) * t * t * t * t + 2) + n
        }
        static EaseInSine(t, a, e, n) {
            return -e * i(t / n * (y / 2)) + e + a
        }
        static EaseOutSine(t, a, e, n) {
            return e * h(t / n * (y / 2)) + a
        }
        static EaseInOutSine(t, a, e, n) {
            return -e / 2 * (i(y * t / n) - 1) + a
        }
        static EaseInExpo(t, a, e, n) {
            return 0 === t ? a : e * f(2, 10 * (t / n - 1)) + a
        }
        static EaseOutExpo(t, a, e, n) {
            return t === n ? a + e : e * (-f(2, -10 * t / n) + 1) + a
        }
        static EaseInOutExpo(t, n, e, r) {
            return 0 === t ? n : t === r ? n + e : 1 > (t /= r / 2) ? e / 2 * f(2, 10 * (t - 1)) + n : e / 2 * (-f(2, -10 * --t) + 2) + n
        }
        static EaseInCirc(t, n, e, r) {
            return -e * (S(1 - (t /= r) * t) - 1) + n
        }
        static EaseOutCirc(t, n, e, r) {
            return e * S(1 - (t = t / r - 1) * t) + n
        }
        static EaseInOutCirc(t, n, e, r) {
            return 1 > (t /= r / 2) ? -e / 2 * (S(1 - t * t) - 1) + n : e / 2 * (S(1 - (t -= 2) * t) + 1) + n
        }
        static EaseInElastic(e, a, n, r) {
            let i = 1.70158
              , u = 0
              , c = n;
            return 0 === e ? a : 1 === (e /= r) ? a + n : (u || (u = .3 * r),
            c < _(n) ? (c = n,
            i = u / 4) : i = u / (2 * y) * t(n / c),
            -(c * f(2, 10 * (e -= 1)) * h((e * r - i) * (2 * y) / u)) + a)
        }
        static EaseOutElastic(e, a, n, r) {
            let i = 1.70158
              , u = 0
              , c = n;
            return 0 === e ? a : 1 === (e /= r) ? a + n : (u || (u = .3 * r),
            c < _(n) ? (c = n,
            i = u / 4) : i = u / (2 * y) * t(n / c),
            c * f(2, -10 * e) * h((e * r - i) * (2 * y) / u) + n + a)
        }
        static EaseInOutElastic(e, a, n, r) {
            let i = 1.70158
              , u = 0
              , c = n;
            return 0 === e ? a : 2 == (e /= r / 2) ? a + n : (u || (u = r * (.3 * 1.5)),
            c < _(n) ? (c = n,
            i = u / 4) : i = u / (2 * y) * t(n / c),
            1 > e ? -.5 * (c * f(2, 10 * (e -= 1)) * h((e * r - i) * (2 * y) / u)) + a : .5 * (c * f(2, -10 * (e -= 1)) * h((e * r - i) * (2 * y) / u)) + n + a)
        }
        static EaseInBack(t, n, e, r, i) {
            return void 0 === i && (i = 1.70158),
            e * (t /= r) * t * ((i + 1) * t - i) + n
        }
        static EaseOutBack(t, n, e, r, i) {
            return void 0 === i && (i = 1.70158),
            e * ((t = t / r - 1) * t * ((i + 1) * t + i) + 1) + n
        }
        static EaseInOutBack(t, n, e, r, i) {
            return void 0 === i && (i = 1.70158),
            1 > (t /= r / 2) ? e / 2 * (t * t * (((i *= 1.525) + 1) * t - i)) + n : e / 2 * ((t -= 2) * t * (((i *= 1.525) + 1) * t + i) + 2) + n
        }
        static EaseInBounce(t, a, e, n) {
            return e - u.EaseOutBounce(n - t, 0, e, n) + a
        }
        static EaseOutBounce(t, n, e, r) {
            return (t /= r) < 1 / 2.75 ? e * (7.5625 * t * t) + n : t < 2 / 2.75 ? e * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + n : t < 2.5 / 2.75 ? e * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + n : e * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + n
        }
        static EaseInOutBounce(t, a, e, n) {
            return t < n / 2 ? .5 * u.EaseInBounce(2 * t, 0, e, n) + a : .5 * u.EaseOutBounce(2 * t - n, 0, e, n) + .5 * e + a
        }
        static EaseCubicBezier(t, a, n, r, i) {
            return a + 3 * t * (n - a) + 3 * t ** 2 * (a + r - 2 * n) + t ** 3 * (i - a + 3 * n - 3 * r)
        }
        static EaseSpline(t, _, e, d, u, c, i, g, h, l) {
            const m = b(t, _, d, c, g, l)
              , n = T(e, u, i, h)
              , f = r(e, u, i, h)
              , p = a(e, u, i, h);
            return I(m, n, f, p)
        }
        static GetBezierSamples(t, n, e, i) {
            const _ = []
              , d = T(t, n, e, i)
              , u = r(t, n, e, i)
              , c = a(t, n, e, i);
            for (let r = 0; r < m; ++r) {
                const e = I(r * G, d, u, c);
                _.push(e)
            }
            return _
        }
    }
    ;
    const m = 11
      , G = 1 / 10
      , T = (e,t,a,n)=>n - 3 * a + 3 * t - e
      , r = (e,t,a)=>3 * a - 6 * t + 3 * e
      , a = (e,t)=>3 * (t - e)
      , I = (t,n,e,a)=>((n * t + e) * t + a) * t
      , c = (t,n,e,a)=>3 * n * t * t + 2 * e * t + a
      , b = (f,d,e,g,h,i)=>{
        if (1 == f)
            return 1;
        let S = 0
          , y = 1
          , b = i[y]
          , C = i[10];
        for (; 10 != y && b <= f; )
            y++,
            b = i[y],
            S += G;
        y--,
        b = i[y];
        const n = (f - b) / (i[y + 1] - b);
        let x = S + n * G;
        const P = T(d, e, g, h)
          , t = r(d, e, g, h)
          , u = a(d, e, g, h)
          , v = c(x, P, t, u);
        if (0 === v)
            return x;
        if (.02 <= v) {
            for (let e = 0; 4 > e; ++e) {
                const e = I(x, P, t, u) - f
                  , a = c(x, P, t, u);
                x -= e / a
            }
            return x
        } else {
            let n = S, e = S + G, r = 0, l, a;
            do {
                x = n + (e - n) / 2;
                let d = I(x, P, t, u) - f;
                0 < d ? e = x : n = x,
                l = 1e-7 < _(d),
                a = 10 > ++r
            } while (l && a);
            return x
        }
    }
}(),
'use strict';
{
    function e(e) {
        if (!C3.IsString(e))
            ;
    }
    C3.ProbabilityTable = class {
        constructor() {
            this._items = [],
            this._totalWeight = 0
        }
        Release() {
            this.Clear(),
            this._items = null
        }
        Clear() {
            C3.clear2DArray(this._items),
            this._totalWeight = 0
        }
        GetTotalWeight() {
            return this._totalWeight
        }
        Sample(e=Math.random() * this.GetTotalWeight()) {
            let t = 0;
            for (const [a,n] of this._items)
                if (t += a,
                e < t)
                    return n;
            return 0
        }
        AddItem(t, a) {
            e(a),
            this._totalWeight += t,
            this._items.push([t, a])
        }
        RemoveItem(t, n) {
            e(n);
            for (let r = 0; r < this._items.length; r++) {
                const a = this._items[r]
                  , i = 0 === t || a[0] === t
                  , e = a[1] === n;
                if (i && e) {
                    this._items.splice(r, 1),
                    this._totalWeight -= a[0];
                    break
                }
            }
        }
        asJSON() {
            return JSON.stringify(this._items)
        }
        static fromJSON(e) {
            const t = new C3.ProbabilityTable
              , a = JSON.parse(e);
            for (const n of a) {
                const e = n[0]
                  , a = n[1];
                t.AddItem(e, a)
            }
            return t
        }
    }
}
'use strict',
C3.Event = class {
    constructor(e, t) {
        this.type = e,
        this.cancelable = !!t,
        this.defaultPrevented = !1,
        this.propagationStopped = !1,
        this.isAsync = !1
    }
    preventDefault() {
        if (!this.cancelable)
            throw new Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable)
            throw new Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync)
            throw new Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}
,
'use strict',
C3.Event.Handler = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._type = e,
        this._captureListeners = [],
        this._captureListenersSet = new Set,
        this._listeners = [],
        this._listenersSet = new Set,
        this._fireDepth = 0,
        this._queueAddListeners = [],
        this._queueRemoveCaptureListeners = [],
        this._queueRemoveListeners = []
    }
    Release() {
        0 < this._fireDepth || (C3.clearArray(this._captureListeners),
        this._captureListenersSet.clear(),
        C3.clearArray(this._listeners),
        this._listenersSet.clear(),
        C3.clearArray(this._queueAddListeners),
        C3.clearArray(this._queueRemoveCaptureListeners),
        C3.clearArray(this._queueRemoveListeners),
        C3.Release(this))
    }
    _AddListener(e, t) {
        if (this._IsFiring())
            return void this._queueAddListeners.push([e, t]);
        if (t) {
            if (this._captureListenersSet.has(e))
                return;
            this._captureListeners.push(e),
            this._captureListenersSet.add(e)
        } else {
            if (this._listenersSet.has(e))
                return;
            this._listeners.push(e),
            this._listenersSet.add(e)
        }
    }
    _RemoveListener(e, t) {
        return this._IsFiring() ? void (t ? this._queueRemoveCaptureListeners.push(e) : this._queueRemoveListeners.push(e)) : void (t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e),
        C3.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e),
        C3.arrayFindRemove(this._listeners, e)))
    }
    _IsEmpty() {
        return !this._captureListeners.length && !this._listeners.length
    }
    _IsFiring() {
        return 0 < this._fireDepth
    }
    _ProcessQueuedListeners() {
        for (let e of this._queueAddListeners)
            this._AddListener(...e);
        C3.clearArray(this._queueAddListeners);
        for (const e of this._queueRemoveListeners)
            this._listenersSet.delete(e);
        for (const e of this._queueRemoveCaptureListeners)
            this._captureListenersSet.delete(e);
        const e = new Set(this._queueRemoveListeners)
          , t = new Set(this._queueRemoveCaptureListeners);
        C3.arrayRemoveAllInSet(this._listeners, e),
        C3.arrayRemoveAllInSet(this._captureListeners, t),
        C3.clearArray(this._queueRemoveCaptureListeners),
        C3.clearArray(this._queueRemoveListeners)
    }
    _FireCancellable(e) {
        this._IncreaseFireDepth();
        let t = !1;
        for (let a = 0, n = this._captureListeners.length; a < n; ++a)
            if (this._captureListeners[a](e),
            e.propagationStopped) {
                t = !0;
                break
            }
        if (!t)
            for (let t = 0, a = this._listeners.length; t < a && (this._listeners[t](e),
            !e.propagationStopped); ++t)
                ;
        return this._DecreaseFireDepth(),
        !e.defaultPrevented
    }
    _FireNonCancellable(e) {
        this._IncreaseFireDepth();
        for (let t = 0, a = this._captureListeners.length; t < a; ++t)
            this._captureListeners[t](e);
        for (let t = 0, a = this._listeners.length; t < a; ++t)
            this._listeners[t](e);
        return this._DecreaseFireDepth(),
        !0
    }
    _IncreaseFireDepth() {
        this._fireDepth++
    }
    _DecreaseFireDepth() {
        this._fireDepth--,
        0 === this._fireDepth && (this._queueAddListeners.length || this._queueRemoveCaptureListeners.length || this._queueRemoveListeners.length) && this._ProcessQueuedListeners()
    }
    SetDelayRemoveEventsEnabled(e) {
        e ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
    }
    _FireAsync(e) {
        let t = [];
        for (let a = 0, n = this._captureListeners.length, r; a < n; ++a)
            r = this._captureListeners[a],
            t.push(C3.Asyncify(()=>r(e)));
        for (let a = 0, n = this._listeners.length, r; a < n; ++a)
            r = this._listeners[a],
            t.push(C3.Asyncify(()=>r(e)));
        return Promise.all(t).then(()=>!e.defaultPrevented)
    }
    _FireAndWait_AsyncOptional(e) {
        const t = [];
        this._IncreaseFireDepth();
        for (let a = 0, n = this._captureListeners.length; a < n; ++a) {
            const n = this._captureListeners[a](e);
            n instanceof Promise && t.push(n)
        }
        for (let a = 0, n = this._listeners.length; a < n; ++a) {
            const n = this._listeners[a](e);
            n instanceof Promise && t.push(n)
        }
        return this._DecreaseFireDepth(),
        t.length ? Promise.all(t).then(()=>!e.defaultPrevented) : !e.defaultPrevented
    }
    async _FireAndWaitAsync(e) {
        return await this._FireAndWait_AsyncOptional(e)
    }
    async _FireAndWaitAsyncSequential(e) {
        this._IncreaseFireDepth();
        for (let t = 0, a = this._captureListeners.length; t < a; ++t) {
            const a = this._captureListeners[t](e);
            a instanceof Promise && (await a)
        }
        for (let t = 0, a = this._listeners.length; t < a; ++t) {
            const a = this._listeners[t](e);
            a instanceof Promise && (await a)
        }
        return this._DecreaseFireDepth(),
        !e.defaultPrevented
    }
    *_FireAsGenerator(e) {
        this._IncreaseFireDepth();
        for (let t = 0, a = this._captureListeners.length; t < a; ++t) {
            const a = this._captureListeners[t](e);
            C3.IsIterator(a) && (yield*a)
        }
        for (let t = 0, a = this._listeners.length; t < a; ++t) {
            const a = this._listeners[t](e);
            C3.IsIterator(a) && (yield*a)
        }
        this._DecreaseFireDepth()
    }
}
,
'use strict',
C3.Event.Dispatcher = class extends C3.DefendedBase {
    constructor() {
        super(),
        this._eventHandlers = new Map,
        this._dispatcherWasReleased = !1
    }
    Release() {
        if (this._dispatcherWasReleased)
            throw new Error('already released');
        this.ClearEvents(),
        this._dispatcherWasReleased = !0,
        C3.Release(this)
    }
    WasReleased() {
        return this._dispatcherWasReleased
    }
    ClearEvents() {
        for (let e of this._eventHandlers.values())
            e.Release();
        this._eventHandlers.clear()
    }
    _GetHandlerByType(e, t) {
        let a = this._eventHandlers.get(e);
        return a ? a : t ? (a = C3.New(C3.Event.Handler, e),
        this._eventHandlers.set(e, a),
        a) : null
    }
    addEventListener(e, t, a) {
        let n = this._GetHandlerByType(e, !0);
        n._AddListener(t, !!a)
    }
    removeEventListener(e, t, a) {
        let n = this._GetHandlerByType(e, !1);
        n && (n._RemoveListener(t, !!a),
        n._IsEmpty() && this._eventHandlers.delete(e))
    }
    dispatchEvent(e) {
        const t = this._GetHandlerByType(e.type, !1);
        return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e))
    }
    dispatchEventAsync(e) {
        const t = this._GetHandlerByType(e.type, !1);
        return t ? (e.isAsync = !0,
        t._FireAsync(e)) : Promise.resolve(!0)
    }
    async dispatchEventAndClearAsync(e) {
        const t = this._GetHandlerByType(e.type, !1);
        if (!t)
            return !0;
        this._eventHandlers.delete(e.type),
        e.isAsync = !0;
        const a = await t._FireAsync(e);
        return t.Release(),
        a
    }
    async dispatchEventAndWaitAsync(e) {
        const t = this._GetHandlerByType(e.type, !1);
        return !t || (await t._FireAndWaitAsync(e))
    }
    dispatchEventAndWait_AsyncOptional(e) {
        const t = this._GetHandlerByType(e.type, !1);
        return !t || t._FireAndWait_AsyncOptional(e)
    }
    async dispatchEventAndWaitAsyncSequential(e) {
        const t = this._GetHandlerByType(e.type, !1);
        return !t || (await t._FireAndWaitAsyncSequential(e))
    }
    dispatchGeneratorEvent(e) {
        const t = this._GetHandlerByType(e.type, !1);
        if (!t)
            return null;
        if (e.cancelable)
            throw new Error('not supported');
        else
            return t._FireAsGenerator(e)
    }
    SetDelayRemoveEventsEnabled(e) {
        for (const t of this._eventHandlers.values())
            t.SetDelayRemoveEventsEnabled(e)
    }
}
,
'use strict';
{
    function t(t) {
        c = _ && 0 === i ? requestIdleCallback(n, {
            timeout: e
        }) : setTimeout(n, 0 < i ? 1 : t)
    }
    function n(e) {
        if (c = -1,
        !u.length)
            return;
        let n = performance.now()
          , d = n
          , g = 0
          , p = 0;
        do
            a(u.shift()),
            d = performance.now(),
            ++g,
            p = 1.1 * ((d - n) / g);
        while (u.length && (_ && 0 === i && 'undefined' != typeof e ? p < e.timeRemaining() : d - n + p < r));
        if (-1 === c && u.length) {
            let e = d - n
              , a = Math.max(l - e, 4);
            t(a)
        }
    }
    function a(e) {
        let t;
        try {
            t = e.func()
        } catch (t) {
            return void e.reject(t)
        }
        e.resolve(t)
    }
    const r = 12
      , l = 16
      , e = 35
      , _ = 'undefined' != typeof requestIdleCallback;
    let u = []
      , c = -1
      , i = 0
      , g = C3.QueryString.Has('disable-asyncify');
    g && console.warn('[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.'),
    C3.Asyncify = function(n) {
        let r = null;
        return C3.isDebug && (r = C3.GetCallStack()),
        new Promise((i,e)=>(u.push({
            func: n,
            resolve: i,
            reject: e,
            stack: r
        }),
        g ? void a(u.pop()) : void (-1 === c && t(16))))
    }
    ,
    C3.Asyncify.SetHighThroughputMode = function(e) {
        if (e)
            ++i;
        else if (--i,
        0 > i)
            throw new Error('already turned off high throughput mode')
    }
}
{
    function t() {
        a = -1
    }
    function n() {
        l = -1,
        _ = -1;
        let t = Date.now();
        for (let n of e)
            if (n._CheckTimeout(t)) {
                let e = n._GetDeadline();
                (-1 === _ || e < _) && (_ = e)
            } else
                e.delete(n);
        if (-1 !== _) {
            let a = Math.max(_ - t + i, r);
            l = self.setTimeout(n, a)
        }
    }
    const r = 1e3
      , i = 100;
    let a = -1;
    C3.FastGetDateNow = function() {
        return -1 === a && (a = Date.now(),
        self.setTimeout(t, 16)),
        a
    }
    ;
    let l = -1
      , _ = -1
      , e = new Set;
    C3.IdleTimeout = class {
        constructor(e, t) {
            this._callback = e,
            this._timeout = 1e3 * t,
            this._deadline = 0,
            this._isActive = !1
        }
        Reset() {
            let t = C3.FastGetDateNow();
            this._deadline = t + this._timeout,
            this._isActive || (e.add(this),
            this._isActive = !0),
            -1 === l ? (_ = this._deadline,
            l = self.setTimeout(n, this._timeout + 100)) : this._deadline < _ && _ > t + r && (self.clearTimeout(l),
            _ = this._deadline,
            l = self.setTimeout(n, this._timeout + 100))
        }
        _CheckTimeout(e) {
            return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout,
            !0) : (this._isActive = !1,
            !1))
        }
        _GetDeadline() {
            return this._deadline
        }
        Cancel() {
            this._isActive && (e.delete(this),
            this._isActive = !1,
            0 === e.size && -1 !== l && (self.clearTimeout(l),
            l = -1,
            _ = -1))
        }
        Release() {
            this.Cancel(),
            this._callback = null
        }
    }
}
'use strict',
C3.Disposable = class e {
    constructor(e) {
        this._disposed = !1,
        this._disposeAction = e
    }
    Dispose() {
        this._disposed || (this._disposed = !0,
        this._disposeAction && (this._disposeAction(),
        this._disposeAction = null))
    }
    IsDisposed() {
        return this._disposed
    }
    Release() {
        this.Dispose()
    }
    static Release(t) {
        return new e(()=>t.Release())
    }
    static From(t, a, n, r, i) {
        if ('undefined' == typeof r || null === r)
            r = !1;
        else if ('boolean' != typeof r && 'object' != typeof r)
            throw new TypeError('invalid event listener options');
        if (i && (n = n.bind(i)),
        a.includes(' ')) {
            a = a.split(' ');
            const i = new C3.CompositeDisposable;
            for (let e of a)
                t.addEventListener(e, n, r),
                i.Add(C3.New(C3.Disposable, ()=>t.removeEventListener(e, n, r)));
            return i
        }
        return t.addEventListener(a, n, r),
        C3.New(C3.Disposable, ()=>t.removeEventListener(a, n, r))
    }
}
,
C3.StubDisposable = class extends C3.Disposable {
    SetAction(e) {
        this._disposeAction = e
    }
}
,
C3.CompositeDisposable = class extends C3.Disposable {
    constructor(...e) {
        super(),
        this._disposables = new Set;
        for (let t of e)
            this.Add(t)
    }
    Add(...e) {
        if (this._disposed)
            throw new Error('already disposed');
        for (let t of e)
            this._disposables.add(t)
    }
    Remove(e) {
        if (this._disposed)
            throw new Error('already disposed');
        this._disposables.delete(e)
    }
    RemoveAll() {
        if (this._disposed)
            throw new Error('already disposed');
        if (this._disposables) {
            for (let e of this._disposables)
                e.Dispose();
            this._disposables.clear()
        }
    }
    IsDisposed() {
        return this._disposed
    }
    Dispose() {
        if (this._disposed)
            throw new Error('already disposed');
        this._disposed = !0;
        for (let e of this._disposables)
            e.Dispose();
        this._disposables.clear(),
        this._disposables = null
    }
    Release() {
        this.Dispose()
    }
}
,
'use strict',
C3.KahanSum = class extends C3.DefendedBase {
    constructor() {
        super(),
        this._c = 0,
        this._y = 0,
        this._t = 0,
        this._sum = 0
    }
    Add(e) {
        e = +e,
        this._y = e - this._c,
        this._t = this._sum + this._y,
        this._c = this._t - this._sum - this._y,
        this._sum = this._t
    }
    Subtract(e) {
        this._sum -= +e
    }
    Get() {
        return this._sum
    }
    Reset() {
        this._c = 0,
        this._y = 0,
        this._t = 0,
        this._sum = 0
    }
    Set(e) {
        this._c = 0,
        this._y = 0,
        this._t = 0,
        this._sum = +e
    }
    Release() {}
}
,
'use strict';
{
    const t = {};
    t.RBnode = function(e) {
        this.tree = e,
        this.right = this.tree.sentinel,
        this.left = this.tree.sentinel,
        this.parent = null,
        this.color = !1,
        this.key = null
    }
    ,
    t.RedBlackSet = function(e) {
        this.size = 0,
        this.sentinel = new t.RBnode(this),
        this.sentinel.color = !1,
        this.root = this.sentinel,
        this.root.parent = this.sentinel,
        this.compare = e || this.default_compare
    }
    ,
    t.RedBlackSet.prototype.default_compare = function(e, t) {
        return e < t ? -1 : t < e ? 1 : 0
    }
    ,
    t.RedBlackSet.prototype.clone = function() {
        var e = new t.RedBlackSet(this.compare);
        return e.insertAll(this),
        e
    }
    ,
    t.RedBlackSet.prototype.clear = function() {
        this.size = 0,
        this.sentinel = new t.RBnode(this),
        this.sentinel.color = !1,
        this.root = this.sentinel,
        this.root.parent = this.sentinel
    }
    ,
    t.RedBlackSet.prototype.leftRotate = function(e) {
        var t = e.right;
        e.right = t.left,
        t.left != this.sentinel && (t.left.parent = e),
        t.parent = e.parent,
        e.parent == this.sentinel ? this.root = t : e == e.parent.left ? e.parent.left = t : e.parent.right = t,
        t.left = e,
        e.parent = t
    }
    ,
    t.RedBlackSet.prototype.rightRotate = function(e) {
        var t = e.left;
        e.left = t.right,
        t.right != this.sentinel && (t.right.parent = e),
        t.parent = e.parent,
        e.parent == this.sentinel ? this.root = t : e == e.parent.right ? e.parent.right = t : e.parent.left = t,
        t.right = e,
        e.parent = t
    }
    ,
    t.RedBlackSet.prototype.insert = function(a) {
        if (!this.contains(a)) {
            var n = new t.RBnode(this);
            n.key = a;
            for (var r = this.sentinel, i = this.root; i != this.sentinel; )
                r = i,
                i = 0 > this.compare(n.key, i.key) ? i.left : i.right;
            n.parent = r,
            r == this.sentinel ? this.root = n : 0 > this.compare(n.key, r.key) ? r.left = n : r.right = n,
            n.left = this.sentinel,
            n.right = this.sentinel,
            n.color = !0,
            this.insertFixup(n),
            this.size++
        } else {
            var l = this.get_(a);
            l.key = a
        }
    }
    ,
    t.RedBlackSet.prototype.insertFixup = function(e) {
        for (; e != this.sentinel && e != this.root && !0 == e.parent.color; )
            if (e.parent == e.parent.parent.left) {
                var t = e.parent.parent.right;
                !0 == t.color ? (e.parent.color = !1,
                t.color = !1,
                e.parent.parent.color = !0,
                e = e.parent.parent) : (e == e.parent.right && (e = e.parent,
                this.leftRotate(e)),
                e.parent.color = !1,
                e.parent.parent.color = !0,
                e.parent.parent != this.sentinel && this.rightRotate(e.parent.parent))
            } else {
                var t = e.parent.parent.left;
                !0 == t.color ? (e.parent.color = !1,
                t.color = !1,
                e.parent.parent.color = !0,
                e = e.parent.parent) : (e == e.parent.left && (e = e.parent,
                this.rightRotate(e)),
                e.parent.color = !1,
                e.parent.parent.color = !0,
                e.parent.parent != this.sentinel && this.leftRotate(e.parent.parent))
            }
        this.root.color = !1
    }
    ,
    t.RedBlackSet.prototype.delete_ = function(e) {
        var t, a;
        t = e.left == this.sentinel || e.right == this.sentinel ? e : this.successor_(e),
        a = t.left == this.sentinel ? t.right : t.left,
        a.parent = t.parent,
        t.parent == this.sentinel ? this.root = a : t == t.parent.left ? t.parent.left = a : t.parent.right = a,
        t != e && (e.key = t.key),
        !1 == t.color && this.deleteFixup(a),
        this.size--
    }
    ,
    t.RedBlackSet.prototype.deleteFixup = function(e) {
        for (; e != this.root && !1 == e.color; )
            if (e == e.parent.left) {
                var t = e.parent.right;
                !0 == t.color && (t.color = !1,
                e.parent.color = !0,
                this.leftRotate(e.parent),
                t = e.parent.right),
                !1 == t.left.color && !1 == t.right.color ? (t.color = !0,
                e = e.parent) : (!1 == t.right.color && (t.left.color = !1,
                t.color = !0,
                this.rightRotate(t),
                t = e.parent.right),
                t.color = e.parent.color,
                e.parent.color = !1,
                t.right.color = !1,
                this.leftRotate(e.parent),
                e = this.root)
            } else {
                var t = e.parent.left;
                !0 == t.color && (t.color = !1,
                e.parent.color = !0,
                this.rightRotate(e.parent),
                t = e.parent.left),
                !1 == t.right.color && !1 == t.left.color ? (t.color = !0,
                e = e.parent) : (!1 == t.left.color && (t.right.color = !1,
                t.color = !0,
                this.leftRotate(t),
                t = e.parent.left),
                t.color = e.parent.color,
                e.parent.color = !1,
                t.left.color = !1,
                this.rightRotate(e.parent),
                e = this.root)
            }
        e.color = !1
    }
    ,
    t.RedBlackSet.prototype.remove = function(e) {
        var t = this.get_(e);
        if (t != this.sentinel) {
            var a = t.key;
            return this.delete_(t),
            a
        }
        return null
    }
    ,
    t.RedBlackSet.prototype.removeSwapped = function(e, t) {
        this.remove(t)
    }
    ,
    t.RedBlackSet.prototype.min = function(e) {
        for (; e.left != this.sentinel; )
            e = e.left;
        return e
    }
    ,
    t.RedBlackSet.prototype.max = function(e) {
        for (; e.right != this.sentinel; )
            e = e.right;
        return e
    }
    ,
    t.RedBlackSet.prototype.successor_ = function(e) {
        if (e.right != this.sentinel)
            return this.min(e.right);
        for (var t = e.parent; t != this.sentinel && e == t.right; )
            e = t,
            t = t.parent;
        return t
    }
    ,
    t.RedBlackSet.prototype.predeccessor_ = function(e) {
        if (e.left != this.sentinel)
            return this.max(e.left);
        for (var t = e.parent; t != this.sentinel && e == t.left; )
            e = t,
            t = t.parent;
        return t
    }
    ,
    t.RedBlackSet.prototype.successor = function(e) {
        if (0 < this.size) {
            var t = this.get_(e);
            if (t == this.sentinel)
                return null;
            if (t.right != this.sentinel)
                return this.min(t.right).key;
            for (var a = t.parent; a != this.sentinel && t == a.right; )
                t = a,
                a = a.parent;
            return a == this.sentinel ? null : a.key
        }
        return null
    }
    ,
    t.RedBlackSet.prototype.predecessor = function(e) {
        if (0 < this.size) {
            var t = this.get_(e);
            if (t == this.sentinel)
                return null;
            if (t.left != this.sentinel)
                return this.max(t.left).key;
            for (var a = t.parent; a != this.sentinel && t == a.left; )
                t = a,
                a = a.parent;
            return a == this.sentinel ? null : a.key
        }
        return null
    }
    ,
    t.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key
    }
    ,
    t.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key
    }
    ,
    t.RedBlackSet.prototype.get_ = function(e) {
        for (var t = this.root; t != this.sentinel && 0 != this.compare(t.key, e); )
            t = 0 > this.compare(e, t.key) ? t.left : t.right;
        return t
    }
    ,
    t.RedBlackSet.prototype.contains = function(e) {
        return null != this.get_(e).key
    }
    ,
    t.RedBlackSet.prototype.getValues = function() {
        var e = [];
        return this.forEach(function(t) {
            e.push(t)
        }),
        e
    }
    ,
    t.RedBlackSet.prototype.insertAll = function(a) {
        if ('array' == t.typeOf(a))
            for (var n = 0; n < a.length; n++)
                this.insert(a[n]);
        else if ('function' == t.typeOf(a.forEach))
            a.forEach(this.insert, this);
        else if ('function' == t.typeOf(a.getValues))
            for (var r = a.getValues(), n = 0; n < r.length; n++)
                this.insert(r[n]);
        else if ('object' == t.typeOf(a))
            for (var i in a)
                this.insert(a[i])
    }
    ,
    t.RedBlackSet.prototype.removeAll = function(a) {
        if ('array' == t.typeOf(a))
            for (var n = 0; n < a.length; n++)
                this.remove(a[n]);
        else if ('function' == t.typeOf(a.forEach))
            a.forEach(this.removeSwapped, this);
        else if ('function' == t.typeOf(a.getValues))
            for (var r = a.getValues(), n = 0; n < r.length; n++)
                this.remove(r[n]);
        else if ('object' == t.typeOf(a))
            for (var i in a)
                this.remove(a[i])
    }
    ,
    t.RedBlackSet.prototype.containsAll = function(a) {
        if ('array' == t.typeOf(a)) {
            for (var n = 0; n < a.length; n++)
                if (!this.contains(a[n]))
                    return !1;
            return !0
        }
        if ('function' == t.typeOf(a.forEach))
            return a.every(this.contains, this);
        if ('function' == t.typeOf(a.getValues)) {
            for (var r = a.getValues(), n = 0; n < r.length; n++)
                if (!this.contains(r[n]))
                    return !1;
            return !0
        }
        if ('object' == t.typeOf(a)) {
            for (var i in a)
                if (!this.contains(a[i]))
                    return !1;
            return !0
        }
    }
    ,
    t.RedBlackSet.prototype.range = function(e, t) {
        var n = [];
        return this.traverseFromTo(function(e) {
            n.push(e)
        }, e, t),
        n
    }
    ,
    t.RedBlackSet.prototype.traverse = function(e, t) {
        if (!this.isEmpty())
            for (var a = this.min(this.root); a != this.sentinel; ) {
                if (e.call(t, a.key, this))
                    return;
                a = this.successor_(a)
            }
    }
    ,
    t.RedBlackSet.prototype.traverseFrom = function(e, t, a) {
        if (!this.isEmpty())
            for (var n = this.get_(t); n != this.sentinel; ) {
                if (e.call(a, n.key, this))
                    return;
                n = this.successor_(n)
            }
    }
    ,
    t.RedBlackSet.prototype.traverseTo = function(t, a, n) {
        if (!this.isEmpty())
            for (var r = this.min(this.root), i = this.get_(a); r != i; ) {
                if (t.call(n, r.key, this))
                    return;
                r = this.successor_(r)
            }
    }
    ,
    t.RedBlackSet.prototype.traverseFromTo = function(t, a, n, r) {
        if (!this.isEmpty())
            for (var i = this.get_(a), l = this.get_(n); i != l; ) {
                if (t.call(r, i.key, this))
                    return;
                i = this.successor_(i)
            }
    }
    ,
    t.RedBlackSet.prototype.traverseBackwards = function(e, t) {
        if (!this.isEmpty())
            for (var a = this.max(this.root); a != this.sentinel; ) {
                if (e.call(t, a.key, this))
                    return;
                a = this.predeccessor_(a)
            }
    }
    ,
    t.RedBlackSet.prototype.forEach = function(e, t) {
        if (!this.isEmpty())
            for (var a = this.min(this.root); a != this.sentinel; a = this.successor_(a))
                e.call(t, a.key, a.key, this)
    }
    ,
    t.RedBlackSet.prototype.some = function(e, t) {
        if (this.isEmpty())
            return !1;
        for (var a = this.min(this.root); a != this.sentinel; a = this.successor_(a))
            if (e.call(t, a.key, a.key, this))
                return !0;
        return !1
    }
    ,
    t.RedBlackSet.prototype.every = function(e, t) {
        if (this.isEmpty())
            return !1;
        for (var a = this.min(this.root); a != this.sentinel; a = this.successor_(a))
            if (!e.call(t, a.key, a.key, this))
                return !1;
        return !0
    }
    ,
    t.RedBlackSet.prototype.map = function(e, t) {
        var a = [];
        if (this.isEmpty())
            return a;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))
            a.push(e.call(t, n.key, n.key, this));
        return a
    }
    ,
    t.RedBlackSet.prototype.filter = function(e, t) {
        var a = [];
        if (this.isEmpty())
            return a;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))
            e.call(t, n.key, n.key, this) && a.push(n.key);
        return a
    }
    ,
    t.RedBlackSet.prototype.getCount = function() {
        return this.size
    }
    ,
    t.RedBlackSet.prototype.isEmpty = function() {
        return 0 == this.size
    }
    ,
    t.RedBlackSet.prototype.isSubsetOf = function(a) {
        var n = t.getCount(a);
        if (this.getCount() > n)
            return !1;
        var r = 0;
        if (this.isEmpty())
            return !0;
        for (var i = this.min(this.root); i != this.sentinel; i = this.successor_(i))
            t.contains.call(a, a, i.key) && r++;
        return r == this.getCount()
    }
    ,
    t.RedBlackSet.prototype.intersection = function(e) {
        var a = new t.RedBlackSet(this.compare);
        if (this.isEmpty())
            return a;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))
            e.contains.call(e, n.key, n.key, this) && a.insert(n.key);
        return a
    }
    ,
    C3.RedBlackSet = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._rbSet = new t.RedBlackSet(e),
            this._enableQueue = !1,
            this._queueInsert = new Set,
            this._queueRemove = new Set
        }
        Add(e) {
            this._enableQueue ? this._rbSet.contains(e) ? this._queueRemove.delete(e) : this._queueInsert.add(e) : this._rbSet.insert(e)
        }
        Remove(e) {
            this._enableQueue ? this._rbSet.contains(e) ? this._queueRemove.add(e) : this._queueInsert.delete(e) : this._rbSet.remove(e)
        }
        Has(e) {
            return this._enableQueue ? !!this._queueInsert.has(e) || !this._queueRemove.has(e) && this._rbSet.contains(e) : this._rbSet.contains(e)
        }
        Clear() {
            this._rbSet.clear(),
            this._queueInsert.clear(),
            this._queueRemove.clear()
        }
        toArray() {
            if (this._enableQueue)
                throw new Error('cannot be used in queueing mode');
            return this._rbSet.getValues()
        }
        GetSize() {
            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
        }
        IsEmpty() {
            return 0 === this.GetSize()
        }
        Front() {
            if (this.IsEmpty())
                throw new Error('empty set');
            if (this._enableQueue)
                throw new Error('cannot be used in queueing mode');
            const e = this._rbSet
              , t = e.min(e.root);
            return t.key
        }
        Shift() {
            if (this.IsEmpty())
                throw new Error('empty set');
            if (this._enableQueue)
                throw new Error('cannot be used in queueing mode');
            const e = this.Front();
            return this.Remove(e),
            e
        }
        SetQueueingEnabled(e) {
            if ((e = !!e,
            this._enableQueue !== e) && (this._enableQueue = e,
            !e)) {
                for (const e of this._queueRemove)
                    this._rbSet.remove(e);
                this._queueRemove.clear();
                for (const e of this._queueInsert)
                    this._rbSet.insert(e);
                this._queueInsert.clear()
            }
        }
        ForEach(e) {
            this._rbSet.forEach(e)
        }
        *values() {
            if (!this.IsEmpty()) {
                const e = this._rbSet;
                for (let t = e.min(e.root); t != e.sentinel; t = e.successor_(t))
                    yield t.key
            }
        }
        [Symbol.iterator]() {
            return this.values()
        }
    }
}
'use strict',
C3.PromiseThrottle = class {
    constructor(e=C3.hardwareConcurrency) {
        this._maxParallel = e,
        this._queue = [],
        this._activeCount = 0
    }
    Add(e) {
        return new Promise((t,a)=>{
            this._queue.push({
                func: e,
                resolve: t,
                reject: a
            }),
            this._MaybeStartNext()
        }
        )
    }
    _FindInQueue(e) {
        for (let t = 0, a = this._queue.length; t < a; ++t)
            if (this._queue[t].func === e)
                return t;
        return -1
    }
    RemoveAndResolve(e, t) {
        const a = this._FindInQueue(e);
        if (-1 === a)
            throw new Error('cannot find promise to resolve');
        this._queue[a].resolve(t),
        this._queue.splice(a, 1)
    }
    RemoveAndReject(e, t) {
        const a = this._FindInQueue(e);
        if (-1 === a)
            throw new Error('cannot find promise to reject');
        this._queue[a].reject(t),
        this._queue.splice(a, 1)
    }
    async _MaybeStartNext() {
        if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
            this._activeCount++;
            const e = this._queue.shift();
            try {
                const t = await e.func();
                e.resolve(t)
            } catch (t) {
                e.reject(t)
            }
            this._activeCount--,
            this._MaybeStartNext()
        }
    }
    static async Batch(t, n) {
        const r = [];
        let i = !1;
        const l = async()=>{
            for (let e; e = n.pop(); ) {
                if (i)
                    return;
                try {
                    r.push((await e()))
                } catch (e) {
                    throw i = !0,
                    e
                }
            }
        }
          , e = [];
        for (; t--; )
            e.push(l());
        return await Promise.all(e),
        r
    }
}
,
'use strict',
C3.RateLimiter = class {
    constructor(e, t, a) {
        this._callback = e,
        this._interval = t,
        this._intervalOnBattery = a || 2 * t,
        this._timerId = -1,
        this._lastCallTime = -Infinity,
        this._timerCallFunc = ()=>this._OnTimer(),
        this._ignoreReset = !1,
        this._canRunImmediate = !1,
        this._callbackArguments = null
    }
    SetCanRunImmediate(e) {
        this._canRunImmediate = !!e
    }
    _GetInterval() {
        return 'undefined' != typeof C3.Battery && C3.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
    }
    Call(...e) {
        if (-1 === this._timerId) {
            this._callbackArguments = e;
            let t = C3.FastGetDateNow()
              , a = t - this._lastCallTime
              , n = this._GetInterval();
            a >= n && this._canRunImmediate ? (this._lastCallTime = t,
            this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(n - a, 4))
        }
    }
    _RunCallback() {
        this._ignoreReset = !0;
        const e = this._callbackArguments;
        this._callbackArguments = null,
        e ? this._callback(...e) : this._callback(),
        this._ignoreReset = !1
    }
    Reset() {
        this._ignoreReset || (this._CancelTimer(),
        this._callbackArguments = null,
        this._lastCallTime = C3.FastGetDateNow())
    }
    _OnTimer() {
        this._timerId = -1,
        this._lastCallTime = C3.FastGetDateNow(),
        this._RunCallback()
    }
    _CancelTimer() {
        -1 !== this._timerId && (self.clearTimeout(this._timerId),
        this._timerId = -1)
    }
    Release() {
        this._CancelTimer(),
        this._callback = null,
        this._callbackArguments = null,
        this._timerCallFunc = null
    }
}
,
'use strict',
C3.SVGRasterManager = class {
    constructor() {
        this._images = new Map,
        this._allowNpotSurfaces = !1,
        this._getBaseSizeCallback = null,
        this._rasterAtSizeCallback = null,
        this._releaseResultCallback = null,
        this._redrawCallback = null
    }
    SetNpotSurfaceAllowed(e) {
        this._allowNpotSurfaces = !!e
    }
    IsNpotSurfaceAllowed() {
        return this._allowNpotSurfaces
    }
    SetGetBaseSizeCallback(e) {
        this._getBaseSizeCallback = e
    }
    GetBaseSize(e) {
        if (!this._getBaseSizeCallback)
            throw new Error('no get base size callback set');
        return this._getBaseSizeCallback(e)
    }
    SetRasterAtSizeCallback(e) {
        this._rasterAtSizeCallback = e
    }
    RasterAtSize(t, a, n, r, i, e) {
        if (!this._rasterAtSizeCallback)
            throw new Error('no raster at size callback set');
        return this._rasterAtSizeCallback(t, a, n, r, i, e)
    }
    SetReleaseResultCallback(e) {
        this._releaseResultCallback = e
    }
    ReleaseResult(e) {
        if (!this._releaseResultCallback)
            throw new Error('no release result callback set');
        this._releaseResultCallback(e)
    }
    SetRedrawCallback(e) {
        this._redrawCallback = e
    }
    Redraw() {
        if (!this._redrawCallback)
            throw new Error('no redraw callback set');
        this._redrawCallback()
    }
    AddImage(e) {
        let t = this._images.get(e);
        return t || (t = C3.New(C3.SVGRasterImage, this, e),
        this._images.set(e, t)),
        t.IncReference(),
        t
    }
    _RemoveImage(e) {
        this._images.delete(e.GetDataSource())
    }
}
,
'use strict';
{
    const t = 2048;
    C3.SVGRasterImage = class {
        constructor(e, t) {
            this._manager = e,
            this._dataSource = t,
            this._refCount = 0,
            this._baseWidth = 0,
            this._baseHeight = 0,
            this._getBaseSizePromise = this._manager.GetBaseSize(t).then(e=>{
                this._baseWidth = e[0],
                this._baseHeight = e[1],
                this._manager.Redraw()
            }
            ).catch(e=>{
                console.error('[SVG] Error loading SVG: ', e),
                this._hadError = !0,
                this._manager.Redraw()
            }
            ),
            this._rasterSurfaceWidth = 0,
            this._rasterSurfaceHeight = 0,
            this._rasterImageWidth = 0,
            this._rasterImageHeight = 0,
            this._isRasterizing = !1,
            this._rasterizedResult = null,
            this._forceRaster = !1,
            this._hadError = !1
        }
        Release() {
            if (0 >= this._refCount)
                throw new Error('already released');
            this._refCount--,
            0 === this._refCount && this._Release()
        }
        _Release() {
            this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult),
            this._rasterizedResult = null),
            this._manager._RemoveImage(this),
            this._manager = null
        }
        GetDataSource() {
            return this._dataSource
        }
        IncReference() {
            this._refCount++
        }
        HasReferences() {
            return 0 < this._refCount
        }
        GetRasterizedResult() {
            return this._rasterizedResult
        }
        ForceRasterAgain() {
            this._forceRaster = !0
        }
        async StartRasterForSize(n, r, l) {
            var a = Math.min
              , e = Math.ceil;
            if (0 === r || 0 === l || this._hadError)
                return;
            if (this._isRasterizing)
                return;
            let _ = C3.nextHighestPowerOfTwo(e(r))
              , u = C3.nextHighestPowerOfTwo(e(l));
            const m = Math.max(_, u);
            if (m > t) {
                const n = t / m;
                r *= n,
                l *= n,
                _ = a(e(_ * n), t),
                u = a(e(u * n), t)
            }
            if (r < _ && l < u) {
                const e = r / l
                  , t = _ / u;
                t > e ? (r = u * e,
                l = u) : (r = _,
                l = _ / e)
            }
            if (this._manager.IsNpotSurfaceAllowed() && (_ = e(r),
            u = e(l)),
            !(_ <= this._rasterSurfaceWidth && u <= this._rasterSurfaceHeight && !this._forceRaster)) {
                this._isRasterizing = !0,
                this._rasterSurfaceWidth = _,
                this._rasterSurfaceHeight = u;
                const e = await this._manager.RasterAtSize(this._dataSource, n, this._rasterSurfaceWidth, this._rasterSurfaceHeight, r, l);
                this._rasterizedResult && this._manager.ReleaseResult(this._rasterizedResult),
                this._rasterizedResult = e,
                this._rasterImageWidth = r,
                this._rasterImageHeight = l,
                this._isRasterizing = !1,
                this._forceRaster = !1,
                this._manager.Redraw()
            }
        }
        WhenBaseSizeReady() {
            return this._getBaseSizePromise
        }
        GetBaseWidth() {
            return this._baseWidth
        }
        GetBaseHeight() {
            return this._baseHeight
        }
        GetRasterWidth() {
            return this._rasterImageWidth
        }
        GetRasterHeight() {
            return this._rasterImageHeight
        }
        HadError() {
            return this._hadError
        }
    }
}
{
    function t(e) {
        return _.get(e)
    }
    C3.UTF8_BOM = '\uFEFF';
    const n = new Set([...'0123456789']);
    C3.IsNumericChar = function(e) {
        return n.has(e)
    }
    ;
    const r = new Set([...' \t\n\r\xA0\x85\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000']);
    C3.IsWhitespaceChar = function(e) {
        return r.has(e)
    }
    ,
    C3.FilterWhitespace = function(e) {
        return [...e].filter(e=>!C3.IsWhitespaceChar(e)).join('')
    }
    ,
    C3.IsStringAllWhitespace = function(e) {
        for (const t of e)
            if (!C3.IsWhitespaceChar(t))
                return !1;
        return !0
    }
    ,
    C3.IsUnprintableChar = function(e) {
        return 1 === e.length && 32 > e.charCodeAt(0)
    }
    ,
    C3.FilterUnprintableChars = function(e) {
        return [...e].filter(e=>!C3.IsUnprintableChar(e)).join('')
    }
    ;
    const l = new Set([...'0123456789.+-e']);
    C3.IsStringNumber = function(e) {
        if (e = e.trim(),
        !e.length)
            return !1;
        let t = e.charAt(0);
        if ('-' !== t && !n.has(t))
            return !1;
        for (let t of e)
            if (!l.has(t))
                return !1;
        return !0
    }
    ,
    C3.RemoveTrailingDigits = function(e) {
        let t = e.length;
        for (; 0 < t; ) {
            let a = e.charAt(t - 1);
            if (!C3.IsNumericChar(a))
                break;
            --t
        }
        return e.substr(0, t)
    }
    ,
    C3.IncrementNumberAtEndOf = function(e) {
        let t = C3.RemoveTrailingDigits(e)
          , a = e.substr(t.length);
        return a = a ? (parseInt(a, 10) + 1).toString() : '2',
        t + a
    }
    ;
    const _ = new Map([['&', '&amp;'], ['<', '&lt;'], ['>', '&gt;'], ['"', '&quot;'], ['\'', '&#39;']])
      , e = /[&<>"']/g;
    C3.EscapeHTML = function(a) {
        return a.replace(e, t)
    }
    ,
    C3.EscapeJS = function(e) {
        let t = C3.ReplaceAll(e, '\\', '\\\\');
        return t = C3.ReplaceAll(t, '"', '\\"'),
        t = C3.ReplaceAll(t, '\t', '\\t'),
        t = C3.ReplaceAll(t, '\r', ''),
        C3.ReplaceAll(t, '\n', '\\n')
    }
    ,
    C3.EscapeXML = function(e) {
        let t = C3.ReplaceAll(e, '&', '&amp;');
        return t = C3.ReplaceAll(t, '<', '&lt;'),
        t = C3.ReplaceAll(t, '>', '&gt;'),
        C3.ReplaceAll(t, '"', '&quot;')
    }
    ;
    const d = /[-[\]{}()*+?.,\\^$|#\s]/g;
    C3.EscapeRegex = function(e) {
        return e.replace(d, '\\$&')
    }
    ,
    C3.FindAll = function(t, n, r=!1) {
        if (!n)
            return [];
        r || (t = t.toLowerCase(),
        n = n.toLowerCase());
        const i = n.length;
        let l = 0
          , _ = 0
          , d = [];
        for (; -1 < (_ = t.indexOf(n, l)); )
            d.push(_),
            l = _ + i;
        return d
    }
    ,
    C3.ReplaceAll = function(e, t, a) {
        return e.replace(new RegExp(C3.EscapeRegex(t),'g'), ()=>a)
    }
    ,
    C3.ReplaceAllCaseInsensitive = function(e, t, a) {
        return e.replace(new RegExp(C3.EscapeRegex(t),'gi'), ()=>a)
    }
    ,
    C3.SetElementContent = function(e, t) {
        'string' == typeof t ? e.textContent = t : t.isPlainText() ? e.textContent = t.toString() : (e.innerHTML = t.toHTML(),
        t instanceof C3.BBString && t.attachLinkHandlers(e))
    }
    ,
    C3.StringLikeEquals = function(e, t) {
        return e instanceof C3.HtmlString || e instanceof C3.BBString ? e.equals(t) : t instanceof C3.HtmlString || t instanceof C3.BBString ? t.equals(e) : e === t
    }
    ,
    C3.StringSubstitute = function(t, ...a) {
        let n = t;
        for (let r = 0, i = a.length; r < i; ++r) {
            const i = `{${r}}`;
            if (!t.includes(i))
                throw new Error(`missing placeholder '${i}' in string substitution`);
            n = n.replace(i, a[r].toString())
        }
        return n
    }
    ,
    C3.StringSubstituteAllowMissing = function(t, ...a) {
        let n = t
          , r = -1
          , i = -1;
        for (let e = 0, l = a.length; e < l; ++e) {
            const l = `{${e}}`;
            t.includes(l) ? (i = e,
            n = n.replace(l, a[e].toString())) : -1 === r && (r = e)
        }
        if (0 <= r && 0 <= i && r < i)
            throw new Error(`missing placeholder '${r}' in string substitution`);
        return n
    }
    ,
    C3.StringSubstituteMap = function(e, t) {
        let a = e;
        for (let[n,r] of Object.entries(t))
            a = C3.ReplaceAll(a, n, r.toString());
        return a
    }
    ,
    C3.SortAZCaseInsensitive = function(e, t) {
        let a = e.toLowerCase()
          , n = t.toLowerCase();
        return a > n ? 1 : a < n ? -1 : 0
    }
    ;
    const u = 1024;
    C3.FormatDataSize = function(e, t) {
        var a = Math.round;
        let n = 'common.' + (t ? 'dataRates' : 'dataSizes') + '.';
        if (e < u)
            return langSub(n + 'bytes', e);
        if (1048576 > e) {
            let t = e / u;
            return t = 10 > t ? a(10 * t) / 10 : a(t),
            langSub(n + 'kilobytes', t)
        }
        if (1073741824 > e) {
            let t = e / 1048576;
            return t = 10 > t ? a(10 * t) / 10 : a(t),
            langSub(n + 'megabytes', t)
        }
        if (1099511627776 > e) {
            let t = e / 1073741824;
            return t = 10 > t ? a(10 * t) / 10 : a(t),
            langSub(n + 'gigabytes', t)
        } else {
            let t = e / 1099511627776;
            return t = 10 > t ? a(10 * t) / 10 : a(t),
            langSub(n + 'terabytes', t)
        }
    }
    ;
    const g = {
        approximate: !1,
        days: !0,
        hours: !0,
        minutes: !0,
        seconds: !0
    };
    C3.FormatTime = function(t, n) {
        var r = Math.floor;
        n = Object.assign({}, g, n),
        C3.Lang.PushContext('common.time');
        const i = [];
        if (n.days) {
            const e = r(t / 86400);
            0 < e && (t -= 3600 * (24 * e),
            i.push(langPluralSub('.days', null, e)))
        }
        if (n.hours) {
            const e = r(t / 3600);
            (0 < e || i.length) && (t -= 3600 * e,
            i.push(langPluralSub('.hours', null, e)))
        }
        if (n.minutes) {
            const a = r(t / 60);
            (0 < a || i.length || !n.seconds) && (t -= 60 * a,
            i.push(langPluralSub('.minutes', null, a)))
        }
        if (n.seconds) {
            const e = r(t % 60);
            i.push(langPluralSub('.seconds', null, e))
        }
        const l = (n.approximate ? lang('.approx-prefix') : '') + i.join(lang('.separator'));
        return C3.Lang.PopContext(),
        l
    }
    ,
    C3.ZeroPad = function(t, n) {
        let r = 0 > t ? '-' : '';
        t = Math.abs(t);
        let i = t.toString()
          , l = n - i.length;
        for (let e = 0; e < l; ++e)
            r += '0';
        return r + i
    }
    ,
    C3.StringToTitleCase = function(e) {
        return e.toLowerCase().replace(/\b\w/g, e=>e.toUpperCase())
    }
    ,
    C3.CompareVersionStrings = function(e, t) {
        let n = e.split('.').map(e=>e.trim())
          , r = t.split('.').map(e=>e.trim());
        C3.resizeArray(n, 4, '0'),
        C3.resizeArray(r, 4, '0'),
        n = n.map(e=>parseInt(e, 10)),
        r = r.map(e=>parseInt(e, 10));
        for (let i = 0; 4 > i; ++i) {
            const e = n[i] - r[i];
            if (0 != e)
                return 0 > e ? -1 : 1
        }
        return 0
    }
    ,
    C3.CreateGUID = function() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, e=>{
            const t = Math.floor(16 * Math.random())
              , a = 'x' === e ? t : 8 | 3 & t;
            return a.toString(16)
        }
        )
    }
    ,
    C3.StringHammingDistance = function(t, n) {
        if (t.length !== n.length)
            throw new Error('strings must be same length');
        let a = 0;
        for (let r = 0, i = t.length; r < i; ++r)
            t.charAt(r) !== n.charAt(r) && ++a;
        return a
    }
    ,
    C3.StringLevenshteinDistance = function(t, n) {
        var r = Math.min;
        if (0 === t.length)
            return n.length;
        if (0 === n.length)
            return t.length;
        let l, _, u, m, p, S;
        for (t.length > n.length && (l = t,
        t = n,
        n = l),
        S = Array(t.length + 1),
        _ = 0; _ <= t.length; _++)
            S[_] = _;
        for (_ = 1; _ <= n.length; _++) {
            for (m = _,
            u = 1; u <= t.length; u++)
                p = n[_ - 1] === t[u - 1] ? S[u - 1] : r(S[u - 1] + 1, r(m + 1, S[u] + 1)),
                S[u - 1] = m,
                m = p;
            S[t.length] = m
        }
        return S[t.length]
    }
}
{
    function t(t, r, l) {
        const _ = n.get(l);
        if (!_)
            return 'class' === l ? r ? '</span>' : `<span class="bbclass${e++}">` : t;
        if ('string' != typeof _) {
            if (Array.isArray(_)) {
                let e = _[0]
                  , t = _[1];
                return r ? '</' + e + '>' : `<${e} class="${t}">`
            }
        } else if ('a' === _ && !r) {
            const e = parseInt(l.substring(1), 10) - 1;
            if (0 > e || e >= i.length)
                throw new Error('invalid bbcode link substitution');
            const t = i[e];
            if ('string' == typeof t)
                return `<a href="${i[e]}">`;
            if ('function' == typeof t)
                return `<a class="bblink${e}">`;
            throw new TypeError('invalid bbcode link action')
        } else
            return '<' + r + _ + '>'
    }
    const n = new Map([['b', 'strong'], ['i', 'em'], ['s', 's'], ['u', 'u'], ['sub', 'sub'], ['sup', 'sup'], ['small', 'small'], ['mark', 'mark'], ['a1', 'a'], ['a2', 'a'], ['a3', 'a'], ['a4', 'a'], ['a5', 'a'], ['a6', 'a'], ['a7', 'a'], ['a8', 'a'], ['a9', 'a'], ['bad', ['span', 'bbCodeBad']], ['good', ['span', 'bbCodeGood']], ['info', ['span', 'bbCodeInfo']], ['h1', ['span', 'bbCodeH1']], ['h2', ['span', 'bbCodeH2']], ['h3', ['span', 'bbCodeH3']], ['h4', ['span', 'bbCodeH4']], ['item', ['span', 'bbCodeItem']]])
      , a = /\[(\/?)([a-zA-Z0-9]+)\]/g
      , r = /\[(\/?)(.*?)\]/g;
    let i = null
      , e = 0;
    const l = /\n/g;
    C3.BBString = class {
        constructor(e, t) {
            if (this._bbstr = t && t.noEscape ? e : C3.EscapeHTML(e),
            this._htmlstr = '',
            this._convertLineBreaks = !1,
            this._linkActions = [],
            t && (this._convertLineBreaks = !!t.convertLineBreaks,
            t.links)) {
                if (9 < t.links.length)
                    throw new Error('too many links');
                this._linkActions = t.links
            }
            this._hasAnyBBtags = this._bbstr.includes('['),
            this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes('\n'),
            this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes('&'),
            this._hasParsedFragments = !1,
            this._fragments = []
        }
        toString() {
            return this._bbstr
        }
        valueOf() {
            return this._bbstr
        }
        isPlainText() {
            return this._isPlain
        }
        toPlainText() {
            return this._hasAnyBBtags ? this._bbstr.replace(a, '') : this._bbstr
        }
        toHTML() {
            if (this._isPlain)
                return this._bbstr;
            if (!this._htmlstr && this._bbstr) {
                let n = this._bbstr;
                this._hasAnyBBtags && (e = 0,
                i = this._linkActions,
                n = n.replace(a, t),
                i = null),
                this._needsLineBreakConversion && (n = n.replace(l, '<br>')),
                this._htmlstr = n
            }
            return this._htmlstr
        }
        attachLinkHandlers(e) {
            if (this._linkActions.length)
                for (let t = 0, a = this._linkActions.length; t < a; ++t) {
                    const a = this._linkActions[t];
                    if ('function' != typeof a)
                        continue;
                    const n = e.querySelector('.bblink' + t);
                    if (!n)
                        throw new Error('unable to attach BBString link handler');
                    n.onclick = a
                }
        }
        equals(e) {
            return e instanceof C3.HtmlString ? this.toHTML() === e.toHTML() : e instanceof C3.BBString ? this._bbstr === e._bbstr : this._bbstr === e
        }
        toFragmentList() {
            if (this._hasParsedFragments)
                return this._fragments;
            const t = this._bbstr
              , n = [];
            r.lastIndex = 0;
            let a = 0
              , l = null;
            for (; null !== (l = r.exec(t)); ) {
                const e = l.index;
                if (0 < e && '\\' === t.charAt(e - 1))
                    continue;
                const r = l[0]
                  , _ = l[1]
                  , u = l[2]
                  , d = t.substring(a, e);
                if (a = e + r.length,
                d && this._fragments.push({
                    text: d,
                    styles: n.slice(0)
                }),
                u)
                    if (_) {
                        const e = u.toLowerCase();
                        for (let t = n.length - 1; 0 <= t; --t)
                            if (n[t].tag === e) {
                                n.splice(t, 1);
                                break
                            }
                    } else {
                        let e = u
                          , t = null;
                        const a = u.indexOf('=');
                        -1 === a ? e = e.toLowerCase() : (e = u.substring(0, a).toLowerCase(),
                        t = u.substring(a + 1)),
                        n.push({
                            tag: e,
                            param: t
                        })
                    }
            }
            a < t.length && this._fragments.push({
                text: t.substring(a),
                styles: n.slice(0)
            });
            for (const e of this._fragments)
                e.text = this._ProcessBBCodeEscapeSequences(e.text);
            return this._hasParsedFragments = !0,
            this._fragments
        }
        _ProcessBBCodeEscapeSequences(e) {
            return e = C3.ReplaceAll(e, '\\[', '['),
            C3.ReplaceAll(e, '\\\\', '\\')
        }
        static StripTags(e) {
            return C3.New(C3.BBString, e, {
                noEscape: !0
            }).toPlainText()
        }
        static StripAnyTags(e) {
            return e.replace(r, '')
        }
    }
}
'use strict',
C3.WordWrap = class {
    constructor() {
        this._lines = []
    }
    GetLines() {
        return this._lines
    }
    GetLineCount() {
        return this._lines.length
    }
    _MeasureLine(t, n) {
        let a = 0
          , r = 0;
        for (const i of t) {
            if (-1 === i.width) {
                const e = n(i.text, i.styles);
                i.width = e.width,
                i.height = e.height
            }
            a += i.width,
            r = Math.max(r, i.height)
        }
        return {
            width: a,
            height: r
        }
    }
    _AddLine(e, t, a) {
        this._lines.push({
            fragments: e,
            width: t,
            height: a
        })
    }
    WordWrap(t, n, r, i, l) {
        if ('string' == typeof t && (t = [{
            text: t,
            styles: []
        }]),
        C3.clearArray(this._lines),
        !t.length || 1 === t.length && !t[0].text.length || 2 > r)
            return;
        if (1 === t.length) {
            const e = t[0]
              , i = e.text
              , _ = e.styles;
            if (100 >= i.length && !i.includes('\n')) {
                let {width: e, height: t} = n(i, _);
                if (e += l,
                e <= r)
                    return void this._AddLine([{
                        text: i,
                        styles: _,
                        width: e,
                        height: t
                    }], e, t)
            }
        }
        let e;
        if ('word' === i)
            e = this._TokeniseWords(t);
        else {
            e = [];
            for (const n of t)
                C3.appendArray(e, [...n.text].map(e=>[{
                    text: e,
                    styles: n.styles
                }]))
        }
        this._WrapText(e, n, r, l)
    }
    _TokeniseWords(t) {
        const n = [];
        let r = []
          , i = !1;
        for (const l of t) {
            const t = l.text
              , _ = l.styles;
            for (const l of t)
                if ('\n' === l)
                    0 < r.length && n.push(r),
                    n.push([{
                        text: '\n',
                        styles: _
                    }]),
                    r = [];
                else if (0 === r.length)
                    r.push({
                        text: l,
                        styles: _
                    }),
                    i = C3.IsWhitespaceChar(l);
                else {
                    const e = C3.IsWhitespaceChar(l);
                    if (e === i) {
                        const e = r[r.length - 1];
                        e.styles === _ ? e.text += l : r.push({
                            text: l,
                            styles: _
                        })
                    } else
                        n.push(r),
                        r = [],
                        r.push({
                            text: l,
                            styles: _
                        }),
                        i = e
                }
        }
        return 0 < r.length && n.push(r),
        n
    }
    _CopyLine(e) {
        return e.map(e=>({
            text: e.text,
            styles: e.styles,
            width: e.width,
            height: e.height
        }))
    }
    _AddWordToLine(e, t) {
        const a = e.length ? e[e.length - 1] : null;
        let n = 0;
        a && t[0].styles === a.styles && (a.text += t[0].text,
        a.width = -1,
        a.height = -1,
        n = 1);
        for (let a = t.length; n < a; ++n) {
            const a = t[n];
            e.push({
                text: a.text,
                styles: a.styles,
                width: -1,
                height: -1
            })
        }
    }
    _WrapText(t, n, r, a) {
        let l = []
          , _ = 0
          , u = 0;
        for (const e of t) {
            if (1 === e.length && '\n' === e[0].text) {
                0 === u && (u = n(' ', e[0].styles).height),
                this._AddLine(l, _, u),
                l = [],
                _ = 0,
                u = 0;
                continue
            }
            const t = this._CopyLine(l);
            this._AddWordToLine(t, e);
            const a = this._MeasureLine(t, n)
              , d = a.width
              , i = a.height;
            if (!(d >= r))
                l = t,
                _ = d,
                u = i;
            else if (0 < l.length && this._AddLine(l, _, u),
            l = [],
            C3.IsStringAllWhitespace(e[0].text))
                _ = 0,
                u = 0;
            else {
                this._AddWordToLine(l, e);
                const t = this._MeasureLine(l, n);
                _ = t.width,
                u = t.height
            }
        }
        0 < l.length && this._AddLine(l, _, u),
        this._TrimLinesTrailingWhitespace(n, a)
    }
    _TrimLinesTrailingWhitespace(t, a) {
        for (const n of this._lines) {
            const r = n.fragments;
            if (!r.length)
                continue;
            let i = r[r.length - 1];
            const e = i.text
              , l = e.trimEnd();
            if (!l)
                n.width -= i.width,
                r.pop();
            else if (l.length < e.length) {
                const e = t(l, i.styles).width
                  , a = i.width - e;
                i.width = e,
                i.text = l,
                n.width -= a
            }
            0 !== a && 0 < r.length && (i = r[r.length - 1],
            i.width += a,
            n.width += a)
        }
    }
    Clear() {
        C3.clearArray(this._lines)
    }
    GetMaxLineWidth() {
        let e = 0;
        for (const t of this._lines) {
            const a = t.width;
            e < a && (e = a)
        }
        return e
    }
}
,
'use strict',
C3.Gfx = {},
'use strict';
{
    const t = [0, 0, 0, 0, 0, 0, 0, 0]
      , e = vec3.fromValues(0, 0, 0);
    C3.Gfx.RendererBase = class {
        constructor() {
            this._width = 0,
            this._height = 0,
            this._cam = vec3.fromValues(0, 0, 100),
            this._look = vec3.fromValues(0, 0, 0),
            this._up = vec3.fromValues(0, 1, 0),
            this._worldScale = vec3.fromValues(1, 1, 1),
            this._matP = mat4.create(),
            this._matMV = mat4.create(),
            this._lastMV = mat4.create(),
            this._allShaderPrograms = [],
            this._shaderProgramsByName = new Map,
            this._spTextureFill = null,
            this._stateGroups = new Map,
            this._currentStateGroup = null,
            this._blendModeTable = [],
            this._namedBlendModeMap = new Map,
            this._frameNumber = 0
        }
        FillIndexBufferData(e) {
            for (let t = 0, a = e.length, n = 0; t < a; )
                e[t++] = n,
                e[t++] = n + 1,
                e[t++] = n + 2,
                e[t++] = n,
                e[t++] = n + 2,
                e[t++] = n + 3,
                n += 4
        }
        Project(a, n, r, i, e) {
            const l = this._matMV
              , _ = this._matP;
            for (let l = 0, _ = t.length; l < _; ++l)
                t[l] = 0;
            t[0] = l[0] * a + l[4] * n + l[12],
            t[1] = l[1] * a + l[5] * n + l[13],
            t[2] = l[2] * a + l[6] * n + l[14],
            t[3] = l[3] * a + l[7] * n + l[15],
            t[4] = _[0] * t[0] + _[4] * t[1] + _[8] * t[2] + _[12] * t[3],
            t[5] = _[1] * t[0] + _[5] * t[1] + _[9] * t[2] + _[13] * t[3],
            t[6] = _[2] * t[0] + _[6] * t[1] + _[10] * t[2] + _[14] * t[3],
            t[7] = -t[2],
            0 === t[7] || (t[7] = 1 / t[7],
            t[4] *= t[7],
            t[5] *= t[7],
            t[6] *= t[7],
            e[0] = (.5 * t[4] + .5) * r,
            e[1] = (.5 * t[5] + .5) * i)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetNearZ() {
            return 1
        }
        GetFarZ() {
            return 1e4
        }
        SetCameraXYZ(e, t, a) {
            this._cam[0] = e * this._worldScale[0],
            this._cam[1] = t * this._worldScale[1],
            this._cam[2] = a
        }
        SetLookXYZ(e, t, a) {
            this._look[0] = e * this._worldScale[0],
            this._look[1] = t * this._worldScale[1],
            this._look[2] = a
        }
        ResetModelView(e) {
            mat4.lookAt(this._matMV, this._cam, this._look, e || this._up),
            mat4.scale(this._matMV, this._matMV, this._worldScale)
        }
        Translate(t, a) {
            0 === t && 0 === a || (e[0] = t,
            e[1] = a,
            e[2] = 0,
            mat4.translate(this._matMV, this._matMV, e))
        }
        Scale(t, a) {
            1 === t && 1 === a || (e[0] = t,
            e[1] = a,
            e[2] = 1,
            mat4.scale(this._matMV, this._matMV, e))
        }
        RotateZ(e) {
            0 === e || mat4.rotateZ(this._matMV, this._matMV, e)
        }
        _AddShaderProgram(e) {
            this._allShaderPrograms.push(e),
            this._shaderProgramsByName.set(e.GetName(), e)
        }
        _RemoveShaderProgram(e) {
            const t = this._allShaderPrograms.indexOf(e);
            -1 !== t && this._allShaderPrograms.splice(t, 1),
            this._shaderProgramsByName.delete(e.GetName())
        }
        _ClearAllShaderPrograms() {
            C3.clearArray(this._allShaderPrograms),
            this._shaderProgramsByName.clear()
        }
        GetShaderProgramByName(e) {
            return this._shaderProgramsByName.get(e) || null
        }
        GetTextureFillShaderProgram() {
            return this._spTextureFill
        }
        _SetCurrentStateGroup(e) {
            this._currentStateGroup = e
        }
        GetCurrentStateGroup() {
            return this._currentStateGroup
        }
        AcquireStateGroup(t, a, n, r, i) {
            const e = C3.Gfx.StateGroup.MakeKey(t, a, n, r, i);
            let l = this._stateGroups.get(e);
            return l || (l = C3.New(C3.Gfx.StateGroup, this, t, a, n, r, i),
            this._stateGroups.set(e, l)),
            l.AddRef(),
            l
        }
        ReleaseStateGroup(e) {
            e.DecRef(),
            0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null),
            this._stateGroups.delete(e.GetKey()),
            e.Release())
        }
        _InitBlendModeData(e) {
            C3.clearArray(this._blendModeTable),
            this._namedBlendModeMap.clear();
            for (const t of e) {
                const e = t[0]
                  , a = t[1]
                  , n = t[2];
                this._blendModeTable.push([a, n]),
                this._namedBlendModeMap.set(e, {
                    srcBlend: a,
                    destBlend: n
                })
            }
        }
        _GetBlendByIndex(e) {
            const t = this._blendModeTable;
            if (0 > e || e >= t.length)
                throw new RangeError('invalid blend index');
            return t[e]
        }
        GetSrcBlendByIndex(e) {
            return this._GetBlendByIndex(e)[0]
        }
        GetDestBlendByIndex(e) {
            return this._GetBlendByIndex(e)[1]
        }
        GetNamedBlend(e) {
            const t = this._namedBlendModeMap.get(e);
            if ('undefined' == typeof t)
                throw new Error('invalid blend name');
            return t
        }
        Finish() {
            this.EndBatch(),
            this._frameNumber++
        }
        GetFrameNumber() {
            return this._frameNumber
        }
        IncrementFrameNumber() {
            this._frameNumber++
        }
    }
}
'use strict',
C3.Gfx.StateGroup = class {
    constructor(t, a, n, r, i, e) {
        this._renderer = t,
        this._refCount = 0,
        this._shaderProgram = null,
        this._shaderProgramName = '',
        this._srcBlend = n,
        this._destBlend = r,
        this._color = C3.New(C3.Color),
        this._color.set(i),
        this._zElevation = e,
        'string' == typeof a ? this._shaderProgramName = a : (this._shaderProgram = a,
        this._shaderProgramName = this._shaderProgram.GetName())
    }
    Release() {
        if (0 < this._refCount)
            throw new Error('releasing state group still in use');
        this._renderer = null,
        this._shaderProgram = null,
        this._shaderProgramName = ''
    }
    Apply() {
        const e = this._renderer;
        e.SetProgram(this._shaderProgram),
        e.SetBlend(this._srcBlend, this._destBlend),
        e.SetColor(this._color),
        e.SetCurrentZ(this._zElevation),
        e._SetCurrentStateGroup(this)
    }
    GetKey() {
        return C3.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._srcBlend, this._destBlend, this._color, this._zElevation)
    }
    AddRef() {
        ++this._refCount
    }
    DecRef() {
        --this._refCount
    }
    _GetRefCount() {
        return this._refCount
    }
    OnContextLost() {
        this._shaderProgram = null
    }
    OnContextRestored(e) {
        if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName),
        !this._shaderProgram)
            throw new Error('failed to restore shader program')
    }
    static MakeKey(t, a, n, r, e) {
        const i = 'string' == typeof t ? t : t.GetName();
        return i + ',' + a + ',' + n + ',' + r.getR() + ',' + r.getG() + ',' + r.getB() + ',' + r.getA() + ',' + e
    }
}
,
'use strict';
{
    function t(t, a) {
        let n, r, i, l;
        switch (t) {
        case 'rgba8':
            n = a.RGBA8,
            r = a.RGBA,
            i = a.RGBA,
            l = a.UNSIGNED_BYTE;
            break;
        case 'rgb8':
            n = a.RGB8,
            r = a.RGB,
            i = a.RGB,
            l = a.UNSIGNED_BYTE;
            break;
        case 'rgba4':
            n = a.RGBA4,
            r = a.RGBA,
            i = a.RGBA,
            l = a.UNSIGNED_SHORT_4_4_4_4;
            break;
        case 'rgb5_a1':
            n = a.RGB5_A1,
            r = a.RGBA,
            i = a.RGBA,
            l = a.UNSIGNED_SHORT_5_5_5_1;
            break;
        case 'rgb565':
            n = a.RGB565,
            r = a.RGB,
            i = a.RGB,
            l = a.UNSIGNED_SHORT_5_6_5;
            break;
        default:
            throw new Error('invalid pixel format');
        }
        return {
            sizedinternalformat: n,
            internalformat: r,
            format: i,
            type: l
        }
    }
    const a = new Set(['rgba8', 'rgb8', 'rgba4', 'rgb5_a1', 'rgb565'])
      , r = new Set(['nearest', 'bilinear', 'trilinear'])
      , _ = new Set(['default', 'low', 'high'])
      , d = {
        isTiled: !1,
        tileType: 'repeat',
        sampling: 'trilinear',
        pixelFormat: 'rgba8',
        mipMap: !0,
        mipMapQuality: 'default',
        premultiplyAlpha: !0,
        isSvg: !1,
        width: -1,
        height: -1
    }
      , n = {
        premultiplyAlpha: !0
    }
      , e = new Set;
    C3.Gfx.WebGLRendererTexture = class {
        constructor(e) {
            this._renderer = e,
            this._texture = null,
            this._width = 0,
            this._height = 0,
            this._isStatic = !0,
            this._isTiled = !1,
            this._tileType = 'repeat',
            this._sampling = 'trilinear',
            this._pixelFormat = 'rgba8',
            this._isMipMapped = !1,
            this._mipMapQuality = 'default',
            this._refCount = 0
        }
        _CreateStatic(n, u) {
            if (('undefined' == typeof HTMLImageElement || !(n instanceof HTMLImageElement)) && ('undefined' == typeof HTMLCanvasElement || !(n instanceof HTMLCanvasElement)) && ('undefined' == typeof ImageBitmap || !(n instanceof ImageBitmap)) && ('undefined' == typeof OffscreenCanvas || !(n instanceof OffscreenCanvas)) && !(n instanceof ImageData) && !(n instanceof ArrayBuffer) && null !== n)
                throw new Error('invalid texture source');
            if (u = Object.assign({}, d, u),
            this._texture)
                throw new Error('already created texture');
            if (this._isTiled = !!u.isTiled,
            this._tileType = u.tileType,
            this._sampling = u.sampling,
            this._pixelFormat = u.pixelFormat,
            this._isMipMapped = !!u.mipMap,
            this._mipMapQuality = u.mipMapQuality,
            !r.has(this._sampling))
                throw new Error('invalid sampling');
            if (!a.has(this._pixelFormat))
                throw new Error('invalid pixel format');
            if (!_.has(this._mipMapQuality))
                throw new Error('invalid mipmap quality');
            if (this._isStatic = !0,
            !(n instanceof ArrayBuffer || null === n || u.isSvg))
                this._width = n.width,
                this._height = n.height;
            else if (this._width = u.width,
            this._height = u.height,
            n instanceof ArrayBuffer && n.byteLength !== 4 * (this._width * this._height))
                throw new Error('ArrayBuffer wrong size');
            if (0 >= this._width || 0 >= this._height)
                throw new Error('invalid texture data size');
            if (u.isSvg) {
                const e = C3.CreateCanvas(this._width, this._height)
                  , t = e.getContext('2d');
                t.drawImage(n, 0, 0, this._width, this._height),
                n = e
            }
            const c = C3.isPOT(this._width) && C3.isPOT(this._height)
              , i = this._renderer.GetMaxTextureSize();
            if (this._width > i || this._height > i)
                throw new Error('texture data exceeds maximum texture size');
            const g = this._renderer.GetContext()
              , p = this._renderer.GetWebGLVersionNumber();
            this._texture = g.createTexture(),
            g.bindTexture(g.TEXTURE_2D, this._texture),
            g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, u.premultiplyAlpha);
            const l = t(this._pixelFormat, g);
            if (!this._renderer.SupportsNPOTTextures() && !c && this._isTiled) {
                if (null === n)
                    throw new Error('cannot pass null data when creating a NPOT tiled texture without NPOT support');
				
                if (n instanceof ArrayBuffer && (n = new ImageData(new Uint8ClampedArray(n),this._width,this._height)), n instanceof ImageData) {
                    const e = C3.CreateCanvas(this._width, this._height)
                      , t = e.getContext('2d');
                    t.putImageData(n, 0, 0),
                    n = e
                }
				
                const e = C3.CreateCanvas(C3.nextHighestPowerOfTwo(this._width), C3.nextHighestPowerOfTwo(this._height))
                  , t = e.getContext('2d');
                t.imageSmoothingEnabled = 'nearest' !== this._sampling,
                t.drawImage(n, 0, 0, this._width, this._height, 0, 0, e.width, e.height),
                g.texImage2D(g.TEXTURE_2D, 0, l.internalformat, l.format, l.type, e);
            } else if (2 <= p) {
                let e;
                e = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1,
                g.texStorage2D(g.TEXTURE_2D, e, l.sizedinternalformat, this._width, this._height),
                n instanceof ArrayBuffer ? g.texSubImage2D(g.TEXTURE_2D, 0, 0, 0, this._width, this._height, l.format, l.type, new Uint8Array(n)) : null !== n && g.texSubImage2D(g.TEXTURE_2D, 0, 0, 0, l.format, l.type, n);
            } else {
                n instanceof ArrayBuffer ? g.texImage2D(g.TEXTURE_2D, 0, l.internalformat, this._width, this._height, 0, l.format, l.type, new Uint8Array(n)) : null === n ? g.texImage2D(g.TEXTURE_2D, 0, l.internalformat, this._width, this._height, 0, l.format, l.type, null) : g.texImage2D(g.TEXTURE_2D, 0, l.internalformat, l.format, l.type, n);
			}
            null !== n && this._SetTextureParameters(g),
            g.bindTexture(g.TEXTURE_2D, null),
            this._renderer._ResetLastTexture(),
            this._refCount = 1,
            e.add(this)
        }
        _CreateDynamic(u, c, g) {
            var h = Math.floor;
            if (g = Object.assign({}, d, g),
            this._texture)
                throw new Error('already created texture');
            if (this._isTiled = !!g.isTiled,
            this._tileType = g.tileType,
            this._sampling = g.sampling,
            this._pixelFormat = g.pixelFormat,
            this._isMipMapped = !!g.mipMap,
            this._mipMapQuality = g.mipMapQuality,
            !r.has(this._sampling))
                throw new Error('invalid sampling');
            if (!a.has(this._pixelFormat))
                throw new Error('invalid pixel format');
            if (!_.has(this._mipMapQuality))
                throw new Error('invalid mipmap quality');
            this._isStatic = !1,
            this._width = h(u),
            this._height = h(c);
            const f = C3.isPOT(this._width) && C3.isPOT(this._height)
              , S = this._renderer.GetMaxTextureSize();
            if (0 >= this._width || 0 >= this._height)
                throw new Error('invalid texture size');
            if (this._width > S || this._height > S)
                throw new Error('texture exceeds maximum texture size');
            if (!this._renderer.SupportsNPOTTextures() && this._isTiled && !f)
                throw new Error('non-power-of-two tiled textures not supported');
            const l = this._renderer.GetContext()
              , m = this._renderer.GetWebGLVersionNumber();
            this._texture = l.createTexture(),
            l.bindTexture(l.TEXTURE_2D, this._texture),
            l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, g.premultiplyAlpha);
            const n = t(this._pixelFormat, l)
              , y = 2 <= m ? n.sizedinternalformat : n.internalformat;
            l.texImage2D(l.TEXTURE_2D, 0, y, this._width, this._height, 0, n.format, n.type, null),
            this._SetTextureParameters(l),
            l.bindTexture(l.TEXTURE_2D, null),
            this._renderer._ResetLastTexture(),
            this._refCount = 1,
            e.add(this)
        }
        _GetMipMapHint(e) {
            if ('default' === this._mipMapQuality)
                return this._isStatic ? e.NICEST : e.FASTEST;
            if ('low' === this._mipMapQuality)
                return e.FASTEST;
            if ('high' === this._mipMapQuality)
                return e.NICEST;
            throw new Error('invalid mipmap quality')
        }
        _SetTextureParameters(e) {
            const t = C3.isPOT(this._width) && C3.isPOT(this._height);
            if (!this._isTiled)
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
            else if ('repeat-x' === this._tileType)
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
            else if ('repeat-y' === this._tileType)
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT);
            else if ('repeat' === this._tileType)
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT);
            else
                throw new Error('invalid tile type');
            if ('nearest' === this._sampling)
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                this._isMipMapped = !1;
            else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
                e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)),
                e.generateMipmap(e.TEXTURE_2D);
                const t = 'trilinear' === this._sampling && !this._renderer.HasMajorPerformanceCaveat();
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST)
            } else
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
                this._isMipMapped = !1
        }
        _Update(r, a) {
            if (('undefined' == typeof HTMLImageElement || !(r instanceof HTMLImageElement)) && ('undefined' == typeof HTMLVideoElement || !(r instanceof HTMLVideoElement)) && ('undefined' == typeof HTMLCanvasElement || !(r instanceof HTMLCanvasElement)) && ('undefined' == typeof ImageBitmap || !(r instanceof ImageBitmap)) && ('undefined' == typeof OffscreenCanvas || !(r instanceof OffscreenCanvas)) && !(r instanceof ImageData))
                throw new Error('invalid texture source');
            if (!this._texture || 0 >= this._refCount)
                throw new Error('texture not created');
            if (this._isStatic)
                throw new Error('cannot update static texture');
            a = Object.assign({}, n, a);
            const l = r.width || r.videoWidth
              , _ = r.height || r.videoHeight
              , e = this._renderer.GetWebGLVersionNumber()
              , d = this._renderer.GetContext();
            d.bindTexture(d.TEXTURE_2D, this._texture),
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
            const u = t(this._pixelFormat, d)
              , i = 2 <= e ? u.sizedinternalformat : u.internalformat;
            try {
                if (this._width === l && this._height === _) {
                    const e = C3.isPOT(this._width) && C3.isPOT(this._height);
                    d.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, u.format, u.type, r),
                    (e || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (d.hint(d.GENERATE_MIPMAP_HINT, this._GetMipMapHint(d)),
                    d.generateMipmap(d.TEXTURE_2D))
                } else {
                    this._width = l,
                    this._height = _;
                    const e = C3.isPOT(this._width) && C3.isPOT(this._height);
                    if (!this._renderer.SupportsNPOTTextures() && this._isTiled && !e)
                        throw new Error('non-power-of-two tiled textures not supported');
                    d.texImage2D(d.TEXTURE_2D, 0, i, u.format, u.type, r),
                    (e || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (d.hint(d.GENERATE_MIPMAP_HINT, this._GetMipMapHint(d)),
                    d.generateMipmap(d.TEXTURE_2D))
                }
            } catch (e) {
                console.error('Error updating WebGL texture: ', e)
            }
            d.bindTexture(d.TEXTURE_2D, null),
            this._renderer._ResetLastTexture()
        }
        _Delete() {
            if (0 < this._refCount)
                throw new Error('texture still has references');
            if (!this._texture)
                throw new Error('already deleted texture');
            e.delete(this);
            const t = this._renderer.GetContext();
            t.deleteTexture(this._texture),
            this._texture = null
        }
        IsValid() {
            return !!this._texture
        }
        _GetTexture() {
            return this._texture
        }
        GetRenderer() {
            return this._renderer
        }
        AddReference() {
            this._refCount++
        }
        SubtractReference() {
            if (0 >= this._refCount)
                throw new Error('no more references');
            this._refCount--
        }
        GetReferenceCount() {
            return this._refCount
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsStatic() {
            return this._isStatic
        }
        GetEstimatedMemoryUsage() {
            let e = this._width * this._height;
            switch (this._pixelFormat) {
            case 'rgba8':
                e *= 4;
                break;
            case 'rgb8':
                e *= 3;
                break;
            case 'rgba4':
            case 'rgb5_a1':
            case 'rgb565':
                e *= 2;
            }
            return this._isMipMapped && (e += Math.floor(e / 3)),
            e
        }
        static OnContextLost() {
            e.clear()
        }
        static allTextures() {
            return e.values()
        }
    }
}
{
    const t = new Set(['nearest', 'bilinear', 'trilinear'])
      , n = {
        sampling: 'trilinear',
        alpha: !0,
        readback: !0,
        isDefaultSize: !0,
        multisampling: 0
    }
      , r = new Set;
    C3.Gfx.WebGLRenderTarget = class {
        constructor(e) {
            this._renderer = e,
            this._frameBuffer = null,
            this._texture = null,
            this._renderBuffer = null,
            this._width = 0,
            this._height = 0,
            this._isDefaultSize = !0,
            this._sampling = 'trilinear',
            this._alpha = !0,
            this._readback = !0,
            this._multisampling = 0
        }
        _Create(a, i, e) {
            e = Object.assign({}, n, e);
            const l = this._renderer.GetWebGLVersionNumber();
            if (this._texture || this._renderBuffer)
                throw new Error('already created render target');
            if (this._sampling = e.sampling,
            this._alpha = !!e.alpha,
            this._readback = !!e.readback,
            this._isDefaultSize = !!e.isDefaultSize,
            this._multisampling = e.multisampling,
            !t.has(this._sampling))
                throw new Error('invalid sampling');
            if (0 < this._multisampling && (2 > l || this._readback))
                throw new Error('invalid use of multisampling');
            if (2 > l && (this._readback = !0),
            this._width = a,
            this._height = i,
            0 >= this._width || 0 >= this._height)
                throw new Error('invalid render target size');
            const _ = this._renderer.GetContext();
            if (this._frameBuffer = _.createFramebuffer(),
            _.bindFramebuffer(_.FRAMEBUFFER, this._frameBuffer),
            this._readback) {
                this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
                    sampling: this._sampling,
                    pixelFormat: this._alpha ? 'rgba8' : 'rgb8',
                    mipMap: !1
                });
                const e = this._texture._GetTexture();
                _.framebufferTexture2D(_.FRAMEBUFFER, _.COLOR_ATTACHMENT0, _.TEXTURE_2D, e, 0)
            } else {
                this._renderBuffer = _.createRenderbuffer(),
                _.bindRenderbuffer(_.RENDERBUFFER, this._renderBuffer);
                const e = this._alpha ? _.RGBA8 : _.RGB8;
                if (0 < this._multisampling) {
                    const t = _.getInternalformatParameter(_.RENDERBUFFER, e, _.SAMPLES);
                    if (t && t[0]) {
                        const e = t[0];
                        this._multisampling > e && (this._multisampling = e)
                    } else
                        this._multisampling = 0
                }
                0 === this._multisampling ? _.renderbufferStorage(_.RENDERBUFFER, e, this._width, this._height) : _.renderbufferStorageMultisample(_.RENDERBUFFER, this._multisampling, e, this._width, this._height),
                _.framebufferRenderbuffer(_.FRAMEBUFFER, _.COLOR_ATTACHMENT0, _.RENDERBUFFER, this._renderBuffer),
                _.bindRenderbuffer(_.RENDERBUFFER, null)
            }
            _.bindFramebuffer(_.FRAMEBUFFER, null),
            r.add(this)
        }
        _Resize(e, t) {
            if (this._width !== e || this._height !== t) {
                this._width = e,
                this._height = t;
                const a = this._renderer.GetContext();
                a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
                this._texture ? this._texture._Update(new ImageData(this._width,this._height)) : (a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer),
                a.renderbufferStorage(a.RENDERBUFFER, this._alpha ? a.RGBA8 : a.RGB8, this._width, this._height),
                a.bindRenderbuffer(a.RENDERBUFFER, null)),
                a.bindFramebuffer(a.FRAMEBUFFER, null)
            }
        }
        _Delete() {
            if (!this._texture && !this._renderBuffer)
                throw new Error('already deleted render target');
            r.delete(this);
            const e = this._renderer.GetContext();
            e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer),
            this._texture ? (e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0),
            this._renderer.DeleteTexture(this._texture),
            this._texture = null) : this._renderBuffer && (e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null),
            e.deleteRenderbuffer(this._renderBuffer),
            this._renderBuffer = null),
            e.bindFramebuffer(e.FRAMEBUFFER, null),
            2 <= this._renderer.GetWebGLVersionNumber() && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)),
            e.deleteFramebuffer(this._frameBuffer),
            this._renderer.GetBatchState().currentFramebuffer = null,
            this._frameBuffer = null
        }
        _GetFramebuffer() {
            return this._frameBuffer
        }
        GetWebGLRenderer() {
            return this._renderer
        }
        GetTexture() {
            return this._texture
        }
        IsLinearSampling() {
            return 'nearest' !== this._sampling
        }
        HasAlpha() {
            return this._alpha
        }
        IsReadback() {
            return this._readback
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsDefaultSize() {
            return this._isDefaultSize
        }
        GetMultisampling() {
            return this._multisampling
        }
        GetOptions() {
            const e = {
                sampling: this._sampling,
                alpha: this._alpha,
                readback: this._readback
            };
            return this._isDefaultSize || (e.width = this._width,
            e.height = this._height),
            e
        }
        IsCompatibleWithOptions(e) {
            return e = Object.assign({}, n, e),
            'nearest' !== e.sampling === this.IsLinearSampling() && !!e.alpha === this.HasAlpha() && !(2 <= this._renderer.GetWebGLVersionNumber() && !!e.readback !== this.IsReadback()) && ('number' == typeof e.width || 'number' == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === e.width && this.GetHeight() === e.height : this.IsDefaultSize())
        }
        _GetWebGLTexture() {
            return this._texture ? this._texture._GetTexture() : null
        }
        GetEstimatedMemoryUsage() {
            return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
        }
        static async DebugReadPixelsToBlob(e, t) {
            const a = await e.ReadBackRenderTargetToImageData(t, !0);
            return await C3.ImageDataToBlob(a)
        }
        static OnContextLost() {
            r.clear()
        }
        static allRenderTargets() {
            return r.values()
        }
        static ResizeAll(e, t) {
            for (const a of r)
                a.IsDefaultSize() && a._Resize(e, t)
        }
    }
}
{
    const e = new Set(['aPos', 'aTex', 'aPoints', 'matP', 'matMV', 'samplerFront', 'samplerBack', 'destStart', 'destEnd', 'srcStart', 'srcEnd', 'srcOriginStart', 'srcOriginEnd', 'pixelSize', 'seconds', 'layerScale', 'layerAngle', 'layoutStart', 'layoutEnd', 'color', 'color2_', 'pointTexStart', 'pointTexEnd', 'zElevation', 'tileSize', 'tileSpacing', 'outlineThickness']);
    C3.Gfx.WebGLShaderProgram = class {
        static async Compile(t, a, n, r) {
            const l = t.GetContext()
              , e = l.createShader(l.FRAGMENT_SHADER);
            l.shaderSource(e, a),
            l.compileShader(e);
            const _ = l.createShader(l.VERTEX_SHADER);
            l.shaderSource(_, n),
            l.compileShader(_);
            const d = l.createProgram();
            l.attachShader(d, e),
            l.attachShader(d, _),
            l.bindAttribLocation(d, 0, 'aPos'),
            l.bindAttribLocation(d, 1, 'aTex'),
            l.bindAttribLocation(d, 2, 'aPoints'),
            l.linkProgram(d);
            const u = t._GetParallelShaderCompileExtension();
            if (u ? await t._WaitForObjectReady(()=>l.getProgramParameter(d, u.COMPLETION_STATUS_KHR)) : await C3.Wait(5),
            !l.getShaderParameter(e, l.COMPILE_STATUS)) {
                const t = l.getShaderInfoLog(e);
                throw l.deleteShader(e),
                l.deleteShader(_),
                l.deleteProgram(d),
                new Error('Error compiling fragment shader: ' + t)
            }
            if (!l.getShaderParameter(_, l.COMPILE_STATUS)) {
                const t = l.getShaderInfoLog(_);
                throw l.deleteShader(e),
                l.deleteShader(_),
                l.deleteProgram(d),
                new Error('Error compiling vertex shader: ' + t)
            }
            if (!l.getProgramParameter(d, l.LINK_STATUS)) {
                const t = l.getProgramInfoLog(d);
                throw l.deleteShader(e),
                l.deleteShader(_),
                l.deleteProgram(d),
                new Error('Error linking shader program: ' + t)
            }
            const i = C3.FilterUnprintableChars(l.getProgramInfoLog(d) || '').trim();
            return i && !C3.IsStringAllWhitespace(i) && console.info(`[WebGL] Shader program '${r}' compilation log: `, i),
            l.deleteShader(e),
            l.deleteShader(_),
            d
        }
        static async Create(t, a, n, r) {
            const i = await C3.Gfx.WebGLShaderProgram.Compile(t, a.src, n, r);
            return new C3.Gfx.WebGLShaderProgram(t,i,a,r)
        }
        constructor(t, a, n, r) {
            const l = t.GetContext()
              , e = t.GetBatchState();
            t.EndBatch(),
            l.useProgram(a),
            this._gl = l,
            this._renderer = t,
            this._name = r,
            this._shaderProgram = a,
            this._isDeviceTransform = '<default-device-transform>' === r;
            const _ = l.getAttribLocation(a, 'aPos')
              , d = l.getAttribLocation(a, 'aTex')
              , u = l.getAttribLocation(a, 'aPoints');
            -1 !== _ && (l.bindBuffer(l.ARRAY_BUFFER, t._vertexBuffer),
            l.vertexAttribPointer(_, t.GetNumVertexComponents(), l.FLOAT, !1, 0, 0),
            l.enableVertexAttribArray(_)),
            -1 !== d && (l.bindBuffer(l.ARRAY_BUFFER, t._texcoordBuffer),
            l.vertexAttribPointer(d, 2, l.FLOAT, !1, 0, 0),
            l.enableVertexAttribArray(d)),
            -1 !== u && (l.bindBuffer(l.ARRAY_BUFFER, t._pointBuffer),
            l.vertexAttribPointer(u, 4, l.FLOAT, !1, 0, 0),
            l.enableVertexAttribArray(u)),
            l.bindBuffer(l.ARRAY_BUFFER, null),
            this._uMatP = new C3.Gfx.WebGLShaderUniform(this,'matP','mat4'),
            this._uMatMV = new C3.Gfx.WebGLShaderUniform(this,'matMV','mat4'),
            this._uColor = new C3.Gfx.WebGLShaderUniform(this,'color','vec4'),
            this._uSamplerFront = new C3.Gfx.WebGLShaderUniform(this,'samplerFront','sampler'),
            this._uPointTexStart = new C3.Gfx.WebGLShaderUniform(this,'pointTexStart','vec2'),
            this._uPointTexEnd = new C3.Gfx.WebGLShaderUniform(this,'pointTexEnd','vec2'),
            this._uZElevation = new C3.Gfx.WebGLShaderUniform(this,'zElevation','float'),
            this._uTileSize = new C3.Gfx.WebGLShaderUniform(this,'tileSize','vec2'),
            this._uTileSpacing = new C3.Gfx.WebGLShaderUniform(this,'tileSpacing','vec2'),
            this._uColor2 = new C3.Gfx.WebGLShaderUniform(this,'color2_','vec4'),
            this._uOutlineThickness = new C3.Gfx.WebGLShaderUniform(this,'outlineThickness','float'),
            this._uSamplerBack = new C3.Gfx.WebGLShaderUniform(this,'samplerBack','sampler'),
            this._uDestStart = new C3.Gfx.WebGLShaderUniform(this,'destStart','vec2'),
            this._uDestEnd = new C3.Gfx.WebGLShaderUniform(this,'destEnd','vec2'),
            this._uSrcStart = new C3.Gfx.WebGLShaderUniform(this,'srcStart','vec2'),
            this._uSrcEnd = new C3.Gfx.WebGLShaderUniform(this,'srcEnd','vec2'),
            this._uSrcOriginStart = new C3.Gfx.WebGLShaderUniform(this,'srcOriginStart','vec2'),
            this._uSrcOriginEnd = new C3.Gfx.WebGLShaderUniform(this,'srcOriginEnd','vec2'),
            this._uPixelSize = new C3.Gfx.WebGLShaderUniform(this,'pixelSize','vec2'),
            this._uSeconds = new C3.Gfx.WebGLShaderUniform(this,'seconds','float'),
            this._uLayerScale = new C3.Gfx.WebGLShaderUniform(this,'layerScale','float'),
            this._uLayerAngle = new C3.Gfx.WebGLShaderUniform(this,'layerAngle','float'),
            this._uLayoutStart = new C3.Gfx.WebGLShaderUniform(this,'layoutStart','vec2'),
            this._uLayoutEnd = new C3.Gfx.WebGLShaderUniform(this,'layoutEnd','vec2'),
            this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed()),
            this._extendBoxHorizontal = n.extendBoxHorizontal || 0,
            this._extendBoxVertical = n.extendBoxVertical || 0,
            this._crossSampling = !!n.crossSampling,
            this._mustPreDraw = !!n.mustPreDraw,
            this._preservesOpaqueness = !!n.preservesOpaqueness,
            this._animated = !!n.animated;
            const i = n.parameters || [];
            this._uCustomParameters = [],
            this._usesDest = this._uDestStart.IsUsed() || this._uDestEnd.IsUsed(),
            this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(),
            this._needsPostDrawOrExtendBox = this._crossSampling || this._usesDest || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical,
            this._hasCurrentMatP = !1,
            this._hasCurrentMatMV = !1,
            this._uColor.Init4f(1, 1, 1, 1),
            this._uColor2.Init4f(1, 1, 1, 1),
            this._uSamplerFront.Init1i(0),
            this._uSamplerBack.Init1i(1),
            this._uPointTexStart.Init2f(0, 0),
            this._uPointTexEnd.Init2f(1, 1),
            this._uZElevation.Init1f(0),
            this._uTileSize.Init2f(0, 0),
            this._uTileSpacing.Init2f(0, 0),
            this._uDestStart.Init2f(0, 0),
            this._uDestEnd.Init2f(1, 1),
            this._uSrcStart.Init2f(0, 0),
            this._uSrcEnd.Init2f(0, 0),
            this._uSrcOriginStart.Init2f(0, 0),
            this._uSrcOriginEnd.Init2f(0, 0),
            this._uPixelSize.Init2f(0, 0),
            this._uLayerScale.Init1f(1),
            this._uLayerAngle.Init1f(0),
            this._uSeconds.Init1f(0),
            this._uLayoutStart.Init2f(0, 0),
            this._uLayoutEnd.Init2f(0, 0),
            this._uOutlineThickness.Init1f(1);
            for (const l of i) {
                const e = l[0]
                  , t = l[2]
                  , a = new C3.Gfx.WebGLShaderUniform(this,e,t);
                'color' === t ? a.Init3f(0, 0, 0) : a.Init1f(0),
                this._uCustomParameters.push(a)
            }
            this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(e.currentMatP) : (this.UpdateMatP(e.currentMatP, !0),
            this.UpdateMatMV(e.currentMV, !0));
            const c = e.currentShader;
            l.useProgram(c ? c._shaderProgram : null)
        }
        Release() {
            this._gl.deleteProgram(this._shaderProgram),
            this._shaderProgram = null,
            this._renderer._RemoveShaderProgram(this),
            this._gl = null,
            this._renderer = null
        }
        GetName() {
            return this._name
        }
        GetWebGLContext() {
            return this._gl
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        UsesDest() {
            return this._usesDest
        }
        UsesCrossSampling() {
            return this._crossSampling
        }
        MustPreDraw() {
            return this._mustPreDraw
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        ExtendsBox() {
            return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
        }
        GetBoxExtendHorizontal() {
            return this._extendBoxHorizontal
        }
        GetBoxExtendVertical() {
            return this._extendBoxVertical
        }
        UsesAnySrcRectOrPixelSize() {
            return this._usesAnySrcRectOrPixelSize
        }
        NeedsPostDrawOrExtendsBox() {
            return this._needsPostDrawOrExtendBox
        }
        GetParameterCount() {
            return this._uCustomParameters.length
        }
        GetParameterType(e) {
            return this._uCustomParameters[e].GetType()
        }
        AreCustomParametersAlreadySetInBatch(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                if (!this._uCustomParameters[t].IsSetToCustomInBatch(e[t]))
                    return !1;
            return !0
        }
        SetCustomParametersInBatch(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                this._uCustomParameters[t].SetBatchValueCustom(e[t])
        }
        AreOptionalUniformsAlreadySetInBatch(t, a, n, r, l, e, _, d, u) {
            return !this._uSamplerBack.IsUsed() && (!this._uPixelSize.IsUsed() || this._uPixelSize.IsSetTo2InBatch(l, e)) && (!this._uDestStart.IsUsed() || this._uDestStart.IsSetTo2InBatch(t.getLeft(), t.getTop())) && (!this._uDestEnd.IsUsed() || this._uDestEnd.IsSetTo2InBatch(t.getRight(), t.getBottom())) && (!this._uLayerScale.IsUsed() || this._uLayerScale.IsSetTo1InBatch(_)) && (!this._uLayerAngle.IsUsed() || this._uLayerAngle.IsSetTo1InBatch(d)) && (!this._uSrcStart.IsUsed() || this._uSrcStart.IsSetTo2InBatch(a.getLeft(), a.getTop())) && (!this._uSrcEnd.IsUsed() || this._uSrcEnd.IsSetTo2InBatch(a.getRight(), a.getBottom())) && (!this._uSrcOriginStart.IsUsed() || this._uSrcOriginStart.IsSetTo2InBatch(n.getLeft(), n.getTop())) && (!this._uSrcOriginEnd.IsUsed() || this._uSrcOriginEnd.IsSetTo2InBatch(n.getRight(), n.getBottom())) && (!this._uLayoutStart.IsUsed() || this._uLayoutStart.IsSetTo2InBatch(r.getLeft(), r.getTop())) && (!this._uLayoutEnd.IsUsed() || this._uLayoutEnd.IsSetTo2InBatch(r.getTop(), r.getBottom())) && (!this._uSeconds.IsUsed() || this._uSeconds.IsSetTo1InBatch(u))
        }
        SetOptionalUniformsInBatch(t, a, n, r, l, e, _, d, u) {
            this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(l, e),
            this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(t.getLeft(), t.getTop()),
            this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(t.getRight(), t.getBottom()),
            this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(_),
            this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(d),
            this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(a.getLeft(), a.getTop()),
            this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(a.getRight(), a.getBottom()),
            this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(n.getLeft(), n.getTop()),
            this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(n.getRight(), n.getBottom()),
            this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r.getLeft(), r.getTop()),
            this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r.getTop(), r.getBottom()),
            this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(u))
        }
        IsAnimated() {
            return this._animated
        }
        UpdateMatP(e, t) {
            this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e),
            this._hasCurrentMatP = !0)
        }
        SetMatPStale() {
            this._hasCurrentMatP = !1
        }
        UpdateMatMV(e, t) {
            this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e),
            this._hasCurrentMatMV = !0)
        }
        SetMatMVStale() {
            this._hasCurrentMatMV = !1
        }
        _UpdateDeviceTransformUniforms(t) {
            if (!this._isDeviceTransform)
                throw new Error('not device transform shader');
            this._uMatP.UpdateMatrix4fv(t);
            const a = this._renderer
              , n = a.GetWidth() / 2
              , r = a.GetHeight() / 2
              , i = a._worldScale
              , e = vec3.fromValues(n * i[0], r * i[1], 100 * self.devicePixelRatio)
              , l = vec3.fromValues(n * i[0], r * i[1], 0)
              , _ = mat4.create();
            mat4.lookAt(_, e, l, a._up),
            mat4.scale(_, _, i),
            this._uMatMV.UpdateMatrix4fv(_)
        }
        UpdateColor(e) {
            this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3])
        }
        static GetReservedUniformNames() {
            return e
        }
        static GetDefaultVertexShaderSource(e, t) {
            const a = t ? 'highmedp' : 'mediump';
            return [`#ifdef GL_FRAGMENT_PRECISION_HIGH`, `#define highmedp highp`, `#else`, `#define highmedp mediump`, `#endif`, `attribute highp ${e ? 'vec3' : 'vec2'} aPos;`, `attribute ${a} vec2 aTex;`, `varying ${a} vec2 vTex;`, `uniform highp mat4 matP;`, `uniform highp mat4 matMV;`, `void main(void) {`, `	gl_Position = matP * matMV * vec4(aPos, ${e ? '' : '0.0,'} 1.0);`, `	vTex = aTex;`, `}`].join('\n')
        }
        static GetTextureFillFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}'
        }
        static GetTilemapFragmentShaderSource() {
            return '#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}'
        }
        static GetPointVertexShaderSource() {
            return 'attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}'
        }
        static GetPointFragmentShaderSource() {
            return 'uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}'
        }
        static GetColorFillFragmentShaderSource() {
            return 'uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}'
        }
        static GetLinearGradientFillFragmentShaderSource() {
            return 'precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}'
        }
        static GetSmoothLineFillFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}'
        }
        static GetHardEllipseFillFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}'
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}'
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}'
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
            return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}'
        }
    }
}
{
    function e(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }
    const t = new Map([['float', 1], ['percent', 1], ['sampler', 1], ['vec2', 2], ['vec3', 3], ['color', 3], ['vec4', 4], ['mat4', 16]]);
    C3.Gfx.WebGLShaderUniform = class {
        constructor(n, a, r) {
            if (!t.has(r))
                throw new Error('invalid uniform type');
            this._owner = n,
            this._gl = this._owner.GetWebGLContext(),
            this._name = a,
            this._type = r,
            this._isColorType = 'color' === this._type,
            this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), a),
            this._isUsed = !!this._location;
            const i = t.get(r);
            this._lastValue = new Float32Array(i),
            this._lastBatchValue = new Float32Array(i)
        }
        Release() {
            this._owner = null,
            this._gl = null,
            this._location = null
        }
        IsUsed() {
            return this._isUsed
        }
        GetType() {
            return this._type
        }
        IsColorType() {
            return this._isColorType
        }
        Init1f(e) {
            this.IsUsed() && (this._lastValue[0] = e,
            this._lastBatchValue.set(this._lastValue),
            this._gl.uniform1f(this._location, e))
        }
        Init1i(e) {
            this.IsUsed() && (this._lastValue[0] = e,
            this._lastBatchValue.set(this._lastValue),
            this._gl.uniform1i(this._location, e))
        }
        Init2f(e, t) {
            this.IsUsed() && (this._lastValue[0] = e,
            this._lastValue[1] = t,
            this._lastBatchValue.set(this._lastValue),
            this._gl.uniform2f(this._location, e, t))
        }
        Init3f(e, t, a) {
            this.IsUsed() && (this._lastValue[0] = e,
            this._lastValue[1] = t,
            this._lastValue[2] = a,
            this._lastBatchValue.set(this._lastValue),
            this._gl.uniform3f(this._location, e, t, a))
        }
        Init4f(e, t, a, n) {
            this.IsUsed() && (this._lastValue[0] = e,
            this._lastValue[1] = t,
            this._lastValue[2] = a,
            this._lastValue[3] = n,
            this._lastBatchValue.set(this._lastValue),
            this._gl.uniform4f(this._location, e, t, a, n))
        }
        Update1f(e) {
            e = Math.fround(e);
            const t = this._lastValue;
            t[0] === e || (t[0] = e,
            this._gl.uniform1f(this._location, e))
        }
        Update1i(e) {
            const t = this._lastValue;
            t[0] === e || (t[0] = e,
            this._gl.uniform1i(this._location, e))
        }
        Update2f(e, t) {
            var n = Math.fround;
            e = n(e),
            t = n(t);
            const r = this._lastValue;
            r[0] === e && r[1] === t || (r[0] = e,
            r[1] = t,
            this._gl.uniform2f(this._location, e, t))
        }
        Update3f(t, n, r) {
            var i = Math.fround;
            t = i(t),
            n = i(n),
            r = i(r);
            const l = this._lastValue;
            l[0] === t && l[1] === n && l[2] === r || (l[0] = t,
            l[1] = n,
            l[2] = r,
            this._gl.uniform3f(this._location, t, n, r))
        }
        Update4f(t, n, r, i) {
            var l = Math.fround;
            t = l(t),
            n = l(n),
            r = l(r),
            i = l(i);
            const e = this._lastValue;
            e[0] === t && e[1] === n && e[2] === r && e[3] === i || (e[0] = t,
            e[1] = n,
            e[2] = r,
            e[3] = i,
            this._gl.uniform4f(this._location, t, n, r, i))
        }
        UpdateMatrix4fv(t) {
            const a = this._lastValue;
            e(a, t) || (C3.typedArraySet16(a, t, 0),
            this._gl.uniformMatrix4fv(this._location, !1, t))
        }
        IsSetToCustomInBatch(e) {
            var t = Math.fround;
            const a = this._lastBatchValue;
            return this.IsColorType() ? a[0] === t(e.getR()) && a[1] === t(e.getG()) && a[2] === t(e.getB()) : a[0] === t(e)
        }
        SetBatchValueCustom(e) {
            const t = this._lastBatchValue;
            this.IsColorType() ? (t[0] = e.getR(),
            t[1] = e.getG(),
            t[2] = e.getB()) : t[0] = e
        }
        IsSetTo1InBatch(e) {
            return this._lastBatchValue[0] === Math.fround(e)
        }
        IsSetTo2InBatch(e, t) {
            var a = Math.fround;
            const n = this._lastBatchValue;
            return n[0] === a(e) && n[1] === a(t)
        }
        SetBatch1(e) {
            this._lastBatchValue[0] = e
        }
        SetBatch2(e, t) {
            const a = this._lastBatchValue;
            a[0] = e,
            a[1] = t
        }
    }
}
'use strict',
C3.Gfx.BatchState = class {
    constructor(e) {
        this.renderer = e,
        this.currentMV = mat4.create(),
        this.currentMatP = mat4.create(),
        this.currentFramebuffer = null,
        this.currentColor = vec4.fromValues(1, 1, 1, 1),
        this.currentShader = null,
        this.pointTexCoords = new C3.Rect,
        this.clearColor = C3.New(C3.Color, 0, 0, 0, 0)
    }
}
,
C3.Gfx.WebGLBatchJob = class {
    constructor(e) {
        const t = new ArrayBuffer(96);
        this._type = 0,
        this._batchState = e,
        this._gl = e.renderer.GetContext(),
        this._startIndex = 0,
        this._indexCount = 0,
        this._texParam = null,
        this._mat4param = new Float32Array(t,0,16),
        this._colorParam = new Float32Array(t,64,4),
        this._srcOriginRect = new Float32Array(t,80,4),
        this._shaderParams = []
    }
    InitQuad(e, t) {
        this._type = 1,
        this._startIndex = e,
        this._indexCount = t
    }
    DoQuad() {
        const e = this._gl;
        e.drawElements(e.TRIANGLES, this._indexCount, e.UNSIGNED_SHORT, this._startIndex)
    }
    InitSetTexture(e) {
        this._type = 2,
        this._texParam = e
    }
    DoSetTexture() {
        const e = this._gl
          , t = this._texParam;
        e.bindTexture(e.TEXTURE_2D, t ? t._GetTexture() : null)
    }
    InitSetColor(e) {
        this._type = 3,
        e.writeToTypedArray(this._colorParam, 0)
    }
    DoSetColor() {
        const e = this._colorParam
          , t = this._batchState;
        vec4.copy(t.currentColor, e),
        t.currentShader.UpdateColor(e)
    }
    InitSetGradientColor(e) {
        this._type = 19,
        e.writeToTypedArray(this._colorParam, 0)
    }
    DoSetGradientColor() {
        const e = this._colorParam
          , t = this._batchState.currentShader;
        t._uColor2.IsUsed() && t._uColor2.Update4f(e[0], e[1], e[2], e[3])
    }
    InitSetBlend(e, t) {
        this._type = 4,
        this._startIndex = e,
        this._indexCount = t
    }
    DoSetBlend() {
        this._gl.blendFunc(this._startIndex, this._indexCount)
    }
    InitUpdateModelView(e) {
        this._type = 5,
        mat4.copy(this._mat4param, e)
    }
    DoUpdateModelView() {
        const e = this._batchState
          , t = e.renderer._allShaderPrograms
          , n = e.currentShader
          , r = this._mat4param;
        for (let i = 0, a = t.length; i < a; ++i) {
            const a = t[i];
            a === n ? a.UpdateMatMV(r, !0) : a.SetMatMVStale()
        }
        mat4.copy(e.currentMV, r)
    }
    InitSetRenderTarget(e, t, a) {
        this._type = 6,
        this._texParam = e,
        this._startIndex = t ? 1 : 0,
        t && mat4.copy(this._mat4param, a)
    }
    DoSetRenderTarget() {
        const t = this._gl
          , a = this._texParam
          , n = 0 !== this._startIndex
          , r = this._mat4param
          , i = this._batchState
          , e = i.renderer;
        let l, _;
        if (a) {
            const e = a._GetFramebuffer();
            i.currentFramebuffer = e,
            t.bindFramebuffer(t.FRAMEBUFFER, e),
            l = a.GetWidth(),
            _ = a.GetHeight()
        } else
            i.currentFramebuffer = null,
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            l = e.GetScissoredViewportWidth(),
            _ = e.GetScissoredViewportHeight();
        n && e._UpdateViewportBatch(l, _, r)
    }
    InitClearSurface(e) {
        this._type = 7,
        e.writeToTypedArray(this._mat4param, 0)
    }
    InitClearSurface2(t, n, e, r) {
        this._type = 7;
        const i = this._mat4param;
        i[0] = t,
        i[1] = n,
        i[2] = e,
        i[3] = r
    }
    DoClearSurface() {
        const t = this._gl
          , a = this._mat4param
          , n = this._batchState
          , e = n.renderer
          , r = n.clearColor
          , l = e._isScissorViewport && C3.isDebug;
        l && t.disable(t.SCISSOR_TEST);
        const i = a[0]
          , _ = a[1]
          , d = a[2]
          , u = a[3];
        r.equalsRgba(i, _, d, u) || (t.clearColor(i, _, d, u),
        r.setRgba(i, _, d, u)),
        t.clear(t.COLOR_BUFFER_BIT),
        l && t.enable(t.SCISSOR_TEST)
    }
    InitClearRect(t, n, r, e, l, _, i, d) {
        this._type = 8;
        const u = this._mat4param;
        u[0] = t,
        u[1] = n,
        u[2] = r,
        u[3] = e,
        u[4] = l,
        u[5] = _,
        u[6] = i,
        u[7] = d
    }
    DoClearRectangle() {
        const t = this._gl
          , a = this._mat4param
          , n = this._batchState
          , e = n.renderer
          , r = n.clearColor;
        e._isScissorViewport || t.enable(t.SCISSOR_TEST),
        t.scissor(a[0], a[1], a[2], a[3]);
        const l = a[4]
          , i = a[5]
          , _ = a[6]
          , d = a[7];
        r.equalsRgba(l, i, _, d) || (t.clearColor(l, i, _, d),
        r.setRgba(l, i, _, d)),
        t.clear(t.COLOR_BUFFER_BIT),
        e._isScissorViewport ? t.scissor(0, 0, e._viewportScissorWidth, e._viewportScissorHeight) : t.disable(t.SCISSOR_TEST)
    }
    InitSetPointTexCoords(e) {
        this._type = 13,
        e.writeToTypedArray(this._mat4param, 0)
    }
    DoSetPointTextureCoords() {
        const e = this._mat4param;
        this._batchState.pointTexCoords.set(e[0], e[1], e[2], e[3])
    }
    InitPoints(e, t) {
        this._type = 9,
        this._startIndex = e,
        this._indexCount = 1,
        this._mat4param[0] = t
    }
    DoPoints() {
        const t = this._gl
          , n = this._batchState
          , a = n.renderer
          , r = a._spPoints;
        t.useProgram(r._shaderProgram),
        r.UpdateMatP(n.currentMatP, !1),
        r.UpdateMatMV(n.currentMV, !1);
        const i = n.pointTexCoords;
        r._uPointTexStart.IsUsed() && r._uPointTexStart.Update2f(i.getLeft(), i.getTop()),
        r._uPointTexEnd.IsUsed() && r._uPointTexEnd.Update2f(i.getRight(), i.getBottom());
        const e = this._mat4param[0];
        if (r._uZElevation.IsUsed() && r._uZElevation.Update1f(e),
        r._uColor.IsUsed()) {
            const e = n.currentColor;
            r._uColor.Update4f(e[0], e[1], e[2], e[3])
        }
        t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount),
        t.useProgram(n.currentShader._shaderProgram)
    }
    InitSetProgram(e) {
        this._type = 10,
        this._texParam = e
    }
    DoSetProgram() {
        const e = this._gl
          , t = this._batchState
          , n = this._texParam;
        if (t.currentShader = n,
        e.useProgram(n._shaderProgram),
        n.UpdateMatP(t.currentMatP, !1),
        n.UpdateMatMV(t.currentMV, !1),
        n._uColor.IsUsed()) {
            const e = t.currentColor;
            n._uColor.Update4f(e[0], e[1], e[2], e[3])
        }
    }
    InitSetProgramParameters() {
        this._type = 11
    }
    DoSetProgramParameters() {
        const e = this._batchState.currentShader;
        e._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(e),
        e._uCustomParameters.length && this._DoUpdateCustomProgramParameters(e)
    }
    _DoSetOptionalUniformProgramParameters(t) {
        const n = this._gl
          , a = this._mat4param
          , r = this._colorParam
          , i = this._srcOriginRect;
        if (t._uSamplerBack.IsUsed()) {
            const e = this._batchState.renderer
              , t = this._texParam;
            e._lastTexture1 !== t && (n.activeTexture(n.TEXTURE1),
            n.bindTexture(n.TEXTURE_2D, t ? t._GetTexture() : null),
            e._lastTexture1 = t,
            n.activeTexture(n.TEXTURE0))
        }
        t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(a[0], a[1]),
        t._uDestStart.IsUsed() && t._uDestStart.Update2f(a[2], a[3]),
        t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(a[4], a[5]),
        t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(a[6]),
        t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(a[7]),
        t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(a[12], a[13]),
        t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(a[14], a[15]),
        t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(i[0], i[1]),
        t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(i[2], i[3]),
        t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(r[0], r[1]),
        t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(r[2], r[3]),
        t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex)
    }
    _DoUpdateCustomProgramParameters(e) {
        const t = e._uCustomParameters
          , n = this._shaderParams;
        for (let r = 0, a = t.length; r < a; ++r) {
            const i = t[r]
              , a = n[r];
            i.IsColorType() ? i.Update3f(a.getR(), a.getG(), a.getB()) : i.Update1f(a)
        }
    }
    InitInvalidateFramebuffer(e) {
        this._type = 12,
        this._texParam = e
    }
    DoInvalidateFramebuffer() {
        const e = this._gl
          , t = this._texParam
          , a = this._batchState.currentFramebuffer;
        t !== a && e.bindFramebuffer(e.FRAMEBUFFER, t),
        e.invalidateFramebuffer(e.FRAMEBUFFER, [e.COLOR_ATTACHMENT0]),
        t !== a && e.bindFramebuffer(e.FRAMEBUFFER, a)
    }
    InitBlitFramebuffer(t, a, n) {
        this._type = 15;
        const r = this._mat4param
          , i = this._batchState.renderer;
        r[0] = t.GetWidth(),
        r[1] = t.GetHeight(),
        r[2] = a ? a.GetWidth() : i.GetWidth(),
        r[3] = a ? a.GetHeight() : i.GetHeight(),
        r[4] = t.IsLinearSampling() ? 1 : 0,
        r[5] = 'stretch' === n;
        const e = this._shaderParams;
        C3.clearArray(e),
        e.push(t._GetFramebuffer()),
        e.push(a ? a._GetFramebuffer() : null)
    }
    DoBlitFramebuffer() {
        var t = Math.max
          , a = Math.min;
        const n = this._mat4param
          , r = this._shaderParams
          , _ = this._gl
          , e = n[0]
          , u = n[1]
          , g = n[2]
          , i = n[3]
          , d = 0 !== n[4]
          , c = 0 !== n[5]
          , p = r[0]
          , l = r[1];
        if (_.bindFramebuffer(_.READ_FRAMEBUFFER, p),
        _.bindFramebuffer(_.DRAW_FRAMEBUFFER, l),
        c)
            _.blitFramebuffer(0, 0, e, u, 0, 0, g, i, _.COLOR_BUFFER_BIT, d ? _.LINEAR : _.NEAREST);
        else {
            const n = a(e, g)
              , r = a(u, i)
              , l = t(u - i, 0)
              , d = t(i - u, 0);
            _.blitFramebuffer(0, l, n, r + l, 0, d, n, r + d, _.COLOR_BUFFER_BIT, _.NEAREST)
        }
    }
    InitStartQuery(e) {
        this._type = 16,
        this._texParam = e
    }
    DoStartQuery() {
        this._texParam.BeginTimeElapsed(),
        this._texParam = null
    }
    InitEndQuery(e) {
        this._type = 17,
        this._texParam = e
    }
    DoEndQuery() {
        this._texParam.EndTimeElapsed(),
        this._texParam = null
    }
    InitSetEllipseParams(e, t, a) {
        this._type = 18;
        const n = this._mat4param;
        n[0] = e,
        n[1] = t,
        n[2] = a
    }
    DoSetEllipseParams() {
        const e = this._batchState.currentShader
          , t = this._mat4param;
        e._uPixelSize.IsUsed() && e._uPixelSize.Update2f(t[0], t[1]),
        e._uOutlineThickness.IsUsed() && e._uOutlineThickness.Update1f(t[2])
    }
    InitSetTilemapInfo(t, a, n, r, i, e, l) {
        this._type = 14;
        const _ = this._mat4param;
        t.writeToTypedArray(_, 0),
        _[4] = 1 / a,
        _[5] = 1 / n,
        _[6] = r / a,
        _[7] = i / n,
        _[8] = e / a,
        _[9] = l / n
    }
    DoSetTilemapInfo() {
        const e = this._batchState.currentShader
          , t = this._mat4param;
        e._uSrcStart.IsUsed() && e._uSrcStart.Update2f(t[0], t[1]),
        e._uPixelSize.IsUsed() && e._uPixelSize.Update2f(t[4], t[5]),
        e._uTileSize.IsUsed() && e._uTileSize.Update2f(t[6], t[7]),
        e._uTileSpacing.IsUsed() && e._uTileSpacing.Update2f(t[8], t[9])
    }
    Run() {
        switch (this._type) {
        case 1:
            return void this.DoQuad();
        case 2:
            return void this.DoSetTexture();
        case 3:
            return void this.DoSetColor();
        case 4:
            return void this.DoSetBlend();
        case 5:
            return void this.DoUpdateModelView();
        case 6:
            return void this.DoSetRenderTarget();
        case 7:
            return void this.DoClearSurface();
        case 8:
            return void this.DoClearRectangle();
        case 9:
            return void this.DoPoints();
        case 10:
            return void this.DoSetProgram();
        case 11:
            return void this.DoSetProgramParameters();
        case 12:
            return void this.DoInvalidateFramebuffer();
        case 13:
            return void this.DoSetPointTextureCoords();
        case 14:
            return void this.DoSetTilemapInfo();
        case 15:
            return void this.DoBlitFramebuffer();
        case 16:
            return void this.DoStartQuery();
        case 17:
            return void this.DoEndQuery();
        case 18:
            return void this.DoSetEllipseParams();
        case 19:
            return void this.DoSetGradientColor();
        }
    }
}
,
'use strict';
{
    function _(t, a, n, r, i, e) {
        a ? 'Gecko' === C3.Platform.BrowserEngine ? t.strokeText(n, r, i, e) : t.strokeText(n, r, i) : 'Gecko' === C3.Platform.BrowserEngine ? t.fillText(n, r, i, e) : t.fillText(n, r, i)
    }
    function a(t, a, n, r, i, e) {
        a ? t.strokeRect(n, r, i, e) : t.fillRect(n, r, i, e)
    }
    function t(e) {
        return e * (4 / 3)
    }
    const n = {
        timeout: 60
    }
      , r = new C3.Color(0,0,0,1)
      , e = new Set(['left', 'center', 'right'])
      , l = new Set(['top', 'center', 'bottom'])
      , d = new Set(['word', 'character'])
      , u = new Set;
    C3.FontManager && C3.FontManager.addEventListener('fontload', e=>{
        const t = e.font.GetName();
        for (const a of u)
            (a.IsBBCodeEnabled() || C3.equalsNoCase(a.GetFontName(), t)) && a._SetTextChanged()
    }
    ),
    C3.Gfx.WebGLText = class {
        constructor(e, t) {
            t = Object.assign({}, n, t),
            this._renderer = e,
            this._fontName = 'Arial',
            this._fontSize = 16,
            this._lineHeight = 0,
            this._isBold = !1,
            this._isItalic = !1,
            this._colorStr = 'black',
            this._isBBcodeEnabled = !1,
            this.onloadfont = null,
            this._alreadyLoadedFonts = new Set,
            this._horizontalAlign = 'left',
            this._verticalAlign = 'top',
            this._text = '',
            this._bbString = null,
            this._wrappedText = C3.New(C3.WordWrap),
            this._wrapMode = 'word',
            this._textChanged = !1,
            this._isUpdating = !1,
            this._isAsync = !0,
            this._drawMaxCharCount = -1,
            this._drawCharCount = 0,
            this._cssWidth = 0,
            this._cssHeight = 0,
            this._width = 0,
            this._height = 0,
            this._zoom = 1,
            this._changed = !1,
            this._textCanvas = null,
            this._textContext = null,
            this._measureContext = null,
            this._lastCanvasWidth = -1,
            this._lastCanvasHeight = -1,
            this._lastTextCanvasFont = '',
            this._lastMeasureCanvasFont = '',
            this._lastTextCanvasFillStyle = '',
            this._lastTextCanvasOpacity = 1,
            this._lastTextCanvasLineWidth = 1,
            this._measureTextCallback = (e,t)=>this._MeasureText(e, t),
            this._texture = null,
            this._textureWidth = 0,
            this._textureHeight = 0,
            this._rcTex = new C3.Rect,
            this._scaleFactor = 1,
            this._needToRecreateTexture = !1,
            this._textureTimeout = new C3.IdleTimeout(()=>{
                this.ReleaseTexture(),
                this._SetTextCanvasSize(8, 8)
            }
            ,t.timeout),
            this.ontextureupdate = null,
            this._wasReleased = !1,
            u.add(this)
        }
        Release() {
            this.onloadfont = null,
            this._alreadyLoadedFonts.clear(),
            this._bbString = null,
            this._textCanvas = null,
            this._textContext = null,
            this._measureContext = null,
            this._measureTextCallback = null,
            this._textureTimeout.Release(),
            this.ontextureupdate = null,
            this.ReleaseTexture(),
            this._wrappedText.Clear(),
            this._wrappedText = null,
            this._renderer = null,
            this._wasReleased = !0,
            u.delete(this)
        }
        _SetChanged() {
            this._changed = !0
        }
        _SetTextChanged() {
            this._SetChanged(),
            this._wrappedText.Clear(),
            this._textChanged = !0
        }
        SetIsAsync(e) {
            this._isAsync = !!e
        }
        IsAsync() {
            return this._isAsync
        }
        SetBBCodeEnabled(e) {
            e = !!e,
            this._isBBcodeEnabled === e || (this._isBBcodeEnabled = e,
            this._textContext && (this._textContext.textBaseline = this._isBBcodeEnabled ? 'alphabetic' : 'top'),
            this._SetTextChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetFontName(e) {
            e || (e = 'serif'),
            this._fontName === e || (this._fontName = e,
            this._SetTextChanged())
        }
        GetFontName() {
            return this._fontName
        }
        SetFontSize(e) {
            .1 > e && (e = .1),
            this._fontSize === e || (this._fontSize = e,
            this._SetTextChanged())
        }
        SetLineHeight(e) {
            this._lineHeight === e || (this._lineHeight = e,
            this._SetChanged())
        }
        SetBold(e) {
            e = !!e,
            this._isBold === e || (this._isBold = e,
            this._SetTextChanged())
        }
        SetItalic(e) {
            e = !!e,
            this._isItalic === e || (this._isItalic = e,
            this._SetTextChanged())
        }
        SetDrawMaxCharacterCount(e) {
            e = Math.floor(e),
            this._drawMaxCharCount === e || (this._drawMaxCharCount = e,
            this._SetChanged())
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(e, t) {
            for (let a = e.length - 1; 0 <= a; --a) {
                const n = e[a];
                if (n.tag === t)
                    return n
            }
            return null
        }
        _HasStyleTag(e, t) {
            return !!this._GetStyleTag(e, t)
        }
        _GetFontString(t, a) {
            let n = '';
            (this._isBold || this._HasStyleTag(a, 'b')) && (n += 'bold'),
            (this._isItalic || this._HasStyleTag(a, 'i')) && (n += ' italic');
            const r = this._GetStyleTag(a, 'size')
              , i = r ? parseFloat(r.param) : this._fontSize;
            n += t ? ' ' + i + 'pt' : ' ' + i * this._scaleFactor * this._zoom * self.devicePixelRatio + 'pt';
            let e = this._fontName;
            const l = this._GetStyleTag(a, 'font');
            return l && l.param && (e = l.param,
            this.onloadfont && !this._alreadyLoadedFonts.has(e) && (this.onloadfont(e),
            this._alreadyLoadedFonts.add(e))),
            e && (n += ' "' + e + '"'),
            n
        }
        SetColor(e) {
            e instanceof C3.Color && (e = e.getCssRgb()),
            this._colorStr === e || (this._colorStr = e,
            this._SetChanged())
        }
        SetColorRgb(e, t, a) {
            r.setRgb(e, t, a),
            this.SetColor(r)
        }
        SetHorizontalAlignment(t) {
            if (!e.has(t))
                throw new Error('invalid horizontal alignment');
            this._horizontalAlign === t || (this._horizontalAlign = t,
            this._SetChanged())
        }
        SetVerticalAlignment(e) {
            if (!l.has(e))
                throw new Error('invalid vertical alignment');
            this._verticalAlign === e || (this._verticalAlign = e,
            this._SetChanged())
        }
        SetWordWrapMode(e) {
            if (!d.has(e))
                throw new Error('invalid word wrap mode');
            this._wrapMode === e || (this._wrapMode = e,
            this._SetTextChanged())
        }
        SetText(e) {
            this._text === e || (this._text = e,
            this._SetTextChanged())
        }
        SetSize(t, a, n) {
            var r = Math.min;
            if ('undefined' == typeof n && (n = 1),
            0 >= t || 0 >= t)
                return;
            if (this._cssWidth === t && this._cssHeight === a && this._zoom === n)
                return;
            1 === this._zoom != (1 === n) && (this._needToRecreateTexture = !0);
            const l = this._cssWidth
              , e = this._zoom;
            this._cssWidth = t,
            this._cssHeight = a,
            this._zoom = n;
            const _ = self.devicePixelRatio;
            this._width = this._cssWidth * this._zoom * _,
            this._height = this._cssHeight * this._zoom * _;
            const d = Math.max(this._width, this._height)
              , u = r(this._renderer.GetMaxTextureSize(), 2048);
            let i = 1;
            d > u && (i = u / d,
            this._width = r(this._width * i, u),
            this._height = r(this._height * i, u)),
            this._scaleFactor = i,
            0 < this._textureWidth && 0 < this._textureHeight && this._zoom === e && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight),
            this._cssWidth === l ? this._SetChanged() : this._SetTextChanged()
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetTextWidth() {
            return this._MaybeWrapText(),
            this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            const e = t(this._fontSize) + 4;
            return this._wrappedText.GetLineCount() * (e + this._lineHeight) - this._lineHeight
        }
        GetTexture() {
            return this._textureTimeout.Reset(),
            this._MaybeUpdate(),
            this._texture
        }
        _MaybeUpdate() {
            this._texture && !this._changed && !this._textChanged || this._isUpdating || 0 >= this._width || 0 >= this._height || (this._changed = !1,
            this._isUpdating = !0,
            this._isAsync ? C3.Asyncify(()=>this._DoUpdate()) : this._DoUpdate())
        }
        _DoUpdate() {
            var e = Math.ceil;
            this._wasReleased || (this._SetTextCanvasSize(e(this._width), e(this._height)),
            this._MaybeWrapText(),
            this._DrawTextToCanvas(),
            this._UpdateTexture(),
            this._textureTimeout.Reset(),
            this._isUpdating = !1)
        }
        _SetTextCanvasSize(e, t) {
            this._textCanvas || (this._textCanvas = C3.CreateCanvas(16, 16));
            let a = !1;
            (this._lastCanvasWidth !== e || this._lastCanvasHeight !== t) && (this._lastCanvasWidth = e,
            this._lastCanvasHeight = t,
            this._textCanvas.width = e,
            this._textCanvas.height = t,
            a = !0),
            this._textContext || (this._textContext = this._textCanvas.getContext('2d'),
            a = !0),
            a ? (this._textContext.textBaseline = this._isBBcodeEnabled ? 'alphabetic' : 'top',
            this._textContext.font = this._lastTextCanvasFont,
            this._textContext.fillStyle = this._lastTextCanvasFillStyle,
            this._textContext.strokeStyle = this._lastTextCanvasFillStyle,
            this._textContext.globalAlpha = this._lastTextCanvasOpacity,
            this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, e, t)
        }
        _MaybeCreateMeasureContext() {
            this._measureContext || (this._measureContext = C3.CreateCanvas(16, 16).getContext('2d'))
        }
        _SetMeasureFontString(e) {
            this._lastMeasureCanvasFont === e || (this._lastMeasureCanvasFont = e,
            this._measureContext.font = e)
        }
        _MaybeWrapText() {
            this._textChanged && (this._MaybeCreateMeasureContext(),
            this._isBBcodeEnabled && (!this._bbString || this._bbString.toString() !== this._text) && (this._bbString = new C3.BBString(this._text,{
                noEscape: !0
            })),
            this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0),
            this._textChanged = !1)
        }
        _MeasureText(n, a) {
            this._SetMeasureFontString(this._GetFontString(!0, a));
            const r = this._GetStyleTag(a, 'size')
              , i = r ? parseFloat(r.param) : this._fontSize;
            return {
                width: this._measureContext.measureText(n).width,
                height: t(i)
            }
        }
        _SetDrawFontString(e) {
            this._lastTextCanvasFont === e || (this._lastTextCanvasFont = e,
            this._textContext.font = e)
        }
        _SetDrawCanvasColor(e) {
            this._lastTextCanvasFillStyle === e || (this._lastTextCanvasFillStyle = e,
            this._textContext.fillStyle = e,
            this._textContext.strokeStyle = e)
        }
        _SetDrawCanvasOpacity(e) {
            this._lastTextCanvasOpacity === e || (this._lastTextCanvasOpacity = e,
            this._textContext.globalAlpha = e)
        }
        _SetDrawCanvasLineWith(e) {
            this._lastTextCanvasLineWidth === e || (this._lastTextCanvasLineWidth = e,
            this._textContext.lineWidth = e)
        }
        _DrawTextToCanvas() {
            this._drawCharCount = 0;
            const t = this._scaleFactor * this._zoom * self.devicePixelRatio
              , n = (4 + this._lineHeight) * t;
            let r = 0;
            const i = this._wrappedText.GetLines()
              , l = i.reduce((e,r)=>e + r.height * t + n, 0) - this._lineHeight * t;
            'center' === this._verticalAlign ? r = Math.max(this._height / 2 - l / 2, 0) : 'bottom' === this._verticalAlign && (r = this._height - l - 2);
            for (let a = 0, e = i.length; a < e; ++a) {
                const e = i[a]
                  , l = e.height * t
                  , _ = r;
                if (this._isBBcodeEnabled) {
                    if (r += l,
                    0 < a && r > this._height - 4 * t)
                        break;
                } else if (0 < a && r >= this._height - l)
                    break;
                0 <= _ && this._DrawTextLine(e, r, t),
                this._isBBcodeEnabled || (r += l),
                r += n
            }
        }
        _DrawTextLine(t, a, n) {
            let r = 0;
            'center' === this._horizontalAlign ? r = (this._width - t.width * n) / 2 : 'right' === this._horizontalAlign && (r = this._width - t.width * n);
            for (const i of t.fragments)
                this._DrawTextFragment(i, r, a, n, t.height),
                r += i.width * n
        }
        _DrawTextFragment(t, S, y, G, u) {
            const f = this._textContext
              , h = u / 16;
            let i = t.width * G;
            const b = t.height * G
              , T = t.height / 16
              , l = (4 + this._lineHeight) * G
              , m = t.styles;
            let n = t.text;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                this._drawCharCount + n.length > this._drawMaxCharCount && (n = n.substr(0, this._drawMaxCharCount - this._drawCharCount),
                i = this._MeasureText(n, m).width * G),
                this._drawCharCount += n.length
            }
            const I = this._GetStyleTag(m, 'background')
              , p = this._HasStyleTag(m, 'u')
              , C = this._HasStyleTag(m, 's');
            if ((!C3.IsStringAllWhitespace(n) || I || p || C) && !this._HasStyleTag(m, 'hide')) {
                const e = this._GetStyleTag(m, 'offsetx');
                S += e ? parseFloat(e.param) * G : 0;
                const r = this._GetStyleTag(m, 'offsety');
                y += r ? parseFloat(r.param) * G : 0,
                I && (this._SetDrawCanvasColor(I.param),
                f.fillRect(S, y - b, i, b + l));
                const d = this._GetStyleTag(m, 'color');
                this._SetDrawCanvasColor(d ? d.param : this._colorStr);
                const c = this._GetStyleTag(m, 'opacity');
                this._SetDrawCanvasOpacity(c ? parseFloat(c.param) / 100 : 1);
                const t = this._HasStyleTag(m, 'stroke');
                if (t && this._SetDrawCanvasLineWith(T * this._scaleFactor * this._zoom),
                p && a(f, t, S, y + G * h, i, G * h),
                C && a(f, t, S, y - b / 4, i, G * T),
                this._SetDrawFontString(this._GetFontString(!1, m)),
                _(f, t, n, S, y, i),
                !t) {
                    this._SetDrawCanvasLineWith(T * this._scaleFactor * this._zoom);
                    const e = this._GetStyleTag(m, 'outline');
                    e && (this._SetDrawCanvasColor(e.param),
                    _(f, !0, n, S, y, i))
                }
            }
        }
        _UpdateTexture() {
            var e = Math.ceil;
            this._renderer.IsContextLost() || (this._textureWidth = e(this._width),
            this._textureHeight = e(this._height),
            this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight),
            this._needToRecreateTexture && (this.ReleaseTexture(),
            this._needToRecreateTexture = !1),
            !this._texture && (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
                mipMap: 1 === this._zoom,
                mipMapQuality: 'high'
            })),
            this._renderer.UpdateTexture(this._textCanvas, this._texture),
            this.ontextureupdate && this.ontextureupdate())
        }
        GetTexRect() {
            return this._rcTex
        }
        ReleaseTexture() {
            this._texture && (!this._renderer.IsContextLost() && this._renderer.DeleteTexture(this._texture),
            this._texture = null)
        }
        static OnContextLost() {
            for (const e of u)
                e.ReleaseTexture()
        }
        static GetAll() {
            return u.values()
        }
    }
}
{
    class e {
        constructor(e) {
            this._gl = e.GetContext(),
            this._version = e.GetWebGLVersionNumber(),
            this._timerExt = e._GetDisjointTimerQueryExtension(),
            this._query = null,
            this._isActive = !1,
            this._hasResult = !1,
            this._result = 0,
            this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
        }
        Release() {
            this._DeleteQueryObject(),
            this._gl = null,
            this._timerExt = null,
            this._hasResult = !1
        }
        _DeleteQueryObject() {
            this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
            this._query = null)
        }
        BeginTimeElapsed() {
            if (this._isActive)
                throw new Error('query already active');
            1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query),
            this._isActive = !0
        }
        EndTimeElapsed() {
            if (!this._isActive)
                throw new Error('query not active');
            1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT),
            this._isActive = !1
        }
        CheckForResult() {
            if (!this._query || this._hasResult || this._isActive)
                return;
            let e = !1;
            e = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            const t = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
            e && !t && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT),
            this._result /= 1e9,
            this._hasResult = !0),
            (e || t) && this._DeleteQueryObject()
        }
        HasResult() {
            return this._hasResult
        }
        GetResult() {
            if (!this._hasResult)
                throw new Error('no result available');
            return this._result
        }
    }
    C3.Gfx.WebGLTimeElapsedQuery = class {
        constructor(e) {
            this._renderer = e,
            this._frameNumber = e.GetFrameNumber(),
            this._isActive = !1,
            this._parentQuery = null,
            this._isNested = !1,
            this._realQuery = null,
            this._queries = []
        }
        Release() {
            for (const t of this._queries)
                t instanceof e && t.Release();
            C3.clearArray(this._queries),
            this._parentQuery = null,
            this._realQuery = null,
            this._renderer = null
        }
        BeginTimeElapsed() {
            if (this._isActive)
                throw new Error('query already active');
            const e = this._renderer._GetTimeQueryStack();
            0 < e.length ? (this._isNested = !0,
            this._parentQuery = e[e.length - 1],
            this._parentQuery._EndReal(),
            this._parentQuery._queries.push(this)) : (this._isNested = !1,
            this._parentQuery = null),
            this._isActive = !0,
            e.push(this),
            this._StartReal()
        }
        EndTimeElapsed() {
            if (!this._isActive)
                throw new Error('query not active');
            const e = this._renderer._GetTimeQueryStack().pop();
            if (e !== this)
                throw new Error('can only end most nested query');
            this._isActive = !1,
            this._EndReal(),
            this._parentQuery && (this._parentQuery._StartReal(),
            this._parentQuery = null)
        }
        _StartReal() {
            this._realQuery = C3.New(e, this._renderer),
            this._queries.push(this._realQuery),
            this._realQuery.BeginTimeElapsed()
        }
        _EndReal() {
            this._realQuery.EndTimeElapsed(),
            this._realQuery = null
        }
        CheckForResult() {
            for (const e of this._queries)
                e.CheckForResult()
        }
        IsNested() {
            return this._isNested
        }
        HasResult() {
            return this._queries.every(e=>e.HasResult())
        }
        GetResult() {
            return this._queries.reduce((e,t)=>e + t.GetResult(), 0)
        }
        GetFrameNumber() {
            return this._frameNumber
        }
    }
}
'use strict',
C3.Gfx.WebGLQueryResultBuffer = class {
    constructor(e, t=1e3) {
        this._renderer = e,
        this._maxQueries = t,
        this._buffer = [],
        this._renderer._AddQueryResultBuffer(this)
    }
    Release() {
        this.Clear(),
        this._renderer._RemoveQueryResultBuffer(this),
        this._renderer = null
    }
    Clear() {
        for (const e of this._buffer)
            e.Release();
        C3.clearArray(this._buffer)
    }
    AddTimeElapsedQuery() {
        const e = new C3.Gfx.WebGLTimeElapsedQuery(this._renderer);
        if (this._buffer.push(e),
        this._buffer.length > this._maxQueries) {
            const e = this._buffer.shift();
            e.Release()
        }
        return e
    }
    CheckForResults(e) {
        for (const t of this._buffer) {
            if (t.GetFrameNumber() >= e)
                return;
            if (t.IsNested())
                return;
            t.CheckForResult()
        }
    }
    GetFrameRangeResultSum(e, t) {
        if (t <= e)
            return NaN;
        let a = 0;
        for (const n of this._buffer) {
            if (n.GetFrameNumber() >= t)
                break;
            if (!(n.GetFrameNumber() < e))
                if (n.HasResult())
                    a += n.GetResult();
                else
                    return NaN
        }
        return a
    }
    DeleteAllBeforeFrameNumber(e) {
        for (let t = 0, a = this._buffer.length; t < a; ++t) {
            const a = this._buffer[t];
            if (a.GetFrameNumber() < e)
                a.Release();
            else
                return void (0 < t && this._buffer.splice(0, t))
        }
    }
}
,
'use strict';
{
    function g(a, e) {
        return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3] && a[4] === e[4] && a[5] === e[5] && a[6] === e[6] && a[7] === e[7] && a[8] === e[8] && a[9] === e[9] && a[10] === e[10] && a[11] === e[11] && a[12] === e[12] && a[13] === e[13] && a[14] === e[14] && a[15] === e[15]
    }
    function m() {
        t = -1;
        for (const t of _)
            t.checkFunc() && (t.resolve(),
            _.delete(t));
        0 < _.size && (t = self.requestAnimationFrame(m))
    }
    function h(n, e, t) {
        let r = null;
        if (2.1 <= t && (r = n.getContext('webgl2-compute', e),
        r))
            return {
                gl: r,
                version: 2.1
            };
        if (2 <= t && (r = n.getContext('webgl2', e),
        r))
            return {
                gl: r,
                version: 2
            };
        if (r = n.getContext('webgl', e),
        !r)
            try {
                r = n.getContext('experimental-webgl', e)
            } catch (t) {
                console.warn('Error requesting \'experimental-webgl\' context: ', t)
            }
        return {
            gl: r,
            version: 1
        }
    }
    const r = {
        powerPreference: 'default',
        enableGpuProfiling: !0,
        alpha: !1,
        lowLatency: !1,
        maxWebGLVersion: 1     //2
    }
      , a = new Set(['default', 'low-power', 'high-performance'])
      , f = new C3.Quad(0,0,1,0,1,1,0,1)
      , n = vec3.fromValues(0, 0, 0)
      , i = vec3.fromValues(0, 0, 0)
      , l = mat4.create()
      , S = new C3.Quad
      , y = new C3.Rect;
    let G = null;
    C3.isDebug && (self.debug_lose_context = function() {
        return G ? void G.loseContext() : void console.warn('WEBGL_lose_context not supported')
    }
    ,
    self.debug_restore_context = function() {
        return G ? void G.restoreContext() : void console.warn('WEBGL_lose_context not supported')
    }
    );
    const _ = new Set;
    let t = -1;
    C3.Gfx.WebGLRenderer = class extends C3.Gfx.RendererBase {
        constructor(i, e) {
            if (super(),
            e = Object.assign({}, r, e),
            !a.has(e.powerPreference))
                throw new Error('invalid power preference');
            let d = !1;
            const u = {
                alpha: !!e.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: e.powerPreference,
                failIfMajorPerformanceCaveat: !0
            };
            e.lowLatency && (u.desynchronized = !0,
            u.preserveDrawingBuffer = !0);
            let _ = h(i, u, e.maxWebGLVersion);
            if (_.gl || (d = !0,
            u.failIfMajorPerformanceCaveat = !1,
            _ = h(i, u, e.maxWebGLVersion)),
            !_.gl)
                throw new Error('failed to initialise WebGL context');
            const c = _.gl;
            this._gl = c,
            this._attribs = c.getContextAttributes(),
            e.lowLatency && !this._attribs.desynchronized && console.info('[WebGLRenderer] Low-latency mode specified but is not supported here'),
            this._versionString = c.getParameter(c.VERSION),
            this._version = _.version,
            this._is3d = !0,
            this._lastBackbufferWidth = 0,
            this._lastBackbufferHeight = 0,
            this._vertexBuffer = null,
            this._texcoordBuffer = null,
            this._indexBuffer = null,
            this._pointBuffer = null,
            this._vertexData = new Float32Array(8e3 * this.GetNumVertexComponents()),
            this._indexData = new Uint16Array(12e3),
            this._texcoordData = new Float32Array(16e3),
            this._pointData = new Float32Array(32e3),
            this._vertexPtr = 0,
            this._texPtr = 0,
            this._pointPtr = 0,
            this._lastVertexPtr = 0,
            this._lastProgram = null,
            this._spDeviceTransformTextureFill = null,
            this._spColorFill = null,
            this._spLinearGradientFill = null,
            this._spHardEllipseFill = null,
            this._spHardEllipseOutline = null,
            this._spSmoothEllipseFill = null,
            this._spSmoothEllipseOutline = null,
            this._spSmoothLineFill = null,
            this._spPoints = null,
            this._spTilemapFill = null,
            this._batch = [],
            this._batchPtr = 0,
            this._topOfBatch = 0,
            this._currentRenderTarget = null,
            this._baseZ = 0,
            this._currentZ = 0,
            this._lastPointZ = 0,
            this._batchState = C3.New(C3.Gfx.BatchState, this),
            this._lastColor = C3.New(C3.Color, 1, 1, 1, 1),
            this._lastTexture0 = null,
            this._lastTexture1 = null,
            this._lastSrcBlend = 0,
            this._lastDestBlend = 0,
            this._lineWidth = 1,
            this._lineWidthStack = [this._lineWidth],
            this._lineCap = 1,
            this._lineCapStack = [this._lineCap],
            this._lineOffset = .5,
            this._lineOffsetStack = [this._lineOffset],
            this._isScissorViewport = !1,
            this._viewportScissorWidth = -1,
            this._viewportScissorHeight = -1,
            this._lastPointTexCoords = new C3.Rect,
            this._maxTextureSize = -1,
            this._minPointSize = 0,
            this._maxPointSize = 0,
            this._highpPrecision = 0,
            this._unmaskedVendor = '(unavailable)',
            this._unmaskedRenderer = '(unavailable)',
            this._extensions = [],
            this._hasMajorPerformanceCaveat = d,
            this._isInitialisingAfterContextRestored = !1,
            this._parallelShaderCompileExt = null,
            this._isGpuProfilingEnabled = !!e.enableGpuProfiling,
            this._timerExt = null,
            this._allQueryResultBuffers = new Set,
            this._timeQueryStack = [],
            this.FillIndexBufferData(this._indexData)
        }
        async InitState() {
            const u = this._gl
              , e = this.GetNumVertexComponents();
            this._lastColor.setRgba(1, 1, 1, 1),
            this._lastTexture0 = null,
            this._lastTexture1 = null,
            this._vertexPtr = 0,
            this._pointPtr = 0,
            this._lastVertexPtr = 8e3 * e - 4 * e,
            C3.clearArray(this._batch),
            this._batchPtr = 0,
            this._topOfBatch = 0,
            this._lastProgram = null,
            this._currentRenderTarget = null,
            this._lastPointTexCoords.set(0, 0, 1, 1),
            this._baseZ = 0,
            this._currentZ = 0,
            this._lastPointZ = 0;
            const t = this._batchState;
            t.currentShader = null,
            t.currentFramebuffer = null,
            vec4.set(t.currentColor, 1, 1, 1, 1),
            t.clearColor.setRgba(0, 0, 0, 0),
            t.pointTexCoords.set(0, 0, 1, 1),
            u.clearColor(0, 0, 0, 0),
            u.clear(u.COLOR_BUFFER_BIT),
            u.enable(u.BLEND),
            u.blendFunc(u.ONE, u.ONE_MINUS_SRC_ALPHA),
            this._lastSrcBlend = u.ONE,
            this._lastDestBlend = u.ONE_MINUS_SRC_ALPHA,
            this._InitBlendModes(u),
            u.disable(u.CULL_FACE),
            u.disable(u.STENCIL_TEST),
            u.disable(u.DITHER),
            u.disable(u.DEPTH_TEST),
            this._pointBuffer = u.createBuffer(),
            u.bindBuffer(u.ARRAY_BUFFER, this._pointBuffer),
            u.bufferData(u.ARRAY_BUFFER, this._pointData.byteLength, u.DYNAMIC_DRAW),
            this._vertexBuffer = u.createBuffer(),
            u.bindBuffer(u.ARRAY_BUFFER, this._vertexBuffer),
            u.bufferData(u.ARRAY_BUFFER, this._vertexData.byteLength, u.DYNAMIC_DRAW),
            this._texcoordBuffer = u.createBuffer(),
            u.bindBuffer(u.ARRAY_BUFFER, this._texcoordBuffer),
            u.bufferData(u.ARRAY_BUFFER, this._texcoordData.byteLength, u.DYNAMIC_DRAW),
            this._indexBuffer = u.createBuffer(),
            u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
            u.bufferData(u.ELEMENT_ARRAY_BUFFER, this._indexData, u.STATIC_DRAW),
            u.activeTexture(u.TEXTURE0),
            u.bindTexture(u.TEXTURE_2D, null),
            this._maxTextureSize = u.getParameter(u.MAX_TEXTURE_SIZE);
            const r = u.getParameter(u.ALIASED_POINT_SIZE_RANGE);
            this._minPointSize = r[0],
            this._maxPointSize = r[1];
            const a = u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT)
              , i = u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT);
            this._highpPrecision = a && i ? Math.min(a.precision, i.precision) : 0,
            2048 < this._maxPointSize && (this._maxPointSize = 2048),
            this._extensions = u.getSupportedExtensions();
            const n = u.getExtension('WEBGL_debug_renderer_info');
            n && (this._unmaskedVendor = u.getParameter(n.UNMASKED_VENDOR_WEBGL),
            this._unmaskedRenderer = u.getParameter(n.UNMASKED_RENDERER_WEBGL)),
            this._parallelShaderCompileExt = u.getExtension('KHR_parallel_shader_compile'),
            C3.isDebug && (G = u.getExtension('WEBGL_lose_context')),
            this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? ('Chromium' !== C3.Platform.BrowserEngine || 81 <= C3.Platform.BrowserVersionNumber || 'undefined' != typeof document) && (this._timerExt = u.getExtension('EXT_disjoint_timer_query')) : this._timerExt = u.getExtension('EXT_disjoint_timer_query_webgl2') || u.getExtension('EXT_disjoint_timer_query')),
            this._ClearAllShaderPrograms();
            const _ = C3.Gfx.WebGLShaderProgram
              , l = _.GetDefaultVertexShaderSource(this._is3d, !1)
              , c = [[_.GetTextureFillFragmentShaderSource(), l, '<default>'], [_.GetTextureFillFragmentShaderSource(), l, '<default-device-transform>'], [_.GetPointFragmentShaderSource(), _.GetPointVertexShaderSource(), '<point>'], [_.GetColorFillFragmentShaderSource(), l, '<fill>'], [_.GetLinearGradientFillFragmentShaderSource(), l, '<lineargradient>'], [_.GetHardEllipseFillFragmentShaderSource(), l, '<hardellipse>'], [_.GetHardEllipseOutlineFragmentShaderSource(), l, '<hardellipseoutline>'], [_.GetSmoothEllipseFillFragmentShaderSource(), l, '<smoothellipse>'], [_.GetSmoothEllipseOutlineFragmentShaderSource(), l, '<smoothellipseoutline>'], [_.GetSmoothLineFillFragmentShaderSource(), l, '<smoothline>'], [_.GetTilemapFragmentShaderSource(), _.GetDefaultVertexShaderSource(this._is3d, !0), '<tilemap>']]
              , g = await Promise.all(c.map(t=>this.CreateShaderProgram({
                src: t[0]
            }, t[1], t[2])));
            this._spTextureFill = g[0],
            this._spDeviceTransformTextureFill = g[1],
            this._spPoints = g[2],
            this._spColorFill = g[3],
            this._spLinearGradientFill = g[4],
            this._spHardEllipseFill = g[5],
            this._spHardEllipseOutline = g[6],
            this._spSmoothEllipseFill = g[7],
            this._spSmoothEllipseOutline = g[8],
            this._spSmoothLineFill = g[9],
            this._spTilemapFill = g[10],
            this._currentStateGroup = null,
            this.SetTextureFillMode()
        }
        Is3D() {
            return this._is3d
        }
        GetNumVertexComponents() {
            return this._is3d ? 3 : 2
        }
        SetBaseZ(t) {
            this._baseZ = t
        }
        GetBaseZ() {
            return this._baseZ
        }
        SetCurrentZ(t) {
            this._currentZ = t,
            this._currentStateGroup = null
        }
        GetCurrentZ() {
            return this._currentZ
        }
        async CreateShaderProgram(n, e, t) {
            const r = await C3.Gfx.WebGLShaderProgram.Create(this, n, e, t);
            return this._AddShaderProgram(r),
            r
        }
        ResetLastProgram() {
            this._lastProgram = null
        }
        SetSize(l, e, t) {
            if (this._width !== l || this._height !== e || t) {
                this.EndBatch();
                const t = this._gl
                  , r = this._batchState;
                this._width = l,
                this._height = e;
                const a = this.GetScissoredViewportWidth()
                  , i = this.GetScissoredViewportHeight();
                this._UpdateViewportRenderer(a, i, this._width, this._height),
                this._UpdateViewportBatch(a, i, this._matP),
                this._spDeviceTransformTextureFill && (t.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()),
                this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP),
                this._lastProgram = this._spDeviceTransformTextureFill,
                this._batchState.currentShader = this._spDeviceTransformTextureFill),
                t.bindTexture(t.TEXTURE_2D, null),
                t.activeTexture(t.TEXTURE1),
                t.bindTexture(t.TEXTURE_2D, null),
                t.activeTexture(t.TEXTURE0),
                this._lastTexture0 = null,
                this._lastTexture1 = null,
                this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height),
                t.bindFramebuffer(t.FRAMEBUFFER, null),
                this._currentRenderTarget = null,
                r.currentFramebuffer = null
            }
        }
        _UpdateViewportRenderer(l, e, t, r) {
            this._cam[2] = 100,
            mat4.lookAt(this._matMV, this._cam, this._look, this._up),
            mat4.perspective(this._matP, 45, l / e, this.GetNearZ(), this.GetFarZ());
            const a = [0, 0]
              , i = [0, 0]
              , n = self.devicePixelRatio;
            this.Project(0, 0, l, e, a),
            this.Project(1, 1, l, e, i),
            this._worldScale[0] = n / (i[0] - a[0]),
            this._worldScale[1] = -n / (i[1] - a[1]),
            this._lastBackbufferWidth = t,
            this._lastBackbufferHeight = r
        }
        _UpdateViewportBatch(l, e, t) {
            const r = this._gl
              , a = this._batchState;
            r.viewport(0, 0, l, e);
            const d = this._allShaderPrograms
              , n = a.currentShader;
            for (let r = 0, a = d.length; r < a; ++r) {
                const a = d[r];
                a === n ? a.UpdateMatP(t, !0) : a.SetMatPStale()
            }
            mat4.copy(a.currentMatP, t)
        }
        SetViewportScissor(a, e) {
            const t = this._gl;
            return this._width === a && this._height === e ? void (this._isScissorViewport && (this.EndBatch(),
            t.disable(t.SCISSOR_TEST),
            this._isScissorViewport = !1,
            this._viewportScissorWidth = -1,
            this._viewportScissorHeight = -1,
            this.SetSize(this._width, this._height, !0))) : void (!this._isScissorViewport && (this.EndBatch(),
            t.enable(t.SCISSOR_TEST),
            this._isScissorViewport = !0),
            (this._viewportScissorWidth !== a || this._viewportScissorHeight !== e) && (this.EndBatch(),
            t.scissor(0, 0, a, e),
            this._viewportScissorWidth = a,
            this._viewportScissorHeight = e,
            this.SetSize(this._width, this._height, !0)))
        }
        RemoveViewportScissor() {
            const t = this._gl;
            this._isScissorViewport && (this.EndBatch(),
            t.disable(t.SCISSOR_TEST),
            this._isScissorViewport = !1),
            this._viewportScissorWidth = -1,
            this._viewportScissorHeight = -1
        }
        GetScissoredViewportWidth() {
            return this._isScissorViewport ? this._viewportScissorWidth : this.GetWidth()
        }
        GetScissoredViewportHeight() {
            return this._isScissorViewport ? this._viewportScissorHeight : this.GetHeight()
        }
        UpdateModelView() {
            if (!g(this._lastMV, this._matMV)) {
                const t = this.PushBatch();
                t.InitUpdateModelView(this._matMV),
                mat4.copy(this._lastMV, this._matMV),
                this._topOfBatch = 0
            }
        }
        GetBatchState() {
            return this._batchState
        }
        PushBatch() {
            const t = this._batch;
            return this._batchPtr === t.length && t.push(new C3.Gfx.WebGLBatchJob(this._batchState)),
            t[this._batchPtr++]
        }
        EndBatch() {
            0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(),
            this._ExecuteBatch(),
            this._batchPtr = 0,
            this._vertexPtr = 0,
            this._texPtr = 0,
            this._pointPtr = 0,
            this._topOfBatch = 0)
        }
        _WriteBuffers() {
            const t = this._gl;
            0 < this._pointPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))),
            0 < this._vertexPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)),
            t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
        }
        _ExecuteBatch() {
            const a = this._batch;
            for (let e = 0, t = this._batchPtr; e < t; ++e)
                a[e].Run()
        }
        GetOpacity() {
            return this._lastColor.getA()
        }
        SetColorRgba(l, e, t, r) {
            const i = this._lastColor;
            if (!i.equalsRgba(l, e, t, r)) {
                i.setRgba(l, e, t, r);
                const a = this.PushBatch();
                a.InitSetColor(i),
                this._topOfBatch = 0,
                this._currentStateGroup = null
            }
        }
        SetOpacity(a) {
            const e = this._lastColor;
            if (e.getA() !== a) {
                e.setA(a);
                const t = this.PushBatch();
                t.InitSetColor(e),
                this._topOfBatch = 0,
                this._currentStateGroup = null
            }
        }
        SetColor(a) {
            const e = this._lastColor;
            if (!e.equals(a)) {
                e.set(a);
                const t = this.PushBatch();
                t.InitSetColor(e),
                this._topOfBatch = 0,
                this._currentStateGroup = null
            }
        }
        ResetColor() {
            this.SetColorRgba(1, 1, 1, 1)
        }
        GetColor() {
            return this._lastColor
        }
        SetTexture(a) {
            if (a !== this._lastTexture0) {
                const e = this.PushBatch();
                e.InitSetTexture(a),
                this._lastTexture0 = a,
                this._topOfBatch = 0
            }
        }
        _ResetLastTexture() {
            this._lastTexture0 = null
        }
        SetBlend(a, e) {
            if (a !== this._lastSrcBlend || e !== this._lastDestBlend) {
                const t = this.PushBatch();
                t.InitSetBlend(a, e),
                this._lastSrcBlend = a,
                this._lastDestBlend = e,
                this._topOfBatch = 0,
                this._currentStateGroup = null
            }
        }
        IsPremultipliedAlphaBlend() {
            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
        }
        SetAlphaBlend() {
            this.SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetNoPremultiplyAlphaBlend() {
            this.SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetCopyBlend() {
            this.SetBlend(this._gl.ONE, this._gl.ZERO)
        }
        Rect(t) {
            this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom())
        }
        Rect2(n, e, t, r) {
            this.Quad2(n, e, t, e, t, r, n, r)
        }
        _ExtendQuadBatch() {
            let a = this._vertexPtr;
            if (a >= this._lastVertexPtr && (this.EndBatch(),
            a = 0),
            1 === this._topOfBatch)
                this._batch[this._batchPtr - 1]._indexCount += 6;
            else {
                const e = this.PushBatch();
                e.InitQuad(this._is3d ? a : 3 * (a / 2), 6),
                this._topOfBatch = 1
            }
        }
        _WriteQuadToVertexBuffer(t) {
            t.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ),
            this._vertexPtr += 12
        }
        Quad(t) {
            this._ExtendQuadBatch(),
            this._WriteQuadToVertexBuffer(t),
            f.writeToTypedArray(this._texcoordData, this._texPtr),
            this._texPtr += 8
        }
        Quad2(n, e, t, r, a, i, _, l) {
            this._ExtendQuadBatch();
            const c = this._vertexData;
            let g = this._vertexPtr;
            const m = this._baseZ + this._currentZ;
            this._is3d ? (c[g++] = n,
            c[g++] = e,
            c[g++] = m,
            c[g++] = t,
            c[g++] = r,
            c[g++] = m,
            c[g++] = a,
            c[g++] = i,
            c[g++] = m,
            c[g++] = _,
            c[g++] = l,
            c[g++] = m) : (c[g++] = n,
            c[g++] = e,
            c[g++] = t,
            c[g++] = r,
            c[g++] = a,
            c[g++] = i,
            c[g++] = _,
            c[g++] = l),
            this._vertexPtr = g,
            f.writeToTypedArray(this._texcoordData, this._texPtr),
            this._texPtr += 8
        }
        Quad3(a, e) {
            this._ExtendQuadBatch(),
            this._WriteQuadToVertexBuffer(a),
            e.writeAsQuadToTypedArray(this._texcoordData, this._texPtr),
            this._texPtr += 8
        }
        Quad4(a, e) {
            this._ExtendQuadBatch(),
            this._WriteQuadToVertexBuffer(a),
            e.writeToTypedArray(this._texcoordData, this._texPtr),
            this._texPtr += 8
        }
        FullscreenQuad(_, d) {
            var t = Math.max
              , r = Math.min;
            if (mat4.copy(l, this._lastMV),
            vec3.copy(n, this._cam),
            vec3.copy(i, this._look),
            this._cam[0] = 0,
            this._cam[1] = 0,
            this._cam[2] = 100 * self.devicePixelRatio,
            this._look[0] = 0,
            this._look[1] = 0,
            this._look[2] = 0,
            this.ResetModelView(),
            this.UpdateModelView(),
            this._isScissorViewport) {
                const a = this._viewportScissorWidth / 2
                  , e = this._viewportScissorHeight / 2;
                y.set(-a, e, -a + this._viewportScissorWidth, e - this._viewportScissorHeight),
                S.setFromRect(y),
                y.set(0, 0, this._viewportScissorWidth / this._width, this._viewportScissorHeight / this._height),
                this.Quad3(S, y)
            } else if ('crop' === _ && this._currentRenderTarget && d) {
                const a = this._width / 2
                  , e = this._height / 2
                  , i = d.GetWidth()
                  , n = d.GetHeight()
                  , _ = this._currentRenderTarget.GetWidth()
                  , l = this._currentRenderTarget.GetHeight()
                  , g = r(_, i)
                  , u = r(l, n)
                  , c = t(n - l, 0)
                  , m = t(l - n, 0);
                y.set(-a, e - m, -a + g, e - u - m),
                S.setFromRect(y),
                y.set(0, c, g, u + c),
                y.divide(i, n),
                this.Quad3(S, y)
            } else {
                let[n,e] = this.GetRenderTargetSize(this._currentRenderTarget);
                const t = n / 2
                  , r = e / 2;
                this.Rect2(-t, r, t, -r)
            }
            mat4.copy(this._matMV, l),
            vec3.copy(this._cam, n),
            vec3.copy(this._look, i),
            this.UpdateModelView()
        }
        ConvexPoly(d) {
            const e = d.length / 2;
            if (3 > e)
                throw new Error('need at least 3 points');
            const u = e - 2
              , c = d[0]
              , a = d[1];
            for (let e = 0; e < u; e += 2) {
                const n = 2 * e
                  , i = d[n + 2]
                  , _ = d[n + 3]
                  , l = d[n + 4]
                  , g = d[n + 5];
                if (e == u - 1)
                    this.Quad2(c, a, i, _, l, g, l, g);
                else {
                    const e = d[n + 6]
                      , t = d[n + 7];
                    this.Quad2(c, a, i, _, l, g, e, t)
                }
            }
        }
        Line(u, e, t, r) {
            const i = C3.angleTo(u, e, t, r)
              , n = Math.sin(i)
              , a = Math.cos(i)
              , _ = .5 * this._lineWidth
              , l = n * _
              , c = a * _
              , g = this._lineCap;
            2 === g ? this.LinePreCalc_LineCap2(u, e, t, r, l, c) : 1 === g ? this.LinePreCalc_LineCap1(u, e, t, r, l, c) : this.LinePreCalc_LineCap0(u, e, t, r, l, c)
        }
        LinePreCalc_LineCap2(g, e, t, r, a, i) {
            const n = this._lineOffset
              , _ = g + n - i
              , l = e + n - a
              , m = t + n + i
              , p = r + n + a
              , d = 2 * i
              , u = 2 * a;
            this.Quad2(_ + a, l - i, m + a, p - i, m - a - d, p + i - u, _ - a + d, l + i + u)
        }
        LinePreCalc_LineCap1(u, e, t, r, a, i) {
            const n = this._lineOffset
              , _ = u + n - i
              , l = e + n - a
              , c = t + n + i
              , g = r + n + a;
            this.Quad2(_ + a, l - i, c + a, g - i, c - a, g + i, _ - a, l + i)
        }
        LinePreCalc_LineCap0(u, e, t, r, a, i) {
            const n = this._lineOffset
              , _ = u + n
              , l = e + n
              , c = t + n
              , g = r + n;
            this.Quad2(_ + a, l - i, c + a, g - i, c - a, g + i, _ - a, l + i)
        }
        TexturedLine(g, e, t, r, i, n) {
            const _ = C3.angleTo(g, e, t, r)
              , l = Math.sin(_)
              , a = Math.cos(_)
              , m = .5 * this._lineWidth
              , p = l * m
              , d = a * m
              , u = this._lineCap;
            2 === u ? this.TexturedLinePreCalc_LineCap2(g, e, t, r, p, d, i, n) : 1 === u ? this.TexturedLinePreCalc_LineCap1(g, e, t, r, p, d, i, n) : this.TexturedLinePreCalc_LineCap0(g, e, t, r, p, d, i, n)
        }
        TexturedLinePreCalc_LineCap2(d, e, t, r, a, i, n, _) {
            const l = this._lineOffset
              , m = d + l - i
              , u = e + l - a
              , c = t + l + i
              , p = r + l + a
              , f = 2 * i
              , h = 2 * a;
            S.set(m + a, u - i, c + a, p - i, c - a - f, p + i - h, m - a + f, u + i + h),
            y.set(n, 0, _, 0),
            this.Quad3(S, y)
        }
        TexturedLinePreCalc_LineCap1(d, e, t, r, a, i, n, _) {
            const l = this._lineOffset
              , g = d + l - i
              , u = e + l - a
              , c = t + l + i
              , m = r + l + a;
            S.set(g + a, u - i, c + a, m - i, c - a, m + i, g - a, u + i),
            y.set(n, 0, _, 0),
            this.Quad3(S, y)
        }
        TexturedLinePreCalc_LineCap0(d, e, t, r, a, i, n, _) {
            const l = this._lineOffset
              , g = d + l
              , u = e + l
              , c = t + l
              , m = r + l;
            S.set(g + a, u - i, c + a, m - i, c - a, m + i, g - a, u + i),
            y.set(n, 0, _, 0),
            this.Quad3(S, y)
        }
        LineRect(l, e, t, r) {
            const a = .5 * this._lineWidth
              , i = this._lineCap;
            2 === i ? this._LineRectPreCalc_LineCap2(l, e, t, r, a) : 1 === i ? this._LineRectPreCalc_LineCap1(l, e, t, r, a) : this._LineRectPreCalc_LineCap0(l, e, t, r, a)
        }
        _LineRectPreCalc_LineCap2(n, e, t, r, a) {
            this.LinePreCalc_LineCap2(n, e, t, e, 0, a),
            this.LinePreCalc_LineCap2(t, e, t, r, a, 0),
            this.LinePreCalc_LineCap2(t, r, n, r, 0, -a),
            this.LinePreCalc_LineCap2(n, r, n, e, -a, 0)
        }
        _LineRectPreCalc_LineCap1(n, e, t, r, a) {
            this.LinePreCalc_LineCap1(n, e, t, e, 0, a),
            this.LinePreCalc_LineCap1(t, e, t, r, a, 0),
            this.LinePreCalc_LineCap1(t, r, n, r, 0, -a),
            this.LinePreCalc_LineCap1(n, r, n, e, -a, 0)
        }
        _LineRectPreCalc_LineCap0(n, e, t, r, a) {
            this.LinePreCalc_LineCap0(n, e, t, e, 0, a),
            this.LinePreCalc_LineCap0(t, e, t, r, a, 0),
            this.LinePreCalc_LineCap0(t, r, n, r, 0, -a),
            this.LinePreCalc_LineCap0(n, r, n, e, -a, 0)
        }
        LineRect2(t) {
            this.LineRect(t.getLeft(), t.getTop(), t.getRight(), t.getBottom())
        }
        LineQuad(d) {
            const e = C3.angleTo(d.getTlx(), d.getTly(), d.getTrx(), d.getTry())
              , t = Math.sin(e)
              , r = Math.cos(e)
              , a = .5 * this._lineWidth
              , i = t * a
              , n = r * a
              , _ = this._lineCap;
            2 === _ ? this._LineQuadPreCalc_LineCap2(d, i, n) : 1 === _ ? this._LineQuadPreCalc_LineCap1(d, i, n) : this._LineQuadPreCalc_LineCap0(d, i, n)
        }
        _LineQuadPreCalc_LineCap2(a, e, t) {
            this.LinePreCalc_LineCap2(a.getTlx(), a.getTly(), a.getTrx(), a.getTry(), e, t),
            this.LinePreCalc_LineCap2(a.getTrx(), a.getTry(), a.getBrx(), a.getBry(), t, -e),
            this.LinePreCalc_LineCap2(a.getBrx(), a.getBry(), a.getBlx(), a.getBly(), -e, -t),
            this.LinePreCalc_LineCap2(a.getBlx(), a.getBly(), a.getTlx(), a.getTly(), -t, e)
        }
        _LineQuadPreCalc_LineCap1(a, e, t) {
            this.LinePreCalc_LineCap1(a.getTlx(), a.getTly(), a.getTrx(), a.getTry(), e, t),
            this.LinePreCalc_LineCap1(a.getTrx(), a.getTry(), a.getBrx(), a.getBry(), t, -e),
            this.LinePreCalc_LineCap1(a.getBrx(), a.getBry(), a.getBlx(), a.getBly(), -e, -t),
            this.LinePreCalc_LineCap1(a.getBlx(), a.getBly(), a.getTlx(), a.getTly(), -t, e)
        }
        _LineQuadPreCalc_LineCap0(a, e, t) {
            this.LinePreCalc_LineCap0(a.getTlx(), a.getTly(), a.getTrx(), a.getTry(), e, t),
            this.LinePreCalc_LineCap0(a.getTrx(), a.getTry(), a.getBrx(), a.getBry(), t, -e),
            this.LinePreCalc_LineCap0(a.getBrx(), a.getBry(), a.getBlx(), a.getBly(), -e, -t),
            this.LinePreCalc_LineCap0(a.getBlx(), a.getBly(), a.getTlx(), a.getTly(), -t, e)
        }
        SetLineWidth(t) {
            this._lineWidth = t,
            this._lineWidthStack[this._lineWidthStack.length - 1] = t
        }
        GetLineWidth() {
            return this._lineWidth
        }
        PushLineWidth(t) {
            if (100 <= this._lineWidthStack.length)
                throw new Error('pushed too many line widths - check push/pop pairs');
            this._lineWidthStack.push(t),
            this._lineWidth = t
        }
        PopLineWidth() {
            if (1 >= this._lineWidthStack.length)
                throw new Error('cannot pop last line width - check push/pop pairs');
            this._lineWidthStack.pop(),
            this._lineWidth = this._lineWidthStack[this._lineWidthStack.length - 1]
        }
        SetLineCapButt() {
            this._lineCap = 0,
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapSquare() {
            this._lineCap = 1,
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapZag() {
            this._lineCap = 2,
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        PushLineCap(t) {
            if ('butt' === t)
                this.PushLineCapButt();
            else if ('square' === t)
                this.PushLineCapSquare();
            else if ('zag' === t)
                this.PushLineCapZag();
            else
                throw new Error('invalid line cap')
        }
        PushLineCapButt() {
            if (100 <= this._lineCapStack.length)
                throw new Error('pushed too many line caps - check push/pop pairs');
            this._lineCapStack.push(0),
            this._lineCap = 0
        }
        PushLineCapSquare() {
            if (100 <= this._lineCapStack.length)
                throw new Error('pushed too many line caps - check push/pop pairs');
            this._lineCapStack.push(1),
            this._lineCap = 1
        }
        PushLineCapZag() {
            if (100 <= this._lineCapStack.length)
                throw new Error('pushed too many line caps - check push/pop pairs');
            this._lineCapStack.push(2),
            this._lineCap = 2
        }
        PopLineCap() {
            if (1 >= this._lineCapStack.length)
                throw new Error('cannot pop last line cap - check push/pop pairs');
            this._lineCapStack.pop(),
            this._lineCap = this._lineCapStack[this._lineCapStack.length - 1]
        }
        SetLineOffset(t) {
            this._lineOffset = t,
            this._lineOffsetStack[this._lineOffsetStack.length - 1] = t
        }
        GetLineOffset() {
            return this._lineOffset
        }
        PushLineOffset(t) {
            if (100 <= this._lineOffsetStack.length)
                throw new Error('pushed too many line offsets - check push/pop pairs');
            this._lineOffsetStack.push(t),
            this._lineOffset = t
        }
        PopLineOffset() {
            if (1 >= this._lineOffsetStack.length)
                throw new Error('cannot pop last line offset - check push/pop pairs');
            this._lineOffsetStack.pop(),
            this._lineOffset = this._lineOffsetStack[this._lineOffsetStack.length - 1]
        }
        SetPointTextureCoords(a) {
            if (!this._lastPointTexCoords.equals(a)) {
                this._lastPointTexCoords.copy(a);
                const e = this.PushBatch();
                e.InitSetPointTexCoords(a),
                this._topOfBatch = 0
            }
        }
        Point(l, e, t, r) {
            7996 <= this._pointPtr && this.EndBatch();
            let a = this._pointPtr;
            const d = this._baseZ + this._currentZ;
            if (2 === this._topOfBatch && this._lastPointZ === d)
                this._batch[this._batchPtr - 1]._indexCount++;
            else {
                const t = this.PushBatch();
                t.InitPoints(a, d),
                this._topOfBatch = 2,
                this._lastPointZ = d
            }
            const n = this._pointData;
            n[a++] = l,
            n[a++] = e,
            n[a++] = t,
            n[a++] = r,
            this._pointPtr = a
        }
        SetProgram(a) {
            if (this._lastProgram !== a) {
                const e = this.PushBatch();
                e.InitSetProgram(a),
                this._lastProgram = a,
                this._topOfBatch = 0,
                this._currentStateGroup = null
            }
        }
        SetTextureFillMode() {
            this.SetProgram(this._spTextureFill)
        }
        SetDeviceTransformTextureFillMode() {
            this.SetProgram(this._spDeviceTransformTextureFill)
        }
        SetColorFillMode() {
            this.SetProgram(this._spColorFill)
        }
        SetLinearGradientFillMode() {
            this.SetProgram(this._spLinearGradientFill)
        }
        SetGradientColor(a) {
            const e = this.PushBatch();
            e.InitSetGradientColor(a),
            this._topOfBatch = 0
        }
        SetHardEllipseFillMode() {
            this.SetProgram(this._spHardEllipseFill)
        }
        SetHardEllipseOutlineMode() {
            this.SetProgram(this._spHardEllipseOutline)
        }
        SetSmoothEllipseFillMode() {
            this.SetProgram(this._spSmoothEllipseFill)
        }
        SetSmoothEllipseOutlineMode() {
            this.SetProgram(this._spSmoothEllipseOutline)
        }
        SetEllipseParams(n, e, t=1) {
            const r = this.PushBatch();
            r.InitSetEllipseParams(n, e, t),
            this._topOfBatch = 0
        }
        SetSmoothLineFillMode() {
            this.SetProgram(this._spSmoothLineFill)
        }
        SetTilemapFillMode() {
            this.SetProgram(this._spTilemapFill)
        }
        SetTilemapInfo(d, e, t, r, a, i, n) {
            if (this._lastProgram !== this._spTilemapFill)
                throw new Error('must set tilemap fill mode first');
            const _ = this.PushBatch();
            _.InitSetTilemapInfo(d, e, t, r, a, i, n),
            this._topOfBatch = 0
        }
        SetProgramParameters(g, e, t, r, a, i, n, _, l, m, d) {
            const h = this._lastProgram
              , u = h._hasAnyOptionalUniforms
              , c = !!d.length;
            if (u && !h.AreOptionalUniformsAlreadySetInBatch(e, t, r, a, i, n, _, l, m) || c && !h.AreCustomParametersAlreadySetInBatch(d)) {
                const S = this.PushBatch();
                if (S.InitSetProgramParameters(),
                u) {
                    h.SetOptionalUniformsInBatch(e, t, r, a, i, n, _, l, m);
                    const d = S._mat4param;
                    d[0] = i,
                    d[1] = n,
                    e.writeToTypedArray(d, 2),
                    d[6] = _,
                    d[7] = l,
                    t.writeToTypedArray(d, 12);
                    const c = S._colorParam;
                    a.writeToTypedArray(c, 0);
                    const u = c[1];
                    c[1] = c[3],
                    c[3] = u,
                    r.writeToTypedArray(S._srcOriginRect, 0),
                    S._startIndex = m,
                    S._texParam = h._uSamplerBack.IsUsed() ? g ? g.GetTexture() : null : null
                }
                c && (h.SetCustomParametersInBatch(d),
                C3.shallowAssignArray(S._shaderParams, d)),
                this._topOfBatch = 0
            }
        }
        ClearRgba(n, e, t, r) {
            const i = this.PushBatch();
            i.InitClearSurface2(n, e, t, r),
            this._topOfBatch = 0
        }
        Clear(a) {
            const e = this.PushBatch();
            e.InitClearSurface(a),
            this._topOfBatch = 0
        }
        ClearRect(n, e, t, r) {
            this.ClearRect4(n, e, t, r, 0, 0, 0, 0)
        }
        ClearRect2(t) {
            this.ClearRect4(t.getLeft(), t.getTop(), t.width(), t.height(), 0, 0, 0, 0)
        }
        ClearRect3(a, e) {
            this.ClearRect4(a.getLeft(), a.getTop(), a.width(), a.height(), e.getR(), e.getG(), e.getB(), e.getA())
        }
        ClearRect4(d, e, t, i, n, _, r, l) {
            if (!(0 > t || 0 > i)) {
                const u = this.PushBatch();
                u.InitClearRect(d, e, t, i, n, _, r, l),
                this._topOfBatch = 0
            }
        }
        Start() {}
        Finish() {
            super.Finish(),
            this._gl.flush()
        }
        CheckForQueryResults() {
            for (const t of this._allQueryResultBuffers)
                t.CheckForResults(this._frameNumber)
        }
        IsContextLost() {
            return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
        }
        OnContextLost() {
            C3.Gfx.WebGLRendererTexture.OnContextLost(),
            C3.Gfx.WebGLRenderTarget.OnContextLost(),
            C3.Gfx.WebGLText.OnContextLost();
            for (const t of this._allQueryResultBuffers)
                t.Clear();
            this._extensions = [],
            this._timerExt = null,
            this._parallelShaderCompileExt = null,
            this._unmaskedVendor = '(unavailable)',
            this._unmaskedRenderer = '(unavailable)',
            this._lastProgram = null,
            this._spTextureFill = null,
            this._spDeviceTransformTextureFill = null,
            this._spColorFill = null,
            this._spLinearGradientFill = null,
            this._spHardEllipseFill = null,
            this._spHardEllipseOutline = null,
            this._spSmoothEllipseFill = null,
            this._spSmoothEllipseOutline = null,
            this._spSmoothLineFill = null,
            this._spPoints = null,
            this._spTilemapFill = null;
            for (const t of this._stateGroups.values())
                t.OnContextLost();
            for (const t of this._allShaderPrograms)
                t.Release();
            this._ClearAllShaderPrograms()
        }
        async OnContextRestored() {
            this._isInitialisingAfterContextRestored = !0,
            await this.InitState(),
            this._isInitialisingAfterContextRestored = !1;
            for (const t of this._stateGroups.values())
                t.OnContextRestored(this);
            this.SetSize(this._width, this._height, !0)
        }
        CreateStaticTexture(a, e) {
            if (this.IsContextLost())
                throw new Error('context lost');
            this.EndBatch();
            const t = C3.New(C3.Gfx.WebGLRendererTexture, this);
            return t._CreateStatic(a, e),
            t
        }
        CreateStaticTextureAsync(a, n) {
            return this.IsContextLost() ? Promise.reject('context lost') : (
                n = Object.assign({}, n),
                C3.Supports.ImageBitmapOptions && (this.SupportsNPOTTextures() || !n.isTiled) ? (
                    n.premultiplyAlpha = !1,
                    createImageBitmap(a, {
                        premultiplyAlpha: 'premultiply'
                    }).then(t=>C3.Asyncify(()=>this.CreateStaticTexture(t, n)))
                ) : C3.Supports.ImageBitmap ? 
                    createImageBitmap(a).then(t=>C3.Asyncify(()=>this.CreateStaticTexture(t, n))) : 
                    a instanceof Blob ? 
                        C3.BlobToImage(a, !0).then(t=>this.CreateStaticTextureAsync(t, n)) : 
                        'undefined' != typeof HTMLImageElement && a instanceof HTMLImageElement && 'function' == typeof a.decode ? 
                            a.decode().then(()=>C3.Asyncify(()=>this.CreateStaticTexture(a, n))) : 
                            C3.Asyncify(()=>this.CreateStaticTexture(a, n))
			)
        }
        CreateDynamicTexture(n, e, t) {
            this.EndBatch();
            const r = C3.New(C3.Gfx.WebGLRendererTexture, this);
            return r._CreateDynamic(n, e, t),
            r
        }
        UpdateTexture(a, e, t) {
            this.EndBatch(),
            e._Update(a, t)
        }
        DeleteTexture(t) {
            t && (t.SubtractReference(),
            0 < t.GetReferenceCount() || (this.EndBatch(),
            t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            this._lastTexture0 = null),
            t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
            this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            this._gl.activeTexture(this._gl.TEXTURE0),
            this._lastTexture1 = null),
            t._Delete()))
        }
        CreateRenderTarget(n) {
            let e = this._width
              , l = this._height
              , _ = !0;
            if (n && ('number' == typeof n.width && (e = n.width,
            _ = !1),
            'number' == typeof n.height && (l = n.height,
            _ = !1)),
            0 >= e || 0 >= l)
                throw new Error('invalid size');
            this.EndBatch();
            const d = C3.New(C3.Gfx.WebGLRenderTarget, this);
            return d._Create(e, l, Object.assign({
                isDefaultSize: _
            }, n)),
            this._currentRenderTarget = null,
            this._batchState.currentFramebuffer = null,
            d
        }
        SetRenderTarget(l) {
            if (l === this._currentRenderTarget)
                return;
            let e, d, u, c;
            l ? (l.IsDefaultSize() && l._Resize(this._width, this._height),
            u = l.GetWidth(),
            c = l.GetHeight(),
            e = u,
            d = c) : (u = this._width,
            c = this._height,
            e = this.GetScissoredViewportWidth(),
            d = this.GetScissoredViewportHeight());
            const g = this._lastBackbufferWidth !== u || this._lastBackbufferHeight !== c;
            g && this._UpdateViewportRenderer(e, d, u, c);
            const n = this.PushBatch();
            n.InitSetRenderTarget(l, g, this._matP),
            this._currentRenderTarget = l,
            this._topOfBatch = 0
        }
        GetRenderTarget() {
            return this._currentRenderTarget
        }
        GetRenderTargetSize(t) {
            return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height]
        }
        CopyRenderTarget(a, e='stretch') {
            if (2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling())
                this.SetCopyBlend(),
                this.ResetColor(),
                this.DrawRenderTarget(a, e);
            else {
                const t = this.PushBatch();
                t.InitBlitFramebuffer(a, this._currentRenderTarget, e),
                this._topOfBatch = 0
            }
        }
        DrawRenderTarget(a, e='stretch') {
            const t = a.GetTexture();
            if (!t)
                throw new Error('not a texture-backed render target');
            this.SetTexture(t),
            this.FullscreenQuad(e, t)
        }
        InvalidateRenderTarget(a) {
            if (!(2 > this._version)) {
                const e = this.PushBatch();
                e.InitInvalidateFramebuffer(a._GetFramebuffer()),
                this._topOfBatch = 0
            }
        }
        DeleteRenderTarget(a) {
            this.SetRenderTarget(null),
            this.EndBatch();
            const e = a.GetTexture();
            e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            this._lastTexture0 = null),
            e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1),
            this._gl.bindTexture(this._gl.TEXTURE_2D, null),
            this._gl.activeTexture(this._gl.TEXTURE0),
            this._lastTexture1 = null),
            a._Delete()
        }
        async ReadBackRenderTargetToImageData(d, e) {
            this.EndBatch();
            const t = this._currentRenderTarget;
            let u, c, g;
            d ? (u = d.GetWidth(),
            c = d.GetHeight(),
            g = d._GetFramebuffer()) : (u = this.GetWidth(),
            c = this.GetHeight(),
            g = null);
            const m = this._gl;
            m.bindFramebuffer(m.FRAMEBUFFER, g);
            const _ = ()=>{
                m.bindFramebuffer(m.FRAMEBUFFER, null),
                this._currentRenderTarget = null,
                this._batchState.currentFramebuffer = null,
                this.SetRenderTarget(t)
            }
            ;
            let l;
            if (!e && 2 <= this.GetWebGLVersionNumber()) {
                m.bindFramebuffer(m.READ_FRAMEBUFFER, g);
                const a = m.createBuffer()
                  , e = 4 * (u * c)
                  , t = m.PIXEL_PACK_BUFFER;
                m.bindBuffer(t, a),
                m.bufferData(t, e, m.STREAM_READ),
                m.readPixels(0, 0, u, c, m.RGBA, m.UNSIGNED_BYTE, 0),
                m.bindFramebuffer(m.READ_FRAMEBUFFER, null),
                m.bindBuffer(t, null),
                _();
                const n = m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._WaitForObjectReady(()=>m.getSyncParameter(n, m.SYNC_STATUS) === m.SIGNALED),
                m.deleteSync(n),
                l = new ImageData(u,c),
                m.bindBuffer(t, a),
                m.getBufferSubData(t, 0, new Uint8Array(l.data.buffer), 0, e),
                m.bindBuffer(t, null),
                m.deleteBuffer(a)
            } else
                l = new ImageData(u,c),
                m.readPixels(0, 0, u, c, m.RGBA, m.UNSIGNED_BYTE, new Uint8Array(l.data.buffer)),
                _();
            return l
        }
        StartQuery(a) {
            if (this.SupportsGPUProfiling()) {
                const e = this.PushBatch();
                e.InitStartQuery(a),
                this._topOfBatch = 0
            }
        }
        EndQuery(a) {
            if (this.SupportsGPUProfiling()) {
                const e = this.PushBatch();
                e.InitEndQuery(a),
                this._topOfBatch = 0
            }
        }
        _WaitForObjectReady(a) {
            const e = new Promise(e=>_.add({
                resolve: e,
                checkFunc: a
            }));
            return -1 === t && (t = self.requestAnimationFrame(m)),
            e
        }
        IsDesynchronized() {
            return !!this._attribs.desynchronized
        }
        GetEstimatedBackBufferMemoryUsage() {
            return this._width * this._height * (this._attribs.alpha ? 4 : 3)
        }
        GetEstimatedRenderBufferMemoryUsage() {
            let t = 0;
            for (const e of C3.Gfx.WebGLRenderTarget.allRenderTargets())
                e.GetTexture() || (t += e.GetEstimatedMemoryUsage());
            return t
        }
        GetEstimatedTextureMemoryUsage() {
            let t = 0;
            for (const e of C3.Gfx.WebGLRendererTexture.allTextures())
                t += e.GetEstimatedMemoryUsage();
            return t
        }
        GetEstimatedTotalMemoryUsage() {
            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
        }
        GetWebGLVersionString() {
            return this._versionString
        }
        GetWebGLVersionNumber() {
            return this._version
        }
        SupportsNPOTTextures() {
            return 2 <= this.GetWebGLVersionNumber()
        }
        GetMaxTextureSize() {
            return this._maxTextureSize
        }
        GetMinPointSize() {
            return this._minPointSize
        }
        GetMaxPointSize() {
            return this._maxPointSize
        }
        SupportsHighP() {
            return 0 !== this._highpPrecision
        }
        GetHighPPrecision() {
            return this._highpPrecision
        }
        GetUnmaskedVendor() {
            return this._unmaskedVendor
        }
        GetUnmaskedRenderer() {
            return this._unmaskedRenderer
        }
        GetExtensions() {
            return this._extensions
        }
        HasMajorPerformanceCaveat() {
            return this._hasMajorPerformanceCaveat
        }
        SupportsGPUProfiling() {
            return !!this._timerExt
        }
        _GetDisjointTimerQueryExtension() {
            return this._timerExt
        }
        _GetParallelShaderCompileExtension() {
            return this._parallelShaderCompileExt
        }
        _AddQueryResultBuffer(t) {
            this._allQueryResultBuffers.add(t)
        }
        _RemoveQueryResultBuffer(t) {
            this._allQueryResultBuffers.delete(t)
        }
        _GetTimeQueryStack() {
            return this._timeQueryStack
        }
        GetContext() {
            return this._gl
        }
        _InitBlendModes(t) {
            this._InitBlendModeData([['normal', t.ONE, t.ONE_MINUS_SRC_ALPHA], ['additive', t.ONE, t.ONE], ['xor', t.ONE, t.ONE_MINUS_SRC_ALPHA], ['copy', t.ONE, t.ZERO], ['destination-over', t.ONE_MINUS_DST_ALPHA, t.ONE], ['source-in', t.DST_ALPHA, t.ZERO], ['destination-in', t.ZERO, t.SRC_ALPHA], ['source-out', t.ONE_MINUS_DST_ALPHA, t.ZERO], ['destination-out', t.ZERO, t.ONE_MINUS_SRC_ALPHA], ['source-atop', t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], ['destination-atop', t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]])
        }
        CreateWebGLText() {
            return C3.New(C3.Gfx.WebGLText, this)
        }
    }
}
{
    function e(e) {
        if (!e)
            return '';
        const t = e.split('.');
        if (2 > t.length)
            return '';
        const a = t[t.length - 1].toLowerCase();
        return r.get(a) || ''
    }
    function t(e) {
        return new Promise((t,a)=>{
            const n = document.createElement('script');
            n.onload = t,
            n.onerror = a,
            n.async = !1,
            n.src = e,
            document.head.appendChild(n)
        }
        )
    }
    const n = new Set(['local', 'remote'])
      , r = new Map([['mp4', 'video/mp4'], ['webm', 'video/webm'], ['m4a', 'audio/mp4'], ['mp3', 'audio/mpeg'], ['js', 'application/javascript'], ['wasm', 'application/wasm'], ['svg', 'image/svg+xml']]);
    C3.AssetManager = class extends C3.DefendedBase {
        constructor(e, t) {
            if (super(),
            !n.has(t.defaultLoadPolicy))
                throw new Error('invalid load policy');
            if (this._runtime = e,
            this._localUrlBlobs = new Map,
            this._localBlobUrlCache = new Map,
            this._isCordova = !!t.isCordova,
            this._isiOSCordova = !!t.isiOSCordova,
            this._supportedAudioFormats = t.supportedAudioFormats || {},
            this._audioFiles = new Map,
            this._preloadSounds = !1,
            this._mediaSubfolder = '',
            this._fontsSubfolder = '',
            this._iconsSubfolder = '',
            this._defaultLoadPolicy = t.defaultLoadPolicy,
            this._allAssets = [],
            this._assetsByUrl = new Map,
            this._webFonts = [],
            this._loadPromises = [],
            this._hasFinishedInitialLoad = !1,
            this._totalAssetSizeToLoad = 0,
            this._assetSizeLoaded = 0,
            this._lastLoadProgress = 0,
            this._hasHadErrorLoading = !1,
            this._loadingRateLimiter = C3.New(C3.RateLimiter, ()=>this._FireLoadingProgressEvent(), 50),
            this._promiseThrottle = new C3.PromiseThrottle(Math.max(C3.hardwareConcurrency, 8)),
            t.localUrlBlobs)
                for (const [e,a] of Object.entries(t.localUrlBlobs))
                    this._localUrlBlobs.set(e.toLowerCase(), a);
            this._iAssetManager = new IAssetManager(this)
        }
        Release() {
            this._localUrlBlobs.clear();
            for (const e of this._localBlobUrlCache.values())
                URL.revokeObjectURL(e);
            this._localBlobUrlCache.clear();
            for (const e of this._allAssets)
                e.Release();
            C3.clearArray(this._allAssets),
            this._assetsByUrl.clear(),
            C3.clearArray(this._loadPromises),
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        _SetMediaSubfolder(e) {
            this._mediaSubfolder = e
        }
        GetMediaSubfolder() {
            return this._mediaSubfolder
        }
        _SetFontsSubfolder(e) {
            this._fontsSubfolder = e
        }
        GetFontsSubfolder() {
            return this._fontsSubfolder
        }
        _SetIconsSubfolder(e) {
            this._iconsSubfolder = e
        }
        GetIconsSubfolder() {
            return this._iconsSubfolder
        }
        _HasLocalUrlBlob(e) {
            return this._localUrlBlobs.has(e.toLowerCase())
        }
        _GetLocalUrlBlob(e) {
            return this._localUrlBlobs.get(e.toLowerCase()) || null
        }
        GetLocalUrlAsBlobUrl(e) {
            const t = this._GetLocalUrlBlob(e);
            if (!t)
                return e;
            let a = this._localBlobUrlCache.get(t);
            return a || (a = URL.createObjectURL(t),
            this._localBlobUrlCache.set(t, a)),
            a
        }
        FetchBlob(e, t) {
            t = t || this._defaultLoadPolicy;
            const a = this._GetLocalUrlBlob(e);
            if (a)
                return Promise.resolve(a);
            if (C3.IsRelativeURL(e)) {
                const a = e.toLowerCase();
                return this._isCordova ? this.CordovaFetchLocalFileAsBlob(a) : 'local' === t ? this._promiseThrottle.Add(()=>C3.FetchBlob(a)) : C3.FetchBlob(a)
            }
            return C3.FetchBlob(e)
        }
        FetchArrayBuffer(e) {
            const t = this._GetLocalUrlBlob(e);
            if (t)
                return C3.BlobToArrayBuffer(t);
            if (C3.IsRelativeURL(e)) {
                const t = e.toLowerCase();
                return this._isCordova ? this.CordovaFetchLocalFileAsArrayBuffer(t) : 'local' === this._defaultLoadPolicy ? this._promiseThrottle.Add(()=>C3.FetchArrayBuffer(t)) : C3.FetchArrayBuffer(t)
            }
            return C3.FetchArrayBuffer(e)
        }
        FetchText(e) {
            const t = this._GetLocalUrlBlob(e);
            if (t)
                return C3.BlobToString(t);
            if (C3.IsRelativeURL(e)) {
                const t = e.toLowerCase();
                return this._isCordova ? this.CordovaFetchLocalFileAsText(t) : 'local' === this._defaultLoadPolicy ? this._promiseThrottle.Add(()=>C3.FetchText(t)) : C3.FetchText(t)
            }
            return C3.FetchText(e)
        }
        async FetchJson(e) {
            const t = await this.FetchText(e);
            return JSON.parse(t)
        }
        _CordovaFetchLocalFileAs(e, t) {
            return this._runtime.PostComponentMessageToDOMAsync('runtime', 'cordova-fetch-local-file', {
                filename: e,
                as: t
            })
        }
        CordovaFetchLocalFileAsText(e) {
            return this._CordovaFetchLocalFileAs(e, 'text')
        }
        async CordovaFetchLocalFileAsBlob(t) {
            const a = await this._CordovaFetchLocalFileAs(t, 'buffer')
              , n = e(t);
            return new Blob([a],{
                type: n
            })
        }
        async CordovaFetchLocalFileAsBlobURL(e) {
            e = e.toLowerCase();
            let t = this._localBlobUrlCache.get(e);
            if (t)
                return t;
            const n = await this.CordovaFetchLocalFileAsBlob(e);
            return t = URL.createObjectURL(n),
            this._localBlobUrlCache.set(e, t),
            t
        }
        CordovaFetchLocalFileAsArrayBuffer(e) {
            return this._CordovaFetchLocalFileAs(e, 'buffer')
        }
        GetMediaFileUrl(e) {
            return this._HasLocalUrlBlob(e) ? this.GetLocalUrlAsBlobUrl(e) : this._mediaSubfolder + e.toLowerCase()
        }
        GetProjectFileUrl(e, t='') {
            if (C3.IsAbsoluteURL(e)) {
                if (t)
                    throw new Error('cannot specify subfolder with remote URL');
                return Promise.resolve(e)
            }
            return this._HasLocalUrlBlob(e) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(e)) : this._isCordova ? this.CordovaFetchLocalFileAsBlobURL(t + e) : Promise.resolve(t + e.toLowerCase())
        }
        LoadProjectFileUrl(e) {
            return this.GetProjectFileUrl(e)
        }
        LoadImage(e) {
            if (e.loadPolicy && !n.has(e.loadPolicy))
                throw new Error('invalid load policy');
            let t = this._assetsByUrl.get(e.url);
            return t ? t : (t = C3.New(C3.ImageAsset, this, {
                url: e.url,
                size: e.size || 0,
                loadPolicy: e.loadPolicy || this._defaultLoadPolicy
            }),
            this._allAssets.push(t),
            this._assetsByUrl.set(t.GetURL(), t),
            this._hasFinishedInitialLoad || (
                this._totalAssetSizeToLoad += t.GetSize(),
                this._loadPromises.push(
                    t.Load().then(
                        ()=>this._AddLoadedSize(t.GetSize())
                    )
                )
            ),
            t)
        }
        async WaitForAllToLoad() {
            try {
                await Promise.all(this._loadPromises),
                this._lastLoadProgress = 1
            } catch (e) {
                console.error('Error loading: ', e),
                this._hasHadErrorLoading = !0,
                this._FireLoadingProgressEvent()
            }
        }
        SetInitialLoadFinished() {
            this._hasFinishedInitialLoad = !0
        }
        HasHadErrorLoading() {
            return this._hasHadErrorLoading
        }
        _AddLoadedSize(e) {
            this._assetSizeLoaded += e,
            this._loadingRateLimiter.Call()
        }
        _FireLoadingProgressEvent() {
            const e = C3.New(C3.Event, 'loadingprogress');
            this._lastLoadProgress = C3.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1),
            e.progress = this._lastLoadProgress,
            this._runtime.Dispatcher().dispatchEvent(e)
        }
        GetLoadProgress() {
            return this._lastLoadProgress
        }
        _SetWebFonts(e) {
            C3.shallowAssignArray(this._webFonts, e),
            this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
        }
        _LoadWebFonts() {
            if ('undefined' == typeof FontFace)
                return Promise.resolve();
            const e = [];
            for (const [t,a,n] of this._webFonts)
                this._totalAssetSizeToLoad += n,
                e.push(this._LoadWebFont(t, a).then(()=>this._AddLoadedSize(n)));
            return Promise.all(e)
        }
        async _LoadWebFont(e, t) {
            try {
                const a = await this.GetProjectFileUrl(t, this._fontsSubfolder)
                  , n = new FontFace(e,`url('${a}')`);
                this._runtime.IsInWorker() ? self.fonts.add(n) : document.fonts.add(n),
                await n.load()
            } catch (t) {
                console.warn(`[C3 runtime] Failed to load web font '${e}': `, t)
            }
        }
        IsAudioFormatSupported(e) {
            return !!this._supportedAudioFormats[e]
        }
        _SetAudioFiles(t, e) {
            this._preloadSounds = !!e;
            for (const [n,a,r] of t)
                this._audioFiles.set(n, {
                    fileName: n,
                    formats: a.map(e=>({
                        type: e[0],
                        fileExtension: e[1],
                        fullName: n + e[1],
                        fileSize: e[2]
                    })),
                    isMusic: r
                })
        }
        GetPreferredAudioFile(e) {
            const t = this._audioFiles.get(e.toLowerCase());
            if (!t)
                return null;
            let a = null;
            for (const n of t.formats)
                if (a || 'audio/webm; codecs=opus' !== n.type || (a = n),
                this.IsAudioFormatSupported(n.type))
                    return n;
            return a
        }
        GetProjectAudioFileUrl(e) {
            const t = this.GetPreferredAudioFile(e);
            return t ? {
                url: this.GetMediaFileUrl(t.fullName),
                type: t.type
            } : null
        }
        GetAudioToPreload() {
            if (this._preloadSounds) {
                const e = [];
                for (const t of this._audioFiles.values()) {
                    if (t.isMusic)
                        continue;
                    const a = this.GetPreferredAudioFile(t.fileName);
                    a && e.push({
                        originalUrl: t.fileName,
                        url: this.GetMediaFileUrl(a.fullName),
                        type: a.type,
                        fileSize: a.fileSize
                    })
                }
                return e
            }
            return []
        }
        GetIAssetManager() {
            return this._iAssetManager
        }
        async LoadScripts(...e) {
            const a = await Promise.all(e.map(e=>this.GetProjectFileUrl(e)));
            this._runtime.IsInWorker() ? importScripts(...a) : await Promise.all(a.map(e=>t(e)))
        }
        async CompileWebAssembly(e) {
            if (WebAssembly.compileStreaming) {
                const t = await this.GetProjectFileUrl(e);
                return await WebAssembly.compileStreaming(fetch(t))
            } else {
                const t = await C3.FetchArrayBuffer(e);
                return await WebAssembly.compile(t)
            }
        }
        async LoadStyleSheet(e) {
            const t = await this.GetProjectFileUrl(e);
            return await this._runtime.PostComponentMessageToDOMAsync('runtime', 'add-stylesheet', {
                url: t
            })
        }
    }
}
'use strict',
C3.Asset = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._assetManager = e,
        this._runtime = e.GetRuntime(),
        this._url = t.url,
        this._size = t.size,
        this._loadPolicy = t.loadPolicy,
        this._blob = null,
        this._isLoaded = !1,
        this._loadPromise = null
    }
    Release() {
        this._loadPromise = null,
        this._assetManager = null,
        this._runtime = null,
        this._blob = null
    }
    GetURL() {
        return this._url
    }
    GetSize() {
        return this._size
    }
    Load() {
        return 'local' === this._loadPolicy || this._blob ? (this._isLoaded = !0,
        Promise.resolve()) : this._loadPromise ? this._loadPromise : (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(e=>{
            this._isLoaded = !0,
            this._loadPromise = null,
            this._blob = e
        }
        ).catch(e=>console.error('Error loading resource: ', e)),
        this._loadPromise)
    }
    IsLoaded() {
        return this._isLoaded
    }
    GetBlob() {
        return this._blob ? Promise.resolve(this._blob) : this._assetManager.FetchBlob(this._url, this._loadPolicy)
    }
}
,
'use strict';
{
    const e = new C3.PromiseThrottle
      , t = new Set;
    C3.ImageAsset = class extends C3.Asset {
        constructor(e, a) {
            super(e, a),
            this._texturePromise = null,
            this._webglTexture = null,
            this._refCount = 0,
            this._imageWidth = -1,
            this._imageHeight = -1,
            t.add(this)
        }
        Release() {
            if (this.ReleaseTexture(),
            0 !== this._refCount)
                throw new Error('released image asset which still has texture references');
            this._texturePromise = null,
            t.delete(this),
            super.Release()
        }
        static OnWebGLContextLost() {
            for (const e of t)
                e._texturePromise = null,
                e._webglTexture = null,
                e._refCount = 0
        }
        LoadStaticTexture(t, a) {
            return (this._refCount++, this._webglTexture) ? 
				Promise.resolve(this._webglTexture) : 
				this._texturePromise ? 
					this._texturePromise : (
						this._texturePromise = this.GetBlob().then(
							n=>e.Add(
								()=>t.CreateStaticTextureAsync(n, a).then(e=>(
							this._texturePromise = null,
							0 === this._refCount
						) ? (
							t.DeleteTexture(e),
							null
						) : (
							this._webglTexture = e,
							this._imageWidth = e.GetWidth(),
							this._imageHeight = e.GetHeight(),
							this._webglTexture
						)))).catch(e=>{
								throw console.error('Failed to load texture: ', this._url),
								e
							}
						),
						this._texturePromise
					)
        }
        ReleaseTexture() {
            if (0 >= this._refCount)
                throw new Error('texture released too many times');
            if (this._refCount--,
            0 === this._refCount && this._webglTexture) {
                const e = this._webglTexture.GetRenderer();
                e.DeleteTexture(this._webglTexture),
                this._webglTexture = null
            }
        }
        GetTexture() {
            return this._webglTexture
        }
        GetWidth() {
            return this._imageWidth
        }
        GetHeight() {
            return this._imageHeight
        }
        async LoadToDrawable() {
            const e = await this.GetBlob();
            return C3.Supports.ImageBitmapOptions ? await createImageBitmap(e, {
                premultiplyAlpha: 'none'
            }) : C3.Supports.ImageBitmap ? await createImageBitmap(e) : await C3.BlobToImage(e)
        }
    }
}
{
    function e(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex()
    }
    C3.RenderCell = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super(),
            this._grid = e,
            this._x = t,
            this._y = a,
            this._instances = [],
            this._isSorted = !0,
            this._pendingRemoval = new Set,
            this._isAnyPendingRemoval = !1
        }
        Release() {
            C3.clearArray(this._instances),
            this._pendingRemoval.clear(),
            this._grid = null
        }
        Reset() {
            C3.clearArray(this._instances),
            this._isSorted = !0,
            this._pendingRemoval.clear(),
            this._isAnyPendingRemoval = !1
        }
        SetChanged() {
            this._isSorted = !1
        }
        IsEmpty() {
            return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(),
            !0)
        }
        Insert(e) {
            return this._pendingRemoval.has(e) ? (this._pendingRemoval.delete(e),
            void (0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1))) : void (this._instances.push(e),
            this._isSorted = 1 === this._instances.length)
        }
        Remove(e) {
            this._pendingRemoval.add(e),
            this._isAnyPendingRemoval = !0,
            50 <= this._pendingRemoval.size && this._FlushPending()
        }
        _FlushPending() {
            return this._isAnyPendingRemoval ? this._instances.length === this._pendingRemoval.size ? void this.Reset() : void (C3.arrayRemoveAllInSet(this._instances, this._pendingRemoval),
            this._pendingRemoval.clear(),
            this._isAnyPendingRemoval = !1) : void 0
        }
        _EnsureSorted() {
            this._isSorted || (this._instances.sort(e),
            this._isSorted = !0)
        }
        Dump(e) {
            this._FlushPending(),
            this._EnsureSorted(),
            this._instances.length && e.push(this._instances)
        }
    }
}
'use strict',
C3.RenderGrid = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._cellWidth = e,
        this._cellHeight = t,
        this._cells = C3.New(C3.PairMap)
    }
    Release() {
        this._cells.Release(),
        this._cells = null
    }
    GetCell(e, t, a) {
        let n = this._cells.Get(e, t);
        return n ? n : a ? (n = C3.New(C3.RenderCell, this, e, t),
        this._cells.Set(e, t, n),
        n) : null
    }
    XToCell(e) {
        return Math.floor(e / this._cellWidth)
    }
    YToCell(e) {
        return Math.floor(e / this._cellHeight)
    }
    Update(t, a, n) {
        if (a)
            for (let r = a.getLeft(), i = a.getRight(); r <= i; ++r)
                for (let i = a.getTop(), e = a.getBottom(); i <= e; ++i) {
                    if (n && n.containsPoint(r, i))
                        continue;
                    const e = this.GetCell(r, i, !1);
                    e && (e.Remove(t),
                    e.IsEmpty() && this._cells.Delete(r, i))
                }
        if (n)
            for (let r = n.getLeft(), i = n.getRight(); r <= i; ++r)
                for (let i = n.getTop(), e = n.getBottom(); i <= e; ++i)
                    a && a.containsPoint(r, i) || this.GetCell(r, i, !0).Insert(t)
    }
    QueryRange(t, e) {
        let n = this.XToCell(t.getLeft());
        for (const r = this.YToCell(t.getTop()), a = this.XToCell(t.getRight()), i = this.YToCell(t.getBottom()); n <= a; ++n)
            for (let t = r; t <= i; ++t) {
                const a = this.GetCell(n, t, !1);
                a && a.Dump(e)
            }
    }
    MarkRangeChanged(t) {
        let n = t.getLeft();
        for (const r = t.getTop(), a = t.getRight(), i = t.getBottom(); n <= a; ++n)
            for (let e = r; e <= i; ++e) {
                const t = this.GetCell(n, e, !1);
                t && t.SetChanged()
            }
    }
}
,
'use strict';
{
    function t(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex()
    }
    function a(e, t) {
        return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation()
    }
    const n = new C3.Rect
      , r = new C3.Quad
      , i = []
      , l = new C3.Rect
      , _ = new C3.Rect
      , u = vec3.fromValues(0, 1, 0);
    C3.Layer = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super(),
            this._layout = e,
            this._runtime = e.GetRuntime(),
            this._name = a[0],
            this._index = t,
            this._sid = a[2],
            this._isVisible = !!a[3],
            this._backgroundColor = C3.New(C3.Color),
            this._backgroundColor.setFromJSON(a[4].map(e=>e / 255)),
            this._isTransparent = !!a[5],
            this._parallaxX = a[6],
            this._parallaxY = a[7],
            this._color = C3.New(C3.Color, 1, 1, 1, a[8]),
            this._premultipliedColor = C3.New(C3.Color),
            this._isForceOwnTexture = a[9],
            this._useRenderCells = a[10],
            this._scaleRate = a[11],
            this._blendMode = a[12],
            this._srcBlend = 0,
            this._destBlend = 0,
            this._curRenderTarget = null,
            this._scale = 1,
            this._zElevation = a[16],
            this._angle = 0,
            this._isAngleEnabled = !0,
            this._viewport = C3.New(C3.Rect),
            this._viewportZ0 = C3.New(C3.Rect),
            this._startupInitialInstances = [],
            this._initialInstances = [],
            this._createdGlobalUids = [],
            this._instances = [],
            this._zIndicesUpToDate = !1,
            this._anyInstanceZElevated = !1,
            this._effectList = C3.New(C3.EffectList, this, a[15]),
            this._renderGrid = null,
            this._lastRenderList = [],
            this._isRenderListUpToDate = !1,
            this._lastRenderCells = C3.New(C3.Rect, 0, 0, -1, -1),
            this._curRenderCells = C3.New(C3.Rect, 0, 0, -1, -1),
            this._iLayer = new ILayer(this),
            this._UpdatePremultipliedColor(),
            this._useRenderCells && (this._renderGrid = C3.New(C3.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
            for (const n of a[14]) {
                const e = this._runtime.GetObjectClassByIndex(n[1]);
                this._layout._AddInitialObjectClass(e),
                e.GetDefaultInstanceData() || (e.SetDefaultInstanceData(n),
                e._SetDefaultLayerIndex(this._index)),
                this._initialInstances.push(n)
            }
            C3.shallowAssignArray(this._startupInitialInstances, this._initialInstances)
        }
        static Create(e, t, a) {
            return C3.New(C3.Layer, e, t, a)
        }
        Release() {
            this._layout = null,
            this._runtime = null
        }
        CreateInitialInstances(e) {
            const t = this._layout.IsFirstVisit();
            let a = 0;
            const n = this._initialInstances;
            for (let r = 0, i = n.length; r < i; ++r) {
                const i = n[r]
                  , l = this._runtime.GetObjectClassByIndex(i[1]);
                let _ = !0;
                if (!l.HasPersistBehavior() || t) {
                    const t = this._runtime.CreateInstanceFromData(i, this, !0);
                    e.push(t),
                    l.IsGlobal() && (_ = !1,
                    this._createdGlobalUids.push(t.GetUID()))
                }
                _ && (n[a] = n[r],
                ++a)
            }
            C3.truncateArray(n, a),
            this._runtime.FlushPendingInstances(),
            this.SetZIndicesChanged()
        }
        _AddInstance(e, t) {
            const a = e.GetWorldInfo();
            if (a.GetLayer() !== this)
                throw new Error('instance added to wrong layer');
            this._instances.push(e),
            0 !== a.GetZElevation() && (this._anyInstanceZElevated = !0),
            t && this._useRenderCells && e.GetWorldInfo().SetBboxChanged(),
            this.SetZIndicesChanged()
        }
        _MaybeAddInstance(e) {
            this._instances.includes(e) || (this._instances.push(e),
            0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0),
            this.SetZIndicesChanged())
        }
        _PrependInstance(e, t) {
            const a = e.GetWorldInfo();
            if (a.GetLayer() !== this)
                throw new Error('instance added to wrong layer');
            this._instances.unshift(e),
            0 !== a.GetZElevation() && (this._anyInstanceZElevated = !0),
            this.SetZIndicesChanged(),
            t && this._useRenderCells && e.GetWorldInfo().SetBboxChanged()
        }
        _RemoveInstance(e, t) {
            const a = this._instances.indexOf(e);
            0 > a || (t && this._useRenderCells && e.GetWorldInfo()._RemoveFromRenderCells(),
            this._instances.splice(a, 1),
            this.SetZIndicesChanged(),
            this._MaybeResetAnyInstanceZElevatedFlag())
        }
        _SetAnyInstanceZElevated() {
            this._anyInstanceZElevated = !0
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
            0 === this._instances.length && (this._anyInstanceZElevated = !1)
        }
        _SortInstancesByLastCachedZIndex(e) {
            if (e) {
                const e = new Set;
                for (const t of this._instances) {
                    const a = t.GetWorldInfo()._GetLastCachedZIndex();
                    0 <= a && e.add(a)
                }
                let t = -1;
                for (const a of this._instances) {
                    const n = a.GetWorldInfo();
                    if (!(0 <= n._GetLastCachedZIndex())) {
                        for (++t; e.has(t); )
                            ++t;
                        n._SetZIndex(t)
                    }
                }
            }
            this._instances.sort(t)
        }
        _Start() {
            this.SetBlendMode(this.GetBlendMode(), !0)
        }
        _End() {
            for (const e of this._instances)
                e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
            this._runtime.FlushPendingInstances(),
            C3.clearArray(this._instances),
            this._anyInstanceZElevated = !1,
            this.SetZIndicesChanged()
        }
        RecreateInitialObjects(t, a) {
            const n = this._runtime.GetEventSheetManager()
              , r = this._runtime.GetAllObjectClasses()
              , l = t.IsFamily();
            for (const e of this._initialInstances) {
                const _ = e[0]
                  , d = _[0]
                  , u = _[1];
                if (!a.containsPoint(d, u))
                    continue;
                const i = r[e[1]];
                if (i !== t)
                    if (!l)
                        continue;
                    else if (!t.FamilyHasMember(i))
                        continue;
                const c = this._runtime.CreateInstanceFromData(e, this, !1);
                if (n.BlockFlushingInstances(!0),
                c._TriggerOnCreated(),
                c.IsInContainer())
                    for (const e of c.siblings())
                        e._TriggerOnCreated();
                n.BlockFlushingInstances(!1)
            }
        }
        GetInstanceCount() {
            return this._instances.length
        }
        GetLayout() {
            return this._layout
        }
        GetName() {
            return this._name
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        GetRuntime() {
            return this._runtime
        }
        GetDevicePixelRatio() {
            return this._runtime.GetDevicePixelRatio()
        }
        GetEffectList() {
            return this._effectList
        }
        UsesRenderCells() {
            return this._useRenderCells
        }
        GetRenderGrid() {
            return this._renderGrid
        }
        SetRenderListStale() {
            this._isRenderListUpToDate = !1
        }
        IsVisible() {
            return this._isVisible
        }
        SetVisible(e) {
            e = !!e,
            this._isVisible === e || (this._isVisible = e,
            this._runtime.UpdateRender())
        }
        GetViewport() {
            return this._viewport
        }
        GetViewportForZ(t, a) {
            const n = this._viewportZ0;
            if (0 === t)
                a.copy(n);
            else {
                const r = this.Get2DScaleFactorToZ(t)
                  , i = n.midX()
                  , e = n.midY()
                  , l = .5 * n.width() / r
                  , _ = .5 * n.height() / r;
                a.set(i - l, e - _, i + l, e + _)
            }
        }
        GetOpacity() {
            return this._color.getA()
        }
        SetOpacity(e) {
            e = C3.clamp(e, 0, 1),
            this._color.getA() === e || (this._color.setA(e),
            this._UpdatePremultipliedColor(),
            this._runtime.UpdateRender())
        }
        _UpdatePremultipliedColor() {
            this._premultipliedColor.copy(this._color),
            this._premultipliedColor.premultiply()
        }
        GetPremultipliedColor() {
            return this._premultipliedColor
        }
        HasDefaultColor() {
            return this._color.equalsRgba(1, 1, 1, 1)
        }
        GetScaleRate() {
            return this._scaleRate
        }
        SetScaleRate(e) {
            this._scaleRate === e || (this._scaleRate = e,
            this._runtime.UpdateRender())
        }
        GetParallaxX() {
            return this._parallaxX
        }
        GetParallaxY() {
            return this._parallaxY
        }
        SetParallax(e, t) {
            if ((this._parallaxX !== e || this._parallaxY !== t) && (this._parallaxX = e,
            this._parallaxY = t,
            this._runtime.UpdateRender(),
            1 !== this._parallaxX || 1 !== this._parallaxY))
                for (const e of this._instances)
                    e.GetObjectClass()._SetAnyInstanceParallaxed(!0)
        }
        SetParallaxX(e) {
            this.SetParallax(e, this.GetParallaxY())
        }
        SetParallaxY(e) {
            this.SetParallax(this.GetParallaxX(), e)
        }
        SetZElevation(e) {
            this._zElevation = +e
        }
        GetZElevation() {
            return this._zElevation
        }
        SetAngle(e) {
            this._angle = C3.clampAngle(e)
        }
        GetAngle() {
            return this._isAngleEnabled ? C3.clampAngle(this._layout.GetAngle() + this._angle) : 0
        }
        GetOwnAngle() {
            return this._angle
        }
        HasInstances() {
            return 0 < this._instances.length
        }
        _GetInstances() {
            return this._instances
        }
        GetBackgroundColor() {
            return this._backgroundColor
        }
        IsTransparent() {
            return this._isTransparent
        }
        SetTransparent(e) {
            this._isTransparent = !!e
        }
        IsForceOwnTexture() {
            return this._isForceOwnTexture
        }
        SetForceOwnTexture(e) {
            this._isForceOwnTexture = !!e
        }
        SetBlendMode(e, t) {
            if (this._blendMode !== e || t) {
                this._blendMode = e;
                const t = this._runtime.GetWebGLRenderer();
                t && (this._srcBlend = t.GetSrcBlendByIndex(e),
                this._destBlend = t.GetDestBlendByIndex(e)),
                this._runtime.UpdateRender()
            }
        }
        GetBlendMode() {
            return this._blendMode
        }
        GetSrcBlend() {
            return this._srcBlend
        }
        GetDestBlend() {
            return this._destBlend
        }
        _IsCollisionCompatibleWith(e) {
            return this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle
        }
        _RemoveAllInstancesInSet(e) {
            if (0 !== e.size) {
                const t = C3.arrayRemoveAllInSet(this._instances, e);
                0 < t && (this._MaybeResetAnyInstanceZElevatedFlag(),
                this.SetZIndicesChanged())
            }
        }
        SetZIndicesChanged() {
            this._zIndicesUpToDate = !1,
            this._isRenderListUpToDate = !1
        }
        _UpdateZIndices() {
            if (!this._zIndicesUpToDate) {
                if (C3.stableSort(this._instances, a),
                this._useRenderCells)
                    for (let e = 0, t = this._instances.length; e < t; ++e) {
                        const t = this._instances[e].GetWorldInfo();
                        t._SetZIndex(e),
                        this._renderGrid.MarkRangeChanged(t.GetRenderCellRange())
                    }
                else
                    for (let e = 0, t = this._instances.length; e < t; ++e)
                        this._instances[e].GetWorldInfo()._SetZIndex(e);
                this._zIndicesUpToDate = !0
            }
        }
        MoveInstanceAdjacent(t, a, n) {
            const r = t.GetWorldInfo()
              , i = a.GetWorldInfo();
            if (r.GetLayer() !== this || i.GetLayer() !== this)
                throw new Error('can\'t arrange Z order unless both objects on this layer');
            const e = r.GetZIndex();
            let l = i.GetZIndex();
            C3.arrayRemove(this._instances, e),
            e < l && l--,
            n && l++,
            l === this._instances.length ? this._instances.push(t) : this._instances.splice(l, 0, t),
            this.SetZIndicesChanged()
        }
        _MergeSortedZArrays(t, n) {
            const a = [];
            let r = 0
              , i = 0
              , l = t.length
              , _ = n.length;
            for (; r < l && i < _; ) {
                const e = t[r]
                  , l = n[i];
                e.GetWorldInfo()._GetLastCachedZIndex() < l.GetWorldInfo()._GetLastCachedZIndex() ? (a.push(e),
                ++r) : (a.push(l),
                ++i)
            }
            for (; r < l; ++r)
                a.push(t[r]);
            for (; i < _; ++i)
                a.push(n[i]);
            return a
        }
        _MergeAllSortedZArrays_pass(t) {
            const a = []
              , e = t.length;
            for (let n = 0; n < e - 1; n += 2) {
                const r = t[n]
                  , i = t[n + 1];
                a.push(this._MergeSortedZArrays(r, i))
            }
            return 1 == e % 2 && a.push(t[e - 1]),
            a
        }
        _MergeAllSortedZArrays(e) {
            for (; 1 < e.length; )
                e = this._MergeAllSortedZArrays_pass(e);
            return e[0]
        }
        _GetRenderCellInstancesToDraw() {
            return this._UpdateZIndices(),
            C3.clearArray(i),
            this._renderGrid.QueryRange(this._viewport, i),
            i.length ? 1 === i.length ? i[0] : this._MergeAllSortedZArrays(i) : []
        }
        _IsOpaque() {
            return !this.UsesOwnTexture() && !this.IsTransparent()
        }
        ShouldDraw() {
            return this.IsVisible() && 0 < this.GetOpacity() && (this.HasInstances() || !this.IsTransparent())
        }
        UsesOwnTexture() {
            return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        _CanFastPathDrawLayer(e) {
            if (0 === e.length)
                return !0;
            if (2 <= e.length)
                return !1;
            const t = e[0]
              , a = t.GetShaderProgram();
            return !a.MustPreDraw() && !a.UsesDest() && !a.UsesCrossSampling() && this.HasDefaultColor()
        }
        Get2DScaleFactorToZ(e) {
            const t = this.GetCameraZ();
            return t / (t - e)
        }
        GetCameraZ() {
            return 100 / this.GetNormalScale()
        }
        _SetTransform(t, n=0, r=0) {
            const l = this._runtime.GetRenderScale()
              , e = (this._viewport.midX() + n) * l
              , _ = (this._viewport.midY() + r) * l
              , d = this.GetCameraZ();
            t.SetCameraXYZ(e, _, d),
            t.SetLookXYZ(e, _, d - 100);
            const i = this.GetAngle()
              , c = u;
            0 === i ? vec3.set(c, 0, 1, 0) : vec3.set(c, Math.sin(i), Math.cos(i), 0),
            t.ResetModelView(c),
            t.Scale(l, l),
            t.UpdateModelView()
        }
        Draw(t, a, n) {
            const r = this._runtime.GetCanvasManager()
              , i = this.UsesOwnTexture();
            let e = null
              , l = null;
            if (this._runtime.IsGPUProfiling() && t.SupportsGPUProfiling()) {
                const e = r.GetLayerTimingsBuffer(this);
                e && (l = e.AddTimeElapsedQuery(),
                t.StartQuery(l))
            }
            if (i) {
                const a = {
                    sampling: this._runtime.GetSampling()
                };
                'low' === r.GetCurrentFullscreenScalingQuality() && (a.width = r.GetDrawWidth(),
                a.height = r.GetDrawHeight()),
                e = this._runtime.GetAdditionalRenderTarget(a),
                t.SetRenderTarget(e),
                this.IsTransparent() && t.ClearRgba(0, 0, 0, 0)
            } else
                t.SetRenderTarget(a);
            if (this.IsTransparent() || t.Clear(this._backgroundColor),
            this._curRenderTarget = e || a,
            this._SetTransform(t),
            t.SetBaseZ(this.GetZElevation()),
            this.GetNormalScale() > Number.EPSILON) {
                this._UpdateZIndices();
                const e = this._useRenderCells && 0 === this.GetZElevation() && !this._anyInstanceZElevated;
                e ? this._DrawInstances_RenderCells(t) : this._DrawInstances(t, this._instances)
            }
            t.SetBaseZ(0),
            t.SetCurrentZ(0),
            t.SetCameraXYZ(0, 0, 100),
            t.SetLookXYZ(0, 0, 0),
            i && this._DrawLayerOwnTextureToRenderTarget(t, e, a, n),
            l && t.EndQuery(l),
            this._curRenderTarget = null
        }
        _DrawInstances(t, a) {
            const n = this._viewport
              , r = this._curRenderTarget;
            let i = null;
            for (let e = 0, l = a.length; e < l; ++e) {
                const l = a[e];
                if (l === i)
                    continue;
                i = l;
                const _ = l.GetWorldInfo();
                _.IsVisible() && _.IsInViewport(n) && (_.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(l, _, t, r) : this._DrawInstance(l, _, t))
            }
        }
        _DrawInstances_RenderCells(t) {
            const a = this._renderGrid
              , n = this._curRenderCells
              , r = this._lastRenderCells
              , i = this._viewport;
            let e;
            n.set(a.XToCell(i.getLeft()), a.YToCell(i.getTop()), a.XToCell(i.getRight()), a.YToCell(i.getBottom())),
            this._isRenderListUpToDate && n.equals(r) ? e = this._lastRenderList : (e = this._GetRenderCellInstancesToDraw(),
            this._isRenderListUpToDate = !0,
            r.copy(n)),
            this._DrawInstances(t, e),
            e !== this._lastRenderList && C3.shallowAssignArray(this._lastRenderList, e)
        }
        _DrawInstance(e, t, a) {
            const n = t.GetWebGLStateGroup();
            a.GetCurrentStateGroup() !== n && n.Apply(),
            e.Draw(a)
        }
        _DrawInstanceWithEffectsAndRestore(e, t, a, n) {
            this._DrawInstanceWithEffects(e, t, a, n, null) && this._SetTransform(a)
        }
        _DrawInstanceWithEffects(t, a, n, r, i) {
            const l = a.GetInstanceEffectList().GetActiveEffectTypes();
            if (1 === l.length) {
                const r = l[0]
                  , i = r.GetShaderProgram();
                if (!i.NeedsPostDrawOrExtendsBox() && a.HasDefaultColor() && !t.MustPreDraw())
                    return this._DrawInstanceWithEffects_FastPath(t, a, r, i, n),
                    !1
            }
            const e = C3.RenderEffectChain(n, this._runtime, t, r, l, i);
            return n.SetBaseZ(this.GetZElevation()),
            e
        }
        _DrawInstanceWithEffects_FastPath(t, a, n, r, d) {
            d.SetProgram(r),
            d.SetBlend(a.GetSrcBlend(), a.GetDestBlend()),
            r.IsAnimated() && this._runtime.UpdateRender();
            let e = 0
              , u = 0;
            if (r.UsesAnySrcRectOrPixelSize()) {
                const n = t.GetCurrentImageInfo();
                if (n) {
                    _.copy(n.GetTexRect());
                    const t = n.GetTexture();
                    t && (e = 1 / t.GetWidth(),
                    u = 1 / t.GetHeight())
                } else
                    _.set(0, 0, 0, 0)
            }
            const c = a.GetInstanceEffectList().GetEffectParametersForIndex(n.GetIndex());
            d.SetCurrentZ(a.GetZElevation()),
            d.SetProgramParameters(null, l, _, _, a.GetBoundingBox(), e, u, this.GetOwnScale(), this.GetAngle(), this._runtime.GetGameTime(), c),
            t.Draw(d)
        }
        _DrawLayerOwnTextureToRenderTarget(t, a, n, r) {
            const i = this._effectList.GetActiveEffectTypes()
              , e = this._runtime;
            if (this._CanFastPathDrawLayer(i)) {
                if (t.SetRenderTarget(n),
                1 === i.length) {
                    const a = i[0]
                      , n = a.GetShaderProgram();
                    t.SetProgram(n),
                    _.set(0, 0, 1, 1);
                    const r = this._effectList.GetEffectParametersForIndex(a.GetIndex());
                    t.SetProgramParameters(null, l, _, _, this._viewport, 1 / e.GetDrawWidth(), 1 / e.GetDrawHeight(), this.GetNormalScale(), this.GetAngle(), e.GetGameTime(), r),
                    n.IsAnimated() && e.UpdateRender()
                } else
                    t.SetTextureFillMode();
                r && 0 === this._blendMode && this.HasDefaultColor() && 0 === i.length ? t.CopyRenderTarget(a) : (t.SetBlend(this._srcBlend, this._destBlend),
                t.SetColor(this._premultipliedColor),
                t.DrawRenderTarget(a)),
                t.InvalidateRenderTarget(a),
                e.ReleaseAdditionalRenderTarget(a)
            } else
                C3.RenderEffectChain(t, e, this, n, i)
        }
        GetOwnScale() {
            return this._scale
        }
        SetOwnScale(e) {
            this._scale === e || (this._scale = e,
            this._layout.BoundScrolling(),
            this._runtime.UpdateRender())
        }
        GetRenderScale() {
            return this.GetNormalScale() * this._runtime.GetRenderScale()
        }
        GetDisplayScale() {
            return this.GetNormalScale() * this._runtime.GetDisplayScale()
        }
        GetNormalScale() {
            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
        }
        UpdateViewport() {
            var t = Math.round;
            this._isAngleEnabled = !1;
            let[a,i] = this.CanvasCssToLayer(0, 0);
            this._isAngleEnabled = !0,
            this._runtime.IsPixelRoundingEnabled() && (a = t(a),
            i = t(i));
            const l = 1 / this.GetNormalScale()
              , _ = this._viewportZ0;
            _.set(a, i, a + this._runtime.GetViewportWidth() * l, i + this._runtime.GetViewportHeight() * l);
            const d = this.GetAngle();
            0 !== d && (n.copy(_),
            n.offset(-_.midX(), -_.midY()),
            r.setFromRotatedRect(n, d),
            r.getBoundingBox(n),
            n.offset(_.midX(), _.midY()),
            _.copy(n)),
            this.GetViewportForZ(this._zElevation, this._viewport)
        }
        CanvasCssToLayer(e, t, a=0) {
            return this._CanvasToLayer(e, t, a, this.GetDisplayScale())
        }
        DrawSurfaceToLayer(e, t, a=0) {
            return this._CanvasToLayer(e, t, a, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _CanvasToLayer(t, a, r, _) {
            const e = this._runtime.GetParallaxXOrigin()
              , d = this._runtime.GetParallaxYOrigin()
              , u = (this._layout.GetScrollX() - e) * this._parallaxX + e
              , g = (this._layout.GetScrollY() - d) * this._parallaxY + d
              , i = this.GetNormalScale()
              , c = this._runtime.GetViewportWidth() / i
              , p = this._runtime.GetViewportHeight() / i;
            let l = u - c / 2 + t / _
              , h = g - p / 2 + a / _;
            const f = this.GetAngle();
            if (0 !== f) {
                l -= u,
                h -= g;
                const e = Math.cos(f)
                  , t = Math.sin(f)
                  , a = l * e - h * t;
                h = h * e + l * t,
                l = a,
                l += u,
                h += g
            }
            if (0 !== r) {
                const e = this._viewportZ0.midX()
                  , t = this._viewportZ0.midY()
                  , a = this.Get2DScaleFactorToZ(r);
                l = (l - e) / a + e,
                h = (h - t) / a + t
            }
            return [l, h]
        }
        CanvasCssToLayer_DefaultTransform(t, a) {
            const n = this._scale
              , r = this._scaleRate
              , i = this._parallaxX
              , e = this._parallaxY
              , l = this._angle;
            this._scale = 1,
            this._scaleRate = 1,
            this._parallaxX = 1,
            this._parallaxY = 1,
            this._angle = 0;
            const _ = this.CanvasCssToLayer(t, a);
            return this._scale = n,
            this._scaleRate = r,
            this._parallaxX = i,
            this._parallaxY = e,
            this._angle = l,
            _
        }
        LayerToCanvasCss(e, t, a=0) {
            return this._LayerToCanvas(e, t, a, this.GetDisplayScale())
        }
        LayerToDrawSurface(e, t, a=0) {
            return this._LayerToCanvas(e, t, a, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _LayerToCanvas(t, r, _, a) {
            const e = this._runtime
              , d = this._layout;
            if (0 !== _) {
                const n = this._viewportZ0.midX()
                  , a = this._viewportZ0.midY()
                  , e = this.Get2DScaleFactorToZ(_);
                t = (t - n) * e + n,
                r = (r - a) * e + a
            }
            const u = e.GetParallaxXOrigin()
              , g = e.GetParallaxYOrigin()
              , i = (d.GetScrollX() - u) * this._parallaxX + u
              , h = (d.GetScrollY() - g) * this._parallaxY + g
              , S = this.GetAngle();
            if (0 !== S) {
                t -= i,
                r -= h;
                const a = Math.cos(-S)
                  , n = Math.sin(-S)
                  , e = t * a - r * n;
                r = r * a + t * n,
                t = e,
                t += i,
                r += h
            }
            const l = this.GetNormalScale()
              , m = e.GetViewportWidth() / l
              , n = e.GetViewportHeight() / l
              , f = t - (i - m / 2)
              , p = r - (h - n / 2);
            return [f * a, p * a]
        }
        _GetLayerToDrawSurfaceScale(e, t) {
            return e *= this.GetRenderScale() * this.GetDevicePixelRatio(),
            0 !== t && (e *= this.Get2DScaleFactorToZ(t)),
            e
        }
        _SaveToJson() {
            const e = {
                s: this.GetOwnScale(),
                a: this.GetOwnAngle(),
                vl: this._viewport.getLeft(),
                vt: this._viewport.getTop(),
                vr: this._viewport.getRight(),
                vb: this._viewport.getBottom(),
                v: this.IsVisible(),
                bc: this._backgroundColor.toJSON(),
                t: this.IsTransparent(),
                px: this.GetParallaxX(),
                py: this.GetParallaxY(),
                c: this._color.toJSON(),
                sr: this.GetScaleRate(),
                fx: this._effectList.SaveToJson(),
                cg: this._createdGlobalUids
            };
            return e
        }
        _LoadFromJson(e) {
            this._scale = e.s,
            this._angle = e.a,
            this._viewport.set(e.vl, e.vt, e.vr, e.vb),
            this._isVisible = !!e.v,
            this._backgroundColor.setFromJSON(e.bc),
            this._isTransparent = !!e.t,
            this._parallaxX = e.px,
            this._parallaxY = e.py,
            this._color.setFromJSON(e.c),
            this._scaleRate = e.sr,
            C3.shallowAssignArray(this._createdGlobalUids, e.cg),
            C3.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
            const t = new Set(this._createdGlobalUids);
            let a = 0;
            for (let n = 0, r = this._initialInstances.length; n < r; ++n)
                t.has(this._initialInstances[n][2]) || (this._initialInstances[a] = this._initialInstances[n],
                ++a);
            C3.truncateArray(this._initialInstances, a),
            this._effectList.LoadFromJson(e.fx),
            this._SortInstancesByLastCachedZIndex(!1),
            this.SetZIndicesChanged()
        }
        GetILayer() {
            return this._iLayer
        }
    }
}
{
    const t = C3.New(C3.Rect)
      , n = C3.New(C3.Rect)
      , r = C3.New(C3.Rect)
      , l = C3.New(C3.Rect);
    C3.Layout = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super(),
            this._layoutManager = e,
            this._runtime = e.GetRuntime(),
            this._name = a[0],
            this._originalWidth = a[1],
            this._originalHeight = a[2],
            this._width = a[1],
            this._height = a[2],
            this._isUnboundedScrolling = !!a[3],
            this._eventSheetName = a[4],
            this._eventSheet = null,
            this._sid = a[5],
            this._index = t,
            this._scrollX = 0,
            this._scrollY = 0,
            this._scale = 1,
            this._angle = 0,
            this._initialObjectClasses = new Set,
            this._textureLoadedTypes = new Set,
            this._textureLoadPendingPromises = new Set,
            this._createdInstances = [],
            this._initialNonWorld = [],
            this._layers = [],
            this._layersByName = new Map,
            this._layersBySid = new Map,
            this._effectList = C3.New(C3.EffectList, this, a[8]),
            this._curRenderTarget = null,
            this._persistData = {},
            this._isFirstVisit = !0,
            this._iLayout = new ILayout(this),
            this._userScriptDispatcher = C3.New(C3.Event.Dispatcher);
            for (const n of a[6]) {
                const e = C3.Layer.Create(this, this._layers.length, n);
                this._layers.push(e),
                this._layersByName.set(e.GetName().toLowerCase(), e),
                this._layersBySid.set(e.GetSID(), e)
            }
            for (const n of a[7]) {
                const e = this._runtime.GetObjectClassByIndex(n[1]);
                if (!e)
                    throw new Error('missing nonworld object class');
                e.GetDefaultInstanceData() || e.SetDefaultInstanceData(n),
                this._initialNonWorld.push(n),
                this._AddInitialObjectClass(e)
            }
        }
        Release() {
            for (const e of this._layers)
                e.Release();
            C3.clearArray(this._layers),
            this._textureLoadPendingPromises.clear(),
            this._eventSheet = null,
            this._layoutManager = null,
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetIndex() {
            return this._index
        }
        GetEffectList() {
            return this._effectList
        }
        GetMinLayerScale() {
            let e = this._layers[0].GetNormalScale();
            for (let t = 1, a = this._layers.length; t < a; ++t) {
                const a = this._layers[t];
                0 === a.GetParallaxX() && 0 === a.GetParallaxY() || (e = Math.min(e, a.GetNormalScale()))
            }
            return e
        }
        SetScrollX(e) {
            if (!this._isUnboundedScrolling) {
                const t = this._runtime.GetViewportWidth() * (1 / this.GetMinLayerScale()) / 2;
                e > this._width - t && (e = this._width - t),
                e < t && (e = t)
            }
            this._scrollX !== e && (this._scrollX = e,
            this._runtime.UpdateRender())
        }
        GetScrollX() {
            return this._scrollX
        }
        SetScrollY(e) {
            if (!this._isUnboundedScrolling) {
                const t = this._runtime.GetViewportHeight() * (1 / this.GetMinLayerScale()) / 2;
                e > this._height - t && (e = this._height - t),
                e < t && (e = t)
            }
            this._scrollY !== e && (this._scrollY = e,
            this._runtime.UpdateRender())
        }
        GetScrollY() {
            return this._scrollY
        }
        BoundScrolling() {
            this.SetScrollX(this.GetScrollX()),
            this.SetScrollY(this.GetScrollY())
        }
        GetScale() {
            return this._scale
        }
        SetScale(e) {
            e = +e,
            this._scale === e || (this._scale = e,
            this.BoundScrolling())
        }
        SetAngle(e) {
            this._angle = C3.clampAngle(e)
        }
        GetAngle() {
            return this._angle
        }
        GetWidth() {
            return this._width
        }
        SetWidth(e) {
            !isFinite(e) || 1 > e || (this._width = e)
        }
        GetHeight() {
            return this._height
        }
        SetHeight(e) {
            !isFinite(e) || 1 > e || (this._height = e)
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetLayers() {
            return this._layers
        }
        GetLayerCount() {
            return this._layers.length
        }
        GetLayer(e) {
            return 'number' == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString())
        }
        GetLayerByIndex(e) {
            return e = C3.clamp(Math.floor(e), 0, this._layers.length - 1),
            this._layers[e]
        }
        GetLayerByName(e) {
            return this._layersByName.get(e.toLowerCase()) || null
        }
        GetLayerBySID(e) {
            return this._layersBySid.get(e) || null
        }
        HasOpaqueBottomLayer() {
            for (const e of this._layers)
                if (e.ShouldDraw())
                    return e._IsOpaque();
            return !1
        }
        IsFirstVisit() {
            return this._isFirstVisit
        }
        _GetInitialObjectClasses() {
            return [...this._initialObjectClasses]
        }
        _AddInitialObjectClass(e) {
            if (e.IsInContainer())
                for (const t of e.GetContainer().GetObjectTypes())
                    this._initialObjectClasses.add(t);
            else
                this._initialObjectClasses.add(e)
        }
        _GetTextureLoadedObjectTypes() {
            return [...this._textureLoadedTypes]
        }
        _Load(e, t) {
            if (e === this || !t)
                return Promise.resolve();
            e && (C3.CopySet(this._textureLoadedTypes, e._textureLoadedTypes),
            e._textureLoadedTypes.clear());
            const a = [];
            for (const n of this._initialObjectClasses)
                this._textureLoadedTypes.has(n) || (a.push(n.LoadTextures(t)),
                this._textureLoadedTypes.add(n));
            return Promise.all(a)
        }
        async MaybeLoadTexturesFor(e) {
            if (e.IsFamily())
                throw new Error('cannot load textures for family');
            const t = this._runtime.GetWebGLRenderer();
            if (!(!t || t.IsContextLost() || this._textureLoadedTypes.has(e))) {
                this._textureLoadedTypes.add(e);
                const a = e.LoadTextures(t);
                this._AddPendingTextureLoadPromise(a),
                await a,
                e.OnDynamicTextureLoadComplete(),
                this._runtime.UpdateRender()
            }
        }
        _AddPendingTextureLoadPromise(e) {
            this._textureLoadPendingPromises.add(e),
            e.then(()=>this._textureLoadPendingPromises.delete(e)).catch(()=>this._textureLoadPendingPromises.delete(e))
        }
        WaitForPendingTextureLoadsToComplete() {
            return Promise.all([...this._textureLoadPendingPromises])
        }
        MaybeUnloadTexturesFor(e) {
            if (e.IsFamily() || 0 < e.GetInstanceCount())
                throw new Error('cannot unload textures');
            const t = this._runtime.GetWebGLRenderer();
            t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e),
            e.ReleaseTextures(t))
        }
        _Unload(e, t) {
            if (e !== this && t)
                for (const t of this._textureLoadedTypes)
                    t.IsGlobal() || e._initialObjectClasses.has(t) || (t.ReleaseTextures(),
                    this._textureLoadedTypes.delete(t))
        }
        _OnWebGLContextLost() {
            this._textureLoadedTypes.clear()
        }
        async _StartRunning(e) {
            const t = this._runtime
              , a = this._layoutManager
              , n = t.GetEventSheetManager();
            if (this._eventSheetName && (this._eventSheet = n.GetEventSheetByName(this._eventSheetName),
            this._eventSheet._UpdateDeepIncludes()),
            a._SetMainRunningLayout(this),
            this._width = this._originalWidth,
            this._height = this._originalHeight,
            this._scrollX = t.GetOriginalViewportWidth() / 2,
            this._scrollY = t.GetOriginalViewportHeight() / 2,
            this.BoundScrolling(),
            this._MoveGlobalObjectsToThisLayout(e),
            this._CreateInitialInstances(),
            this._isFirstVisit || this._CreatePersistedInstances(),
            this._CreateAndLinkContainerInstances(this._createdInstances),
            this._CreateInitialNonWorldInstances(),
            a.ClearPendingChangeLayout(),
            t.FlushPendingInstances(),
            t.IsLoadingState())
                t._TriggerOnCreateAfterLoad(this._createdInstances);
            else
                for (const e of this._createdInstances)
                    e._TriggerOnCreated();
            C3.clearArray(this._createdInstances),
            await Promise.all([...this._initialObjectClasses].map(e=>e.PreloadTexturesWithInstances(this._runtime.GetWebGLRenderer()))),
            e && (t.Dispatcher().dispatchEvent(new C3.Event('beforefirstlayoutstart')),
            await t.DispatchUserScriptEventAsyncWait(new C3.Event('beforeprojectstart'))),
            await this.DispatchUserScriptEventAsyncWait(new C3.Event('beforelayoutstart')),
            t.IsLoadingState() || (await t.TriggerAsync(C3.Plugins.System.Cnds.OnLayoutStart, null, null)),
            await this.DispatchUserScriptEventAsyncWait(new C3.Event('afterlayoutstart')),
            e && (t.Dispatcher().dispatchEvent(new C3.Event('afterfirstlayoutstart')),
            await t.DispatchUserScriptEventAsyncWait(new C3.Event('afterprojectstart'))),
            n._RunQueuedTriggers(a),
            await this.WaitForPendingTextureLoadsToComplete(),
            this._isFirstVisit = !1
        }
        _MoveGlobalObjectsToThisLayout(e) {
            for (const t of this._runtime.GetAllObjectClasses())
                if (!t.IsFamily() && t.IsWorldType())
                    for (const n of t.GetInstances()) {
                        const t = n.GetWorldInfo()
                          , a = t.GetLayer()
                          , r = C3.clamp(a.GetIndex(), 0, this._layers.length - 1)
                          , i = this._layers[r];
                        t._SetLayer(i),
                        i._MaybeAddInstance(n)
                    }
            if (!e)
                for (const e of this._layers)
                    e._SortInstancesByLastCachedZIndex(!1)
        }
        _CreateInitialInstances() {
            for (const e of this._layers)
                e.CreateInitialInstances(this._createdInstances),
                e.UpdateViewport(),
                e._Start()
        }
        _CreatePersistedInstances() {
            let t = !1;
            for (const [e,a] of Object.entries(this._persistData)) {
                const n = this._runtime.GetObjectClassBySID(parseInt(e, 10));
                if (n && !n.IsFamily() && n.HasPersistBehavior()) {
                    for (const r of a) {
                        let a = null;
                        if (n.IsWorldType() && (a = this.GetLayerBySID(r.w.l),
                        !a))
                            continue;
                        const i = this._runtime.CreateInstanceFromData(n, a, !1, 0, 0, !0);
                        i.LoadFromJson(r),
                        t = !0,
                        this._createdInstances.push(i)
                    }
                    C3.clearArray(a)
                }
            }
            for (const e of this._layers)
                e._SortInstancesByLastCachedZIndex(!0),
                e.SetZIndicesChanged();
            t && (this._runtime.FlushPendingInstances(),
            this._runtime._RefreshUidMap())
        }
        _CreateAndLinkContainerInstances(t) {
            for (const a of t) {
                if (!a.IsInContainer())
                    continue;
                const n = a.GetWorldInfo()
                  , r = a.GetIID();
                for (const i of a.GetObjectClass().GetContainer().objectTypes()) {
                    if (i === a.GetObjectClass())
                        continue;
                    const e = i.GetInstances();
                    if (e.length > r)
                        a._AddSibling(e[r]);
                    else {
                        let e;
                        e = n ? this._runtime.CreateInstanceFromData(i, n.GetLayer(), !0, n.GetX(), n.GetY(), !0) : this._runtime.CreateInstanceFromData(i, null, !0, 0, 0, !0),
                        this._runtime.FlushPendingInstances(),
                        i._UpdateIIDs(),
                        a._AddSibling(e),
                        t.push(e)
                    }
                }
            }
        }
        _CreateInitialNonWorldInstances() {
            for (const e of this._initialNonWorld) {
                const t = this._runtime.GetObjectClassByIndex(e[1]);
                t.IsInContainer() || this._runtime.CreateInstanceFromData(e, null, !0)
            }
        }
        _CreateGlobalNonWorlds() {
            const t = []
              , a = this._initialNonWorld;
            let n = 0;
            for (let r = 0, i = a.length; r < i; ++r) {
                const i = a[r]
                  , e = this._runtime.GetObjectClassByIndex(i[1]);
                e.IsGlobal() ? (!e.IsInContainer() || !e.GetContainer().HasAnyWorldType()) && t.push(this._runtime.CreateInstanceFromData(i, null, !0)) : (a[n] = i,
                ++n)
            }
            C3.truncateArray(a, n),
            this._runtime.FlushPendingInstances(),
            this._CreateAndLinkContainerInstances(t)
        }
        RecreateInitialObjects(a, n, r, i, e) {
            t.set(n, r, i, e);
            for (const l of this._layers)
                l.RecreateInitialObjects(a, t)
        }
        async _StopRunning() {
            const e = this._layoutManager;
            this._runtime.IsLoadingState() || (await this._runtime.TriggerAsync(C3.Plugins.System.Cnds.OnLayoutEnd, null, null)),
            e.SetIsEndingLayout(!0),
            this._runtime.GetEventSheetManager().ClearAllScheduledWaits(),
            this._isFirstVisit || this._SavePersistData();
            for (const e of this._layers)
                e._End();
            for (const e of this._runtime.GetAllObjectClasses())
                if (!(e.IsGlobal() || e.IsWorldType() || e.GetPlugin().IsSingleGlobal() || e.IsFamily())) {
                    for (const t of e.GetInstances())
                        this._runtime.DestroyInstance(t);
                    this._runtime.FlushPendingInstances()
                }
            e.SetIsEndingLayout(!1),
            e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null)
        }
        _SaveInstanceToPersist(e) {
            const t = e.GetObjectClass().GetSID().toString();
            this._persistData.hasOwnProperty(t) || (this._persistData[t] = []);
            const a = this._persistData[t];
            a.push(e.SaveToJson())
        }
        _SavePersistData() {
            for (const e of this._layers) {
                e._UpdateZIndices();
                for (const t of e._GetInstances()) {
                    const e = t.GetObjectClass();
                    !e.IsGlobal() && e.HasPersistBehavior() && this._SaveInstanceToPersist(t)
                }
            }
        }
        ResetPersistData() {
            this._persistData = {},
            this._isFirstVisit = !0
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        UsesOwnTexture() {
            return 'low' === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() || this._runtime.UsesAnyBackgroundBlending() || 'low-latency' === this._runtime.GetCompositingMode() || this._effectList.HasAnyActiveEffect()
        }
        _CanFastPathDrawLayout(e) {
            if (0 === e.length)
                return !0;
            if (2 <= e.length)
                return !1;
            const t = e[0]
              , a = t.GetShaderProgram();
            return !a.MustPreDraw()
        }
        Draw(t) {
            const a = this._runtime.GetCanvasManager()
              , n = this.UsesOwnTexture();
            let r = null;
            if (n) {
                'low-latency' !== this._runtime.GetCompositingMode() && (t.SetRenderTarget(null),
                t.ClearRgba(0, 0, 0, 0));
                const e = {
                    sampling: this._runtime.GetSampling(),
                    readback: this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
                };
                'low' === a.GetCurrentFullscreenScalingQuality() && (e.width = a.GetDrawWidth(),
                e.height = a.GetDrawHeight()),
                r = this._runtime.GetAdditionalRenderTarget(e),
                t.SetRenderTarget(r)
            } else
                t.SetRenderTarget(null);
            this.HasOpaqueBottomLayer() || t.ClearRgba(0, 0, 0, 0),
            this._curRenderTarget = r;
            let i = !0;
            for (const e of this._layers)
                e.UpdateViewport(),
                e.ShouldDraw() && (e.Draw(t, r, i),
                i = !1);
            n && this._DrawLayoutOwnTextureToRenderTarget(t, r),
            this._curRenderTarget = null
        }
        _DrawLayoutOwnTextureToRenderTarget(t, a) {
            const _ = this._effectList.GetActiveEffectTypes()
              , d = this._runtime;
            if (this._CanFastPathDrawLayout(_)) {
                if (t.SetRenderTarget(null),
                1 === _.length) {
                    const a = _[0]
                      , e = a.GetShaderProgram();
                    t.SetProgram(e),
                    r.set(0, 0, 1, 1),
                    l.set(0, 0, d.GetViewportWidth(), d.GetViewportHeight());
                    const u = this._effectList.GetEffectParametersForIndex(a.GetIndex());
                    t.SetProgramParameters(null, n, r, r, l, 1 / d.GetDrawWidth(), 1 / d.GetDrawHeight(), this.GetScale(), this.GetAngle(), d.GetGameTime(), u),
                    e.IsAnimated() && d.UpdateRender()
                } else
                    t.SetTextureFillMode();
                0 === _.length ? t.CopyRenderTarget(a) : (t.SetAlphaBlend(),
                t.ResetColor(),
                t.DrawRenderTarget(a)),
                t.InvalidateRenderTarget(a),
                d.ReleaseAdditionalRenderTarget(a)
            } else
                C3.RenderEffectChain(t, d, this, null, _)
        }
        _SaveToJson() {
            const e = {
                sx: this.GetScrollX(),
                sy: this.GetScrollY(),
                s: this.GetScale(),
                a: this.GetAngle(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                fv: this._isFirstVisit,
                persist: this._persistData,
                fx: this._effectList.SaveToJson(),
                layers: {}
            };
            for (const t of this._layers)
                e.layers[t.GetSID().toString()] = t._SaveToJson();
            return e
        }
        _LoadFromJson(e) {
            this._scrollX = e.sx,
            this._scrollY = e.sy,
            this._scale = e.s,
            this._angle = e.a,
            this._width = e.w,
            this._height = e.h,
            this._isFirstVisit = !!e.fv,
            this._persistData = e.persist,
            this._effectList.LoadFromJson(e.fx);
            for (const [t,n] of Object.entries(e.layers)) {
                const e = parseInt(t, 10)
                  , a = this.GetLayerBySID(e);
                a && a._LoadFromJson(n)
            }
        }
        GetILayout() {
            return this._iLayout
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(e) {
            const t = this._runtime
              , a = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
            a && C3Debugger.StartMeasuringScriptTime(),
            this._userScriptDispatcher.dispatchEvent(e),
            a && C3Debugger.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(e) {
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(e)
        }
    }
}
'use strict',
C3.LayoutManager = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e,
        this._allLayouts = [],
        this._layoutsByName = new Map,
        this._layoutsBySid = new Map,
        this._mainRunningLayout = null,
        this._runningSubLayouts = [],
        this._firstLayout = null,
        this._isEndingLayout = 0,
        this._pendingChangeLayout = null
    }
    Release() {
        this._runtime = null,
        this._mainRunningLayout = null,
        this._firstLayout = null,
        this._pendingChangeLayout = null,
        C3.clearArray(this._allLayouts),
        this._layoutsByName.clear(),
        this._layoutsBySid.clear(),
        C3.clearArray(this._runningSubLayouts)
    }
    Create(e) {
        const t = C3.New(C3.Layout, this, this._allLayouts.length, e);
        this._allLayouts.push(t),
        this._layoutsByName.set(t.GetName().toLowerCase(), t),
        this._layoutsBySid.set(t.GetSID(), t)
    }
    GetRuntime() {
        return this._runtime
    }
    SetFirstLayout(e) {
        this._firstLayout = e
    }
    GetFirstLayout() {
        if (this._firstLayout)
            return this._firstLayout;
        if (this._allLayouts.length)
            return this._allLayouts[0];
        throw new Error('no first layout')
    }
    GetLayoutByName(e) {
        return this._layoutsByName.get(e.toLowerCase()) || null
    }
    GetLayoutBySID(e) {
        return this._layoutsBySid.get(e) || null
    }
    GetLayoutByIndex(e) {
        return e = C3.clamp(Math.floor(e), 0, this._allLayouts.length - 1),
        this._allLayouts[e]
    }
    GetLayout(e) {
        return 'number' == typeof e ? this.GetLayoutByIndex(e) : this.GetLayoutByName(e.toString())
    }
    GetAllLayouts() {
        return this._allLayouts
    }
    _SetMainRunningLayout(e) {
        this._mainRunningLayout = e
    }
    GetMainRunningLayout() {
        return this._mainRunningLayout
    }
    _AddRunningSubLayout(e) {
        if (this._runningSubLayouts.includes(e))
            throw new Error('layout already running');
        this._runningSubLayouts.push(e)
    }
    _RemoveRunningSubLayout(e) {
        const t = this._runningSubLayouts.indexOf(e);
        if (-1 === t)
            throw new Error('layout not running');
        this._runningSubLayouts.splice(t, 1)
    }
    *runningLayouts() {
        this._mainRunningLayout && (yield this._mainRunningLayout),
        this._runningSubLayouts.length && (yield*this._runningSubLayouts)
    }
    IsLayoutRunning(e) {
        return this._mainRunningLayout === e || this._runningSubLayouts.includes(e)
    }
    SetIsEndingLayout(e) {
        if (e)
            this._isEndingLayout++;
        else {
            if (0 >= this._isEndingLayout)
                throw new Error('already unset');
            this._isEndingLayout--
        }
    }
    IsEndingLayout() {
        return 0 < this._isEndingLayout
    }
    ChangeMainLayout(e) {
        this._pendingChangeLayout = e
    }
    ClearPendingChangeLayout() {
        this._pendingChangeLayout = null
    }
    IsPendingChangeMainLayout() {
        return !!this._pendingChangeLayout
    }
    GetPendingChangeMainLayout() {
        return this._pendingChangeLayout
    }
}
,
'use strict';
{
    function t() {
        return g === i.length && i.push(new c),
        i[g++]
    }
    function a(e) {
        e.ReleaseEffectRenderTargets(),
        e.Clear(),
        g--
    }
    async function n(t, a, n) {
        const r = await C3.Gfx.WebGLRenderTarget.DebugReadPixelsToBlob(a, n)
          , i = URL.createObjectURL(r);
        console.log('[FX] ' + t + ' ' + (n ? '' : ' [to display]') + ': ', i)
    }
    function _(t, a) {
        var _ = Math.max
          , u = Math.min;
        for (let e = 0, n = a.length; e < n; ++e) {
            const n = a[e].GetShaderProgram();
            t.boxExtendHorizontal += n.GetBoxExtendHorizontal(),
            t.boxExtendVertical += n.GetBoxExtendVertical()
        }
        const d = t.wi
          , c = d.GetLayer()
          , e = c.GetAngle()
          , f = d.GetBoundingBox()
          , h = d.GetTotalZElevation();
        let[i,S] = c.LayerToDrawSurface(f.getLeft(), f.getTop(), h)
          , [y,G] = c.LayerToDrawSurface(f.getRight(), f.getBottom(), h);
        if (0 !== e) {
            const [t,a] = c.LayerToDrawSurface(f.getRight(), f.getTop(), h)
              , [r,e] = c.LayerToDrawSurface(f.getLeft(), f.getBottom(), h);
            let l = u(i, y, t, r);
            y = _(i, y, t, r),
            i = l,
            l = u(S, G, a, e),
            G = _(S, G, a, e),
            S = l
        }
        const g = t.screenRect
          , n = t.rcTexOrigin
          , b = t.rcTexDest
          , p = t.clearRect
          , T = t.rcTexBounce;
        g.set(i, S, y, G),
        g.shuntY(t.drawHeight),
        n.copy(g),
        n.divide(t.surfaceWidth, t.surfaceHeight),
        n.swapTopBottom(),
        g.inflate(t.boxExtendHorizontal, t.boxExtendVertical),
        b.copy(g),
        b.divide(t.surfaceWidth, t.surfaceHeight),
        b.swapTopBottom(),
        p.copy(g),
        p.roundOuter(),
        p.inflate(t.boxExtendHorizontal + 1, t.boxExtendVertical + 1),
        g.clamp(0, 0, t.drawWidth, t.drawHeight),
        p.clamp(0, 0, t.drawWidth, t.drawHeight),
        T.copy(g),
        T.divide(t.surfaceWidth, t.surfaceHeight),
        T.swapTopBottom()
    }
    function d(t) {
        const a = t.renderer;
        a.SetTextureFillMode();
        const r = t.GetEffectRenderTarget(t.fxIndex);
        a.SetRenderTarget(r);
        const i = t.opts;
        if (i && i.preTransform && i.preTransform(),
        !1,
        a.ClearRect2(t.clearRect),
        t.inst)
            a.SetColor(t.wi.GetPremultipliedColor()),
            a.SetCurrentZ(t.wi.GetTotalZElevation()),
            t.inst.Draw(a),
            a.SetCurrentZ(0);
        else {
            const e = (t.layer || t.layout).GetRenderTarget();
            t.layer ? a.SetColor(t.layer.GetPremultipliedColor()) : a.ResetColor(),
            a.DrawRenderTarget(e),
            a.InvalidateRenderTarget(e),
            t.runtime.GetCanvasManager().ReleaseAdditionalRenderTarget(e)
        }
        t.rcTexDest.clampFlipped(0, 1, 1, 0),
        t.fxIndex = 1,
        t.otherFxIndex = 0,
        S && n('Pre-draw', a, r)
    }
    function e(t, a) {
        const r = t.renderer
          , l = t.runtime
          , e = t.GetEffectRenderTarget(t.fxIndex);
        r.SetRenderTarget(e);
        const i = t.opts;
        if (i && i.preTransform && i.preTransform(),
        !1,
        r.ClearRect2(t.clearRect),
        t.inst) {
            let _ = 100
              , d = 100;
            const u = t.inst.GetCurrentImageInfo();
            if (u) {
                t.srcRect.copy(u.GetTexRect());
                const e = u.GetTexture();
                e && (_ = e.GetWidth(),
                d = e.GetHeight())
            } else
                t.srcRect.set(0, 0, 0, 0);
            const i = t.wi.GetInstanceEffectList().GetEffectParametersForIndex(a.GetIndex());
            r.SetProgramParameters(t.renderTarget, t.rcTexDest, t.srcRect, t.srcRect, t.layoutRect, 1 / _, 1 / d, t.layerScale, t.layerAngle, l.GetGameTime(), i),
            r.SetCurrentZ(t.wi.GetTotalZElevation()),
            t.inst.Draw(r),
            r.SetCurrentZ(0),
            t.rcTexDest.clampFlipped(0, 1, 1, 0),
            t.screenRect.shuntY(t.drawHeight),
            S && n('First bounce', r, e)
        } else {
            const i = (t.layer || t.layout).GetEffectList().GetEffectParametersForIndex(a.GetIndex());
            r.SetProgramParameters(t.renderTarget, t.rcTexDest, t.rcTexBounce, t.rcTexOrigin, t.layoutRect, 1 / t.drawWidth, 1 / t.drawHeight, t.layerScale, t.layerAngle, l.GetGameTime(), i);
            const _ = (t.layer || t.layout).GetRenderTarget();
            S && n('Layer target', r, _),
            r.DrawRenderTarget(_),
            r.InvalidateRenderTarget(_),
            l.GetCanvasManager().ReleaseAdditionalRenderTarget(_),
            S && n('First bounce', r, e)
        }
    }
    function r(t, a, r, l) {
        const e = t.renderer
          , _ = t.runtime;
        let d, u;
        0 === l && t.preDraw && t.inst && t.screenRect.shuntY(t.drawHeight),
        r ? (t.inst ? e.SetBlend(t.wi.GetSrcBlend(), t.wi.GetDestBlend()) : t.layer && e.SetBlend(t.layer.GetSrcBlend(), t.layer.GetDestBlend()),
        d = t.renderTarget,
        e.SetRenderTarget(d)) : (d = t.GetEffectRenderTarget(t.fxIndex),
        e.SetRenderTarget(d),
        !1,
        e.ClearRect2(t.clearRect)),
        u = t.inst ? t.wi.GetInstanceEffectList().GetEffectParametersForIndex(a.GetIndex()) : (t.layer || t.layout).GetEffectList().GetEffectParametersForIndex(a.GetIndex()),
        e.SetProgramParameters(t.renderTarget, t.rcTexDest, t.rcTexBounce, t.rcTexOrigin, t.layoutRect, 1 / t.surfaceWidth, 1 / t.surfaceHeight, t.layerScale, t.layerAngle, _.GetGameTime(), u);
        const c = t.GetEffectRenderTarget(t.otherFxIndex);
        e.SetTexture(c.GetTexture()),
        _.GetCanvasManager().SetDeviceTransform(e),
        t.didChangeTransform = !0,
        p.setFromRect(t.screenRect),
        e.Quad3(p, t.rcTexBounce),
        t.inst || e.InvalidateRenderTarget(c),
        S && n('Bounce ' + l, e, d)
    }
    function u(t) {
        const a = t.renderer;
        if (t.layout) {
            a.SetTextureFillMode(),
            a.SetRenderTarget(t.renderTarget);
            const e = t.GetEffectRenderTarget(t.otherFxIndex);
            return a.CopyRenderTarget(e),
            void a.InvalidateRenderTarget(e)
        }
        const r = t.runtime.GetCanvasManager();
        'low' === r.GetCurrentFullscreenScalingQuality() ? (a.SetTextureFillMode(),
        r.SetDeviceTransform(a, r.GetDrawWidth(), r.GetDrawHeight()),
        t.didChangeTransform = !0) : a.SetDeviceTransformTextureFillMode(),
        t.inst ? a.SetBlend(t.wi.GetSrcBlend(), t.wi.GetDestBlend()) : t.layer && a.SetBlend(t.layer.GetSrcBlend(), t.layer.GetDestBlend()),
        a.SetRenderTarget(t.renderTarget);
        const i = t.GetEffectRenderTarget(t.otherFxIndex);
        a.SetTexture(i.GetTexture()),
        p.setFromRect(t.screenRect),
        a.Quad3(p, t.rcTexBounce),
        t.inst || a.InvalidateRenderTarget(i),
        S && n('Post-draw', a, t.renderTarget)
    }
    class c {
        constructor() {
            this.renderer = null,
            this.runtime = null,
            this.drawWidth = 0,
            this.drawHeight = 0,
            this.surfaceWidth = 0,
            this.surfaceHeight = 0,
            this.layoutRect = new C3.Rect,
            this.rcTexBounce = new C3.Rect,
            this.rcTexDest = new C3.Rect,
            this.rcTexOrigin = new C3.Rect,
            this.screenRect = new C3.Rect,
            this.clearRect = new C3.Rect,
            this.srcRect = new C3.Rect,
            this.fxTex = [null, null],
            this.fxIndex = 0,
            this.otherFxIndex = 1,
            this.boxExtendHorizontal = 0,
            this.boxExtendVertical = 0,
            this.layerScale = 0,
            this.layerAngle = 0,
            this.layout = null,
            this.layer = null,
            this.inst = null,
            this.wi = null,
            this.renderTarget = null,
            this.preDraw = !1,
            this.postDraw = !1,
            this.didChangeTransform = !1,
            this.opts = null
        }
        Clear() {
            this.renderer = null,
            this.runtime = null,
            this.layout = null,
            this.layer = null,
            this.inst = null,
            this.wi = null,
            this.renderTarget = null,
            this.opts = null
        }
        ShouldPreDraw(e) {
            const t = e.GetShaderProgram();
            return !!t.MustPreDraw() || (this.inst ? t.UsesDest() && 0 !== this.wi.GetAngle() || 0 !== this.boxExtendHorizontal || 0 !== this.boxExtendVertical || !this.wi.HasDefaultColor() || this.inst.MustPreDraw() : this.layer ? !this.layer.HasDefaultColor() : void 0)
        }
        ShouldPostDraw(e) {
            const t = e.GetShaderProgram();
            return t.UsesDest() || t.UsesCrossSampling() || this.layout && 'low' === this.runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality()
        }
        GetEffectRenderTarget(t) {
            if (0 !== t && 1 !== t)
                throw new Error('invalid effect target');
            const a = this.fxTex;
            if (!a[t]) {
                const n = this.runtime
                  , r = n.GetCanvasManager()
                  , i = {
                    sampling: n.GetSampling()
                };
                'low' === r.GetCurrentFullscreenScalingQuality() && (i.width = r.GetDrawWidth(),
                i.height = r.GetDrawHeight()),
                a[t] = r.GetAdditionalRenderTarget(i)
            }
            return a[t]
        }
        ReleaseEffectRenderTargets() {
            const e = this.fxTex
              , t = this.runtime.GetCanvasManager();
            e[0] && (t.ReleaseAdditionalRenderTarget(e[0]),
            e[0] = null),
            e[1] && (t.ReleaseAdditionalRenderTarget(e[1]),
            e[1] = null)
        }
    }
    const i = [];
    let g = 0;
    const p = new C3.Quad;
    let S = !1;
    C3.RenderEffectChain = function(g, c, m, i, h, l) {
        const n = t();
        if (n.renderer = g,
        n.runtime = c,
        m instanceof C3.Instance)
            n.inst = m,
            n.wi = n.inst.GetWorldInfo();
        else if (m instanceof C3.Layer)
            n.layer = m;
        else if (m instanceof C3.Layout)
            n.layout = m;
        else
            throw new Error('invalid effects object');
        const f = c.GetCanvasManager();
        if (n.renderTarget = i,
        n.drawWidth = f.GetDrawWidth(),
        n.drawHeight = f.GetDrawHeight(),
        n.surfaceWidth = n.drawWidth,
        n.surfaceHeight = n.drawHeight,
        n.fxIndex = 0,
        n.otherFxIndex = 1,
        n.boxExtendHorizontal = 0,
        n.boxExtendVertical = 0,
        n.screenRect.set(0, 0, n.drawWidth, n.drawHeight),
        n.clearRect.set(0, 0, n.drawWidth, n.drawHeight),
        n.didChangeTransform = !1,
        n.opts = l,
        n.inst) {
            const e = n.wi;
            n.layerScale = e.GetLayer().GetRenderScale(),
            n.layerAngle = e.GetLayer().GetAngle(),
            n.layoutRect.copy(e.GetBoundingBox())
        } else if (n.layer) {
            const e = n.layer;
            n.layerScale = e.GetRenderScale(),
            n.layerAngle = e.GetAngle(),
            n.layoutRect.copy(e.GetViewport())
        } else {
            const e = n.layout;
            n.layerScale = e.GetScale(),
            n.layerAngle = e.GetAngle(),
            n.layoutRect.set(0, 0, n.drawWidth, n.drawHeight)
        }
        n.inst ? _(n, h) : (n.rcTexBounce.set(0, 0, n.drawWidth / n.surfaceWidth, n.drawHeight / n.surfaceHeight),
        n.rcTexDest.copy(n.rcTexBounce),
        n.rcTexOrigin.copy(n.rcTexBounce),
        n.rcTexBounce.swapTopBottom(),
        n.rcTexDest.swapTopBottom(),
        n.rcTexOrigin.swapTopBottom()),
        g.SetAlphaBlend(),
        g.ResetColor(),
        g.SetBaseZ(0),
        g.SetCurrentZ(0),
        n.preDraw = n.ShouldPreDraw(h[0]),
        n.preDraw && d(n),
        g.ResetColor();
        const p = h.length - 1;
        n.postDraw = n.ShouldPostDraw(h[p]);
        for (let t = 0, a = h.length; t < a; ++t) {
            const a = h[t]
              , i = a.GetShaderProgram();
            if (g.SetProgram(i),
            i.IsAnimated() && c.UpdateRender(),
            0 === t && !n.preDraw)
                e(n, a);
            else {
                g.SetCopyBlend();
                const e = t === p && !n.postDraw;
                r(n, a, e, t)
            }
            0 === n.fxIndex ? (n.fxIndex = 1,
            n.otherFxIndex = 0) : (n.fxIndex = 0,
            n.otherFxIndex = 1)
        }
        n.postDraw && u(n, h);
        const y = n.didChangeTransform;
        return a(n),
        S = !1,
        y
    }
}
{
    const e = /<(.+?)>/g;
    C3.TimelineManager = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._runtime = e,
            this._timelineDataManager = C3.New(C3.TimelineDataManager),
            this._pluginInstance = null,
            this._timelines = [],
            this._timelinesByName = new Map,
            this._objectClassToTimelineMap = new Map,
            this._timelinesCreatedByTemplate = new Map,
            this._scheduledTimelines = [],
            this._playingTimelines = [],
            this._hasRuntimeListeners = !1,
            this._changingLayout = !1,
            this._isTickingTimelines = !1,
            this._tickFunc = ()=>this._OnTick(),
            this._tick2Func = ()=>this._OnTick2(),
            this._beforeLayoutChange = ()=>this._OnBeforeChangeLayout(),
            this._layoutChange = ()=>this._OnAfterChangeLayout(),
            this._instanceDestroy = e=>this._OnInstanceDestroy(e.instance)
        }
        Release() {
            this.RemoveRuntimeListeners(),
            this._tickFunc = null,
            this._tick2Func = null,
            this._beforeLayoutChange = null,
            this._layoutChange = null,
            this._instanceDestroy = null;
            for (const e of this._timelines)
                e.Stop(),
                e.Release();
            C3.clearArray(this._timelines),
            this._timelines = null,
            this._timelineDataManager.Release(),
            this._timelineDataManager = null,
            C3.clearArray(this._scheduledTimelines),
            this._scheduledTimelines = null,
            C3.clearArray(this._playingTimelines),
            this._playingTimelines = null,
            this._timelinesByName.clear(),
            this._timelinesByName = null,
            this._objectClassToTimelineMap.clear(),
            this._objectClassToTimelineMap = null,
            this._timelinesCreatedByTemplate.clear(),
            this._timelinesCreatedByTemplate = null,
            this._runtime = null
        }
        AddRuntimeListeners() {
            const e = this._runtime.Dispatcher();
            e.addEventListener('pretick', this._tickFunc),
            e.addEventListener('tick2', this._tick2Func),
            e.addEventListener('beforelayoutchange', this._beforeLayoutChange),
            e.addEventListener('layoutchange', this._layoutChange),
            e.addEventListener('instancedestroy', this._instanceDestroy)
        }
        RemoveRuntimeListeners() {
            const e = this._runtime.Dispatcher();
            e.removeEventListener('pretick', this._tickFunc),
            e.removeEventListener('tick2', this._tick2Func),
            e.removeEventListener('beforelayoutchange', this._beforeLayoutChange),
            e.removeEventListener('layoutchange', this._layoutChange),
            e.removeEventListener('instancedestroy', this._instanceDestroy)
        }
        Create(e) {
            this._timelineDataManager.Add(e);
            const t = C3.TimelineState.CreateInitial(e, this);
            this.Add(t),
            this.SetTimelineObjectClassesToMap(t),
            this._timelinesCreatedByTemplate.set(t.GetName(), 0)
        }
        CreateFromTemplate(t) {
            const a = this.GetTimelineDataManager()
              , n = t.GetTemplateName()
              , r = a.Get(n)
              , i = C3.TimelineState.CreateFromTemplate(`${n}:${this._timelinesCreatedByTemplate.get(n)}`, r, this);
            return this._IncreaseTemplateTimelinesCount(n),
            this.Add(i),
            i
        }
        _IncreaseTemplateTimelinesCount(e) {
            this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1)
        }
        _SetCreatedTemplateTimelinesCount() {
            for (const e of this._timelines) {
                if (e.IsTemplate())
                    continue;
                const t = e.GetTemplateName();
                this._IncreaseTemplateTimelinesCount(t)
            }
        }
        _ClearCreatedTemplateTimelinesCount() {
            for (const e of this._timelinesCreatedByTemplate.keys())
                this._timelinesCreatedByTemplate.set(e, 0)
        }
        Add(e) {
            this._timelines.push(e),
            this._timelinesByName.set(e.GetName().toLowerCase(), e)
        }
        Remove(e) {
            e.IsTemplate() || (C3.arrayFindRemove(this._timelines, e),
            C3.arrayFindRemove(this._scheduledTimelines, e),
            C3.arrayFindRemove(this._playingTimelines, e),
            this._timelinesByName.delete(e.GetName().toLowerCase()),
            this.RemoveTimelineFromObjectClassMap(e),
            e.Release())
        }
        Trigger(e) {
            this._runtime.Trigger(e, this._pluginInstance, null)
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimelineDataManager() {
            return this._timelineDataManager
        }
        SetPluginInstance(e) {
            this._pluginInstance = e
        }
        GetPluginInstance() {
            return this._pluginInstance
        }
        *GetTimelines() {
            for (const e of this._timelines)
                yield e
        }
        SetTimelineObjectClassToMap(e, t) {
            this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, new Set),
            this._objectClassToTimelineMap.get(e).add(t)
        }
        SetTimelineObjectClassesToMap(e) {
            for (const t of e.GetObjectClasses())
                this.SetTimelineObjectClassToMap(t, e)
        }
        RemoveTimelineFromObjectClassMap(e) {
            for (const [t,a] of this._objectClassToTimelineMap.entries())
                a.has(e) && (a.delete(e),
                0 === a.size && this._objectClassToTimelineMap.delete(t))
        }
        GetTimelinesForObjectClass(e) {
            return this._objectClassToTimelineMap.has(e) ? this._objectClassToTimelineMap.get(e) : void 0
        }
        GetTimelineOfTemplateForInstances(e, t) {
            if (t)
                for (const n of this._timelines) {
                    const a = t.every(e=>n.HasTrackInstance(e.instance, e.trackId));
                    if (a && n.GetName().includes(e.GetName()))
                        return n
                }
        }
        GetTimelineByName(e) {
            return this._timelinesByName.get(e.toLowerCase()) || null
        }
        GetScheduledOrPlayingTimelineByName(e) {
            for (const t of this._scheduledTimelines)
                if (t.GetName() === e)
                    return t;
            for (const t of this._playingTimelines)
                if (t.GetName() === e)
                    return t;
            return null
        }
        *GetTimelinesByName(t) {
            if (e.test(t)) {
                e.lastIndex = 0;
                let n;
                const r = new Set;
                do
                    if (n = e.exec(t),
                    n) {
                        const e = n[1].split(',');
                        for (const t of e)
                            r.add(t)
                    }
                while (n);
                for (const e of r.values()) {
                    const t = this.GetTimelineByName(e);
                    t && (yield t)
                }
                r.clear()
            } else {
                const e = this.GetTimelineByName(t);
                e && (yield e)
            }
        }
        *GetTimelinesByTags(e) {
            for (const t of this._timelines)
                t.HasTags(e) && (yield t)
        }
        AddScheduledTimeline(e) {
            this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e),
            this._MaybeEnableRuntimeListeners()
        }
        RemovePlayingTimeline(e) {
            C3.arrayFindRemove(this._playingTimelines, e),
            this._MaybeDisableRuntimeListeners()
        }
        ScheduleTimeline(e) {
            e.SetPlaying(!1),
            e.SetScheduled(!0),
            e.SetMarkedForRemoval(!1),
            this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e),
            this._MaybeEnableRuntimeListeners()
        }
        DeScheduleTimeline(e) {
            e.SetPlaying(!1),
            e.SetScheduled(!1),
            e.ResolvePlayPromise(),
            C3.arrayFindRemove(this._scheduledTimelines, e),
            this._MaybeDisableRuntimeListeners()
        }
        CompleteTimeline(e) {
            e.SetPlaying(!1),
            e.SetScheduled(!1),
            e.SetMarkedForRemoval(!0)
        }
        CompleteTimelineAndResolve(e) {
            this.CompleteTimeline(e),
            e.ResolvePlayPromise()
        }
        _OnTick() {
            if (!this._hasRuntimeListeners)
                return;
            if (this._changingLayout)
                return;
            let t = !1;
            for (this._isTickingTimelines = !0; this._scheduledTimelines.length; ) {
                const e = this._scheduledTimelines.pop();
                e.SetInitialState(),
                this._playingTimelines.push(e)
            }
            const n = this._runtime.GetDt()
              , r = this._runtime.GetTimeScale();
            for (const a of this._playingTimelines) {
                if (a.IsMarkedForRemoval())
                    continue;
                const i = a.Tick(n, r);
                !t && i && (t = !0)
            }
            this._isTickingTimelines = !1,
            t && this.GetRuntime().UpdateRender()
        }
        _OnTick2() {
            if (!this._hasRuntimeListeners)
                return;
            let e;
            for (const t of this._playingTimelines)
                t.IsMarkedForRemoval() && (e || (e = new Set),
                this._MaybeExecuteTimelineFinishTriggers(t),
                e.add(t));
            e && C3.arrayRemoveAllInSet(this._playingTimelines, e),
            this._MaybeDisableRuntimeListeners()
        }
        _MaybeExecuteTimelineFinishTriggers(e) {
            e.IsReleased() || !e.HasValidTracks() || e.IsComplete() && e.InitialStateSet() && e.FinishTriggers()
        }
        _MaybeEnableRuntimeListeners() {
            this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
        }
        _MaybeDisableRuntimeListeners() {
            this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
        }
        _OnBeforeChangeLayout() {
            for (this._changingLayout = !0; this._scheduledTimelines.length; )
                this.DeScheduleTimeline(this._scheduledTimelines.pop());
            for (; this._playingTimelines.length; ) {
                const e = this._playingTimelines.pop();
                e.IsReleased() || (this.CompleteTimeline(e),
                e.Reset(!1))
            }
            this._MaybeDisableRuntimeListeners();
            for (const e of this._timelines)
                e.CleanCaches()
        }
        _OnAfterChangeLayout() {
            this._changingLayout = !1
        }
        _OnInstanceDestroy(e) {
            const t = e.GetObjectClass()
              , n = this.GetTimelinesForObjectClass(t);
            if (n)
                for (const e of n)
                    e.IsTemplate() || e.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e),
                    this.Remove(e))
        }
        _SaveToJson() {
            return {
                timelinesJson: this._SaveTimelinesToJson(),
                scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
                playingTimelinesJson: this._SavePlayingTimelinesToJson(),
                hasRuntimeListeners: this._hasRuntimeListeners,
                changingLayout: this._changingLayout,
                isTickingTimelines: this._isTickingTimelines
            }
        }
        _LoadFromJson(e) {
            e && (this._ClearCreatedTemplateTimelinesCount(),
            this._LoadTimelinesFromJson(e.timelinesJson),
            this._LoadScheduledTimelinesFromJson(e.scheduledTimelinesJson),
            this._LoadPlayingTimelinesFromJson(e.playingTimelinesJson),
            this._hasRuntimeListeners = !e.hasRuntimeListeners,
            this._changingLayout = !!e.changingLayout,
            this._isTickingTimelines = !!e.isTickingTimelines,
            this._SetCreatedTemplateTimelinesCount(),
            this._MaybeEnableRuntimeListeners(),
            this._MaybeDisableRuntimeListeners())
        }
        _SaveTimelinesToJson() {
            return this._timelines.map(e=>e._SaveToJson())
        }
        _LoadTimelinesFromJson(e) {
            for (const t of e) {
                let e = this.GetTimelineByName(t.name);
                if (e)
                    e._LoadFromJson(t);
                else {
                    const a = this._GetTemplateNameFromJson(t);
                    if (!a)
                        continue;
                    const n = this.GetTimelineByName(a);
                    e = this.CreateFromTemplate(n),
                    e._LoadFromJson(t)
                }
                e.HasTracks() || this.Remove(e)
            }
        }
        _GetTemplateNameFromJson(e) {
            const t = e.name
              , a = t.split(':');
            return a && 2 === a.length ? a[0] : null
        }
        _SaveScheduledTimelinesToJson() {
            return this._SaveTimelines(this._scheduledTimelines)
        }
        _LoadScheduledTimelinesFromJson(e) {
            this._LoadTimelines(e, this._scheduledTimelines)
        }
        _SavePlayingTimelinesToJson() {
            return this._SaveTimelines(this._playingTimelines)
        }
        _LoadPlayingTimelinesFromJson(e) {
            this._LoadTimelines(e, this._playingTimelines)
        }
        _IsTimelineInJson(e, t) {
            for (const a of t)
                if (a === e.GetName())
                    return !0;
            return !1
        }
        _SaveTimelines(e) {
            return e.map(e=>e.GetName())
        }
        _LoadTimelines(e, t) {
            const n = e=>t=>t.GetName() === e;
            for (const a of t)
                this._IsTimelineInJson(a, e) || C3.arrayFindRemove(t, a);
            for (const r of e) {
                const i = this.GetTimelineByName(r);
                if (i) {
                    const a = t.find(n(r));
                    a || t.push(i)
                }
            }
        }
    }
}
{
    const e = 0;
    C3.TimelineState = class extends C3.DefendedBase {
        constructor(t, a, n) {
            super(),
            this._runtime = n.GetRuntime(),
            this._timelineManager = n,
            this._timelineDataItem = a,
            this._name = t,
            this._tracks = [];
            for (const e of this._timelineDataItem.GetTrackData().trackDataItems())
                this._tracks.push(C3.TrackState.Create(this, e));
            this._playPromise = null,
            this._playResolve = null,
            this._playheadTime = C3.New(C3.KahanSum),
            this._playheadTime.Set(0),
            this._playbackRate = 1,
            this._pingPongState = e,
            this._currentRepeatCount = 1,
            this._isPlaying = !1,
            this._isScheduled = !1,
            this._initialStateSet = !1,
            this._complete = !0,
            this._released = !1,
            this._markedForRemoval = !1,
            this._completedTick = -1,
            this._implicitPause = !1,
            this._isTemplate = !1,
            this._finishedTriggers = !1,
            this._tags = [''],
            this._stringTags = '',
            this._tagsChanged = !1
        }
        static CreateInitial(t, a) {
            const n = a.GetTimelineDataManager()
              , r = n.GetNameId()
              , i = n.Get(t[r])
              , e = C3.New(C3.TimelineState, t[r], i, a);
            return e.SetIsTemplate(!0),
            e
        }
        static CreateFromTemplate(e, t, a) {
            return C3.New(C3.TimelineState, e, t, a)
        }
        static get WORLD_INSTANCE_BOX_CHANGE() {
            return 1
        }
        static get LAYOUT_RENDER_CHANGE() {
            return C3.nextHighestPowerOfTwo(1)
        }
        Release() {
            if (!this.IsReleased()) {
                this._timelineManager.DeScheduleTimeline(this),
                this._timelineManager.CompleteTimelineAndResolve(this);
                for (const e of this._tracks)
                    e.Release();
                C3.clearArray(this._tracks),
                this._tracks = null,
                this._playheadTime.Release(),
                this._playheadTime = null,
                this._runtime = null,
                this._timelineManager = null,
                this._timelineDataItem = null,
                this._released = !0,
                this._playPromise = null,
                this._playResolve = null
            }
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetTracks() {
            return this._tracks
        }
        HasTracks() {
            return !!this._tracks.length
        }
        GetTrackById(e) {
            for (const t of this._tracks)
                if (C3.equalsNoCase(t.GetId(), e))
                    return t;
            return null
        }
        SetName(e) {
            this._name = e
        }
        GetName() {
            return this._name
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        GetTemplateName() {
            return this._timelineDataItem.GetName()
        }
        GetTotalTime() {
            return this._timelineDataItem.GetTotalTime()
        }
        SetTotalTime(e) {
            this._timelineDataItem.SetTotalTime(e)
        }
        GetStep() {
            return this._timelineDataItem.GetStep()
        }
        SetStep(e) {
            this._timelineDataItem.SetStep(e)
        }
        GetInterpolationMode() {
            return this._timelineDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(e) {
            this._timelineDataItem.SetInterpolationMode(e)
        }
        GetResultMode() {
            return this._timelineDataItem.GetResultMode()
        }
        SetResultMode(e) {
            this._timelineDataItem.GetResultMode(e)
        }
        SetEase(e) {
            for (const t of this.GetTracks())
                t.SetEase(e)
        }
        GetLoop() {
            return this._timelineDataItem.GetLoop()
        }
        GetPingPong() {
            return this._timelineDataItem.GetPingPong()
        }
        GetRepeatCount() {
            return this._timelineDataItem.GetRepeatCount()
        }
        SetPlaybackRate(e) {
            return this._playbackRate = e
        }
        GetPlaybackRate() {
            return this._playbackRate
        }
        IsForwardPlayBack() {
            return !this.IsPlaying() || 0 < this._playbackRate
        }
        GetPlayPromise() {
            return this._playPromise ? this._playPromise : (this._playPromise = new Promise(e=>{
                this._playResolve = e
            }
            ),
            this._playPromise)
        }
        ResolvePlayPromise() {
            this._playPromise && (this._playResolve(),
            this._playPromise = null,
            this._playResolve = null)
        }
        SetTags(e) {
            this._tags = C3.TimelineState._GetTagArray(e),
            this._tagsChanged = !0
        }
        GetTags() {
            return this._tags
        }
        GetStringTags() {
            return this._tagsChanged && (this._stringTags = this._tags.join(' ')),
            this._tagsChanged = !1,
            this._stringTags
        }
        HasTags(e) {
            if (!this._tags)
                return !1;
            if (!this._tags.length)
                return !1;
            const t = C3.TimelineState._GetTagArray(e);
            return !!t && !!t.length && t.every(C3.TimelineState._HasTag, this)
        }
        OnStarted() {
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStarted),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStartedByName),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStartedByTags),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnAnyTimelineStarted),
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            this._finishedTriggers || (this._finishedTriggers = !0,
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinished),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinishedByName),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinishedByTags),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        SetPlaying(e) {
            this._isPlaying = e
        }
        IsCompletedTick() {
            return this._completedTick === this._runtime.GetTickCount()
        }
        IsPlaying() {
            return !!this.IsCompletedTick() || this._isPlaying
        }
        SetScheduled(e) {
            this._isScheduled = e
        }
        IsScheduled() {
            return this._isScheduled
        }
        SetComplete(e) {
            this._complete = e;
            const t = this.GetTime();
            (0 >= t || t >= this.GetTotalTime()) && (this._complete = !0)
        }
        IsComplete() {
            return this._complete
        }
        IsReleased() {
            return this._released
        }
        SetMarkedForRemoval(e) {
            this._markedForRemoval = e
        }
        IsMarkedForRemoval() {
            return this._markedForRemoval
        }
        SetImplicitPause(e) {
            this._implicitPause = e
        }
        IsImplicitPause() {
            return this._implicitPause
        }
        SetIsTemplate(e) {
            this._isTemplate = !!e
        }
        IsTemplate() {
            return this._isTemplate
        }
        InitialStateSet() {
            return this._initialStateSet
        }
        GetTime() {
            return this._playheadTime.Get()
        }
        SetTime(e) {
            this._SetTime(e),
            this.SetComplete(!1),
            this.IsComplete() || this.SetImplicitPause(!0),
            (this.IsPlaying() || this.IsScheduled() || !this._initialStateSet) && (this.IsPlaying() || this.IsScheduled() || this._initialStateSet ? this.IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this),
            this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime());
            let t = !1;
            for (const n of this._tracks) {
                n.SetResumeState();
                const e = n.Interpolate(this._playheadTime.Get(), !1, !0);
                !t && e && (t = !0)
            }
            t && this.GetRuntime().UpdateRender(),
            this._OnSetTime()
        }
        _SetTime(e) {
            0 > e ? this._playheadTime.Set(0) : e >= this.GetTotalTime() ? this._playheadTime.Set(this.GetTotalTime()) : this._playheadTime.Set(e)
        }
        _OnSetTime() {
            C3.Plugins.Timeline && this.constructor === C3.TimelineState && (C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSet),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSetByName),
            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSetByTags),
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        Resume() {
            if (!this.IsReleased()) {
                if (this.IsForwardPlayBack()) {
                    if (this._playheadTime.Get() >= this.GetTotalTime())
                        return;
                } else if (0 >= this._playheadTime.Get())
                    return;
                this.Play(!0)
            }
        }
        Play(e=!1) {
            return !this.IsReleased() && !this.IsScheduled() && (this.IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this.IsPlaying() && !!(this.IsComplete() || e || this.IsImplicitPause()) && this._ScheduleStoppedTimeline())
        }
        _SchedulePlayingTimeline() {
            return this.SetImplicitPause(!1),
            this._timelineManager.RemovePlayingTimeline(this),
            this._timelineManager.ScheduleTimeline(this),
            this.GetPlayPromise(),
            !0
        }
        _ScheduleStoppedTimeline() {
            return this.SetImplicitPause(!1),
            this._timelineManager.ScheduleTimeline(this),
            this.GetPlayPromise(),
            !0
        }
        Stop(e=!1) {
            this.IsReleased() || (this.SetComplete(e),
            this._timelineManager.CompleteTimeline(this),
            this.IsComplete() && this.ResolvePlayPromise())
        }
        Reset(e=!0) {
            if (this.IsReleased())
                return;
            if (!this.IsPlaying() && this.IsScheduled())
                return this._timelineManager.DeScheduleTimeline(this);
            if (this.IsComplete())
                return;
            this.Stop(!0),
            this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
            let t = !1;
            for (const n of this._tracks) {
                const e = n.Interpolate(this._playheadTime.Get());
                !t && e && (t = !0)
            }
            e && this._OnSetTime(),
            t && e && this.GetRuntime().UpdateRender()
        }
        SetInitialStateFromSetTime() {
            this.SetInitialState(!0)
        }
        SetInitialState(t) {
            if (!this.IsMarkedForRemoval())
                if (t) {
                    this._initialStateSet = !0;
                    for (const e of this._tracks)
                        e.SetInitialState()
                } else if (this.SetPlaying(!0),
                this.SetScheduled(!1),
                this.OnStarted(),
                this.IsComplete()) {
                    this._completedTick = -1,
                    this._pingPongState = e,
                    this._currentRepeatCount = 1,
                    this._complete = !1,
                    this._finishedTriggers = !1,
                    this._initialStateSet = !0,
                    this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                    for (const e of this._tracks)
                        e.SetInitialState()
                } else
                    for (const e of this._tracks)
                        e.SetResumeState()
        }
        Tick(e, t) {
            this._playheadTime.Add(e * t * this._playbackRate);
            let a;
            if (this.GetLoop() || this.GetPingPong() ? this.GetLoop() && !this.GetPingPong() ? a = this._LoopCompleteCheck() : !this.GetLoop() && this.GetPingPong() ? a = this._PingPongCompleteCheck() : this.GetLoop() && this.GetPingPong() && (a = this._LoopPingPongCompleteCheck()) : a = this._SimpleCompleteCheck(),
            a) {
                for (const e of this._tracks)
                    e.SetEndState();
                return this.Stop(!0),
                this.OnCompleted(),
                !0
            } else {
                let e = !1;
                for (const t of this._tracks) {
                    const a = t.Interpolate(this._playheadTime.Get(), !0);
                    !e && a && (e = !0)
                }
                return e
            }
        }
        _SimpleCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this._playheadTime.Get() >= this.GetTotalTime())
                    if (this._currentRepeatCount < this.GetRepeatCount())
                        this._currentRepeatCount++,
                        this._SetTime(0);
                    else
                        return this._SetTime(this.GetTotalTime()),
                        !0;
            } else if (0 >= this._playheadTime.Get())
                if (this._currentRepeatCount < this.GetRepeatCount())
                    this._currentRepeatCount++,
                    this._SetTime(this.GetTotalTime());
                else
                    return this._SetTime(0),
                    !0;
            return !1
        }
        _LoopCompleteCheck() {
            return this.IsForwardPlayBack() ? this._playheadTime.Get() >= this.GetTotalTime() && this._SetTime(0) : 0 >= this._playheadTime.Get() && this._SetTime(this.GetTotalTime()),
            !1
        }
        _PingPongCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this._playheadTime.Get() >= this.GetTotalTime())
                    if (this._SetTime(this.GetTotalTime()),
                    this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                    1 !== this._pingPongState)
                        this._pingPongState === e && (this._pingPongState = 1);
                    else if (this._currentRepeatCount < this.GetRepeatCount())
                        this._currentRepeatCount++,
                        this._pingPongState = e;
                    else
                        return !0;
            } else if (0 >= this._playheadTime.Get())
                if (this._SetTime(0),
                this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                1 !== this._pingPongState)
                    this._pingPongState === e && (this._pingPongState = 1);
                else if (this._currentRepeatCount < this.GetRepeatCount())
                    this._currentRepeatCount++,
                    this._pingPongState = e;
                else
                    return !0;
            return !1
        }
        _LoopPingPongCompleteCheck() {
            return this.IsForwardPlayBack() ? this._playheadTime.Get() >= this.GetTotalTime() && (this._SetTime(this.GetTotalTime()),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this._playheadTime.Get() && (this._SetTime(0),
            this.SetPlaybackRate(-1 * this.GetPlaybackRate())),
            !1
        }
        AddTrack() {
            const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem()
              , t = C3.TrackState.Create(this, e);
            return this._tracks.push(t),
            t
        }
        CleanCaches() {
            for (const e of this._tracks)
                e.CleanCaches()
        }
        ClearTrackInstances() {
            for (const e of this._tracks)
                e.ClearInstance()
        }
        SetTrackInstance(e, t) {
            if (t)
                for (const a of this._tracks)
                    if (e) {
                        if (a.GetId() !== e)
                            continue;
                        a.SetInstance(t),
                        this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                        break
                    } else {
                        if (a.HasInstance())
                            continue;
                        a.SetInstance(t),
                        this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                        break
                    }
        }
        HasTrackInstance(e, t) {
            for (const a of this._tracks)
                if (t) {
                    if (t === a.GetId() && e === a.GetInstance())
                        return !0;
                } else if (e === a.GetInstance())
                    return !0;
            return !1
        }
        HasValidTracks() {
            return this._tracks.some(e=>e.CanInstanceBeValid())
        }
        GetPropertyTrack(e) {
            for (const t of this.GetTracks())
                for (const a of t.GetPropertyTracks())
                    if (a.GetPropertyName() === e)
                        return a
        }
        GetKeyframeWithTags(e) {
            let t = e ? e.split(' ') : [];
            const a = new Set(t.map(e=>e.toLowerCase().trim()));
            t = [...a.values()];
            for (const n of this.GetTracks())
                for (const e of n.GetKeyframeDataItems()) {
                    const a = t.every(t=>e.HasTag(t));
                    if (a)
                        return e
                }
        }
        GetObjectClasses() {
            const e = [];
            for (const t of this.GetTracks())
                e.push(t.GetObjectClass());
            return e.filter(e=>e)
        }
        _SaveToJson() {
            return {
                tracksJson: this._SaveTracksToJson(),
                name: this._name,
                playheadTime: this._playheadTime.Get(),
                playbackRate: this._playbackRate,
                pingPongState: this._pingPongState,
                currentRepeatCount: this._currentRepeatCount,
                isPlaying: this._isPlaying,
                isScheduled: this._isScheduled,
                initialStateSet: this._initialStateSet,
                finishedTriggers: this._finishedTriggers,
                complete: this._complete,
                released: this._released,
                markedForRemoval: this._markedForRemoval,
                completedTick: this._completedTick,
                implicitPause: this._implicitPause,
                isTemplate: this._isTemplate,
                tags: this._tags.join(' '),
                stringTags: this._stringTags,
                tagsChanged: this._tagsChanged
            }
        }
        _LoadFromJson(e) {
            e && (this._LoadTracksFromJson(e.tracksJson),
            this._name = e.name,
            this._playheadTime.Set(e.playheadTime),
            this._playbackRate = e.playbackRate,
            this._pingPongState = e.pingPongState,
            this._currentRepeatCount = e.currentRepeatCount,
            this._isPlaying = !!e.isPlaying,
            this._isScheduled = !!e.isScheduled,
            this._initialStateSet = !!e.initialStateSet,
            this._finishedTriggers = !!e.hasOwnProperty('finishedTriggers') && !!e.finishedTriggers,
            this._complete = !!e.complete,
            this._released = !!e.released,
            this._markedForRemoval = !!e.markedForRemoval,
            this._completedTick = e.completedTick,
            this._implicitPause = !!e.implicitPause,
            this._isTemplate = !!e.isTemplate,
            this._tags = e.tags.split(' '),
            this._stringTags = e.stringTags,
            this._tagsChanged = !!e.tagsChanged)
        }
        _SaveTracksToJson() {
            return this._tracks.map(e=>e._SaveToJson())
        }
        _LoadTracksFromJson(e) {
            e.forEach((e,t)=>{
                const a = this._tracks[t];
                a._LoadFromJson(e)
            }
            ),
            this._tracks.filter(e=>e.CanInstanceBeValid())
        }
        static _HasTag(e) {
            const t = this.GetTags();
            return '' === e ? 1 === t.length && '' === t[0] : t.includes(e)
        }
        static _GetTagArray(e) {
            return C3.IsArray(e) ? e.slice(0) : C3.IsString(e) ? e.split(' ') : void 0
        }
    }
}
'use strict',
C3.TrackState = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._timeline = e,
        this._trackDataItem = t,
        this._trackData = t.GetTrackData(),
        this._instanceUid = NaN,
        this._objectClassIndex = NaN,
        this._instance = null,
        this._worldInfo = null,
        this._lastKeyframeDataItem = null,
        this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(),
        this._propertyTracks = [];
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3.PropertyTrackState.Create(this, a))
    }
    static Create(e, t) {
        return C3.New(C3.TrackState, e, t)
    }
    Release() {
        this._keyframeDataItems = null;
        for (const e of this._propertyTracks)
            e.Release();
        C3.clearArray(this._propertyTracks),
        this._propertyTracks = null,
        this._timeline = null,
        this._instance = null,
        this._worldInfo = null,
        this._trackDataItem = null,
        this._lastKeyframeDataItem = null
    }
    CleanCaches() {
        for (const e of this._propertyTracks)
            e.CleanCaches();
        this._instance = null,
        this._worldInfo = null
    }
    GetTimeline() {
        return this._timeline
    }
    GetRuntime() {
        return this._timeline.GetRuntime()
    }
    GetKeyframeDataItems() {
        return this._keyframeDataItems ? this._keyframeDataItems : (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(),
        this._keyframeDataItems)
    }
    GetPropertyTracks() {
        return this._propertyTracks
    }
    GetPropertyTrack(e) {
        for (const t of this._propertyTracks)
            if (t.GetPropertyName() === e)
                return t
    }
    MaybeGetInstance() {
        this._instance || this.GetInstance()
    }
    IsInstanceValid() {
        return !!this._instance && !this._instance.IsDestroyed()
    }
    CanInstanceBeValid() {
        const e = this.GetInstanceUID()
          , t = this.GetRuntime().GetInstanceByUID(e);
        return !!t && !t.IsDestroyed()
    }
    GetObjectClass() {
        const e = this.GetObjectClassIndex();
        return -1 === e ? void 0 : this.GetRuntime().GetObjectClassByIndex(e)
    }
    ClearInstance() {
        this._instance = null,
        this._instanceUid = -1,
        this._worldInfo = null,
        this._objectClassIndex = -1
    }
    HasInstance() {
        return !!this._instance
    }
    GetInstance() {
        if (this._instance && this.IsInstanceValid())
            return this._instance;
        const e = this.GetInstanceUID();
        return this._instance = this.GetRuntime().GetInstanceByUID(e),
        this._instance
    }
    SetInstance(e) {
        if (this._instance !== e) {
            this.CleanCaches(),
            this._instance = e,
            this._objectClassIndex = e.GetObjectClass().GetIndex(),
            this._instanceUid = e.GetUID(),
            this._worldInfo = e.GetWorldInfo();
            for (const t of this.propertyTrackItems()) {
                const e = t.propertyTrack
                  , n = t.sourceAdapter
                  , a = e.GetSourceAdapterId();
                switch (a) {
                case 'instance-variable':
                    {
                        const a = n.GetEditorIndex()
                          , r = inst.GetObjectClass()
                          , i = r.GetInstanceVariableIndexByName(t.name)
                          , e = r.GetInstanceVariableName(i)
                          , l = r.GetInstanceVariableType(i);
                        e === t.name && l === t.type && n.UpdateInstanceVariableIndex(i);
                        break
                    }
                case 'behavior':
                    {
                        const r = t.behaviorType
                          , l = this.GetObjectClass()
                          , _ = inst.GetObjectClass()
                          , e = n.GetBehaviorType(_);
                        if (r && e) {
                            const t = r.GetName()
                              , a = l.GetBehaviorIndexByName(t)
                              , d = _.GetBehaviorIndexByName(t)
                              , u = n.GetEditorIndex();
                            n.UpdateBehaviorTypeSid(e.GetSID())
                        }
                        break
                    }
                }
            }
        }
    }
    *propertyTrackItems() {
        for (const e of this._propertyTracks) {
            const t = e.GetSourceAdapter()
              , n = this.GetObjectClass()
              , r = {
                propertyTrack: e,
                sourceAdapter: t
            };
            switch (e.GetSourceAdapterId()) {
            case 'world-instance':
                {
                    r.property = e.GetPropertyName();
                    break
                }
            case 'instance-variable':
                {
                    const e = t.GetEditorIndex();
                    r.name = n.GetInstanceVariableName(e),
                    r.type = n.GetInstanceVariableType(e);
                    break
                }
            case 'effect':
                {
                    const i = n.GetEffectList()
                      , a = t.GetEffectType(i);
                    r.effectType = a;
                    break
                }
            case 'behavior':
                {
                    const e = t.GetBehaviorType(n);
                    r.behaviorType = e;
                    break
                }
            case 'plugin':
                {
                    r.plugin = n.GetPlugin();
                    break
                }
            }
            yield r
        }
    }
    GetWorldInfo() {
        if (this._worldInfo && this.IsInstanceValid())
            return this._worldInfo;
        const e = this.GetInstance();
        return e && (this._worldInfo = e.GetWorldInfo()),
        this._worldInfo
    }
    GetTrackDataItem() {
        return this._trackDataItem
    }
    GetInstanceUID() {
        return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
    }
    SetInstanceUID(e) {
        this._trackDataItem.SetInstanceUID(e)
    }
    GetInterpolationMode() {
        return this._trackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(e) {
        this._trackDataItem.SetInterpolationMode(e)
    }
    GetResultMode() {
        return this._trackDataItem.GetResultMode()
    }
    GetId() {
        return this._trackDataItem.GetId()
    }
    SetResultMode(e) {
        this._trackDataItem.SetResultMode(e)
    }
    SetEase(e) {
        for (const t of this.GetKeyframeDataItems())
            t.SetEase(e);
        for (const t of this.GetPropertyTracks())
            t.SetEase(e)
    }
    GetEnable() {
        return this._trackDataItem.GetEnable()
    }
    SetEnable(e) {
        this._trackDataItem.SetEnable(e)
    }
    GetObjectClassIndex() {
        return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
    }
    SetObjectClassIndex(e) {
        this._trackDataItem.SetObjectClassIndex(e)
    }
    SetInitialState() {
        if (this.MaybeGetInstance(),
        !!this.IsInstanceValid()) {
            for (const e of this._propertyTracks)
                e.SetInitialState();
            const e = this.GetTimeline()
              , t = e.IsForwardPlayBack()
              , a = e.GetTotalTime()
              , n = t ? 0 : a;
            this._lastKeyframeDataItem = this._trackData.GetKeyFrameDataItemAtTime(n, this._trackDataItem),
            this.Interpolate(n)
        }
    }
    SetResumeState() {
        if (this.MaybeGetInstance(),
        !!this.IsInstanceValid()) {
            const e = this._timeline.IsForwardPlayBack()
              , t = this._timeline.GetTime();
            this._timeline.IsForwardPlayBack() ? this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem) : (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem),
            !this._lastKeyframeDataItem && (this._lastKeyframeDataItem = this._trackData.GetLastKeyframeDataItem(this._trackDataItem)));
            for (const e of this._propertyTracks)
                e.SetResumeState()
        }
    }
    SetEndState() {
        if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(),
        !!this.IsInstanceValid())) {
            const e = this._timeline.GetTime()
              , t = this._timeline.GetTotalTime();
            e >= t ? this.Interpolate(t, !0) : 0 >= e && this.Interpolate(0, !0)
        }
    }
    Interpolate(t, a=!1, n=!1) {
        if (this.MaybeGetInstance(),
        !this.IsInstanceValid())
            return !1;
        this._lastKeyframeDataItem = this.MaybeTriggerKeyframeReachedConditions(t, a);
        let r = !1
          , i = !1;
        for (const e of this._propertyTracks) {
            const a = e.Interpolate(t, n);
            r || 0 == (a & C3.TimelineState.WORLD_INSTANCE_BOX_CHANGE) || (r = !0),
            i || 0 == (a & C3.TimelineState.LAYOUT_RENDER_CHANGE) || (i = !0)
        }
        if (r) {
            const e = this.GetWorldInfo();
            e && e.SetBboxChanged()
        }
        return i
    }
    MaybeTriggerKeyframeReachedConditions(e, t) {
        if (!t)
            return;
        const a = this.GetTimeline();
        let n = this._trackData.GetKeyFrameDataItemAtTime(e, this._trackDataItem);
        return n ? this.OnKeyframeReached(n) : (n = a.IsForwardPlayBack() ? this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(e, this._trackDataItem) : this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(e, this._trackDataItem),
        n !== this._lastKeyframeDataItem && this.OnKeyframeReached(n)),
        n
    }
    OnKeyframeReached(e) {
        if (C3.Plugins.Timeline && this.GetTimeline().constructor === C3.TimelineState) {
            const t = this.GetTimeline();
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(t),
            C3.Plugins.Timeline.Cnds.SetTriggerKeyframe(e);
            const a = t.GetTimelineManager();
            a.Trigger(C3.Plugins.Timeline.Cnds.OnAnyKeyframeReached),
            a.Trigger(C3.Plugins.Timeline.Cnds.OnKeyframeReached),
            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null),
            C3.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
        }
    }
    AddKeyframe() {
        const e = this._trackDataItem.GetKeyframeData()
          , t = e.AddEmptyKeyframeDataItem();
        return t
    }
    AddPropertyTrack() {
        const e = this._trackDataItem.GetPropertyTrackData()
          , t = e.AddEmptyPropertyTrackDataItem()
          , a = C3.PropertyTrackState.Create(this, t);
        return this._propertyTracks.push(a),
        a
    }
    DeleteKeyframes(e) {
        const t = this._trackDataItem.GetKeyframeData();
        t.DeleteKeyframeDataItems(e)
    }
    DeletePropertyKeyframes(e) {
        for (const t of this._propertyTracks)
            t.DeletePropertyKeyframes(e)
    }
    SaveState() {
        for (const e of this._propertyTracks)
            e.SaveState()
    }
    CompareInitialStateWithCurrent() {
        if (this.MaybeGetInstance(),
        !!this.IsInstanceValid())
            for (const e of this._propertyTracks)
                e.CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
        if (this.MaybeGetInstance(),
        !this.IsInstanceValid())
            return;
        let e = !1;
        for (const t of this._propertyTracks) {
            const a = t.CompareSaveStateWithCurrent();
            !e && a && (e = !0)
        }
        if (e) {
            const e = this.AddKeyframe();
            e.SetTime(this.GetTimeline().GetTime()),
            e.SetEase('noease'),
            e.SetEnable(!0),
            e.SetTags('')
        }
    }
    _SaveToJson() {
        return {
            propertyTracksJson: this._SavePropertyTracksToJson(),
            lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
            instanceUid: this._instanceUid
        }
    }
    _LoadFromJson(e) {
        e && (this._LoadPropertyTracksFromJson(e.propertyTracksJson),
        this._LoadLastKeyframeDataItemFromJson(e.lastKeyframeDataItemJson),
        this._LoadInstanceFromJson(e.instanceUid))
    }
    _SaveLastKeyframeDataItemToJson() {
        const e = this._trackDataItem.GetKeyframeData();
        return e.GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
    }
    _SavePropertyTracksToJson() {
        return this._propertyTracks.map(e=>e._SaveToJson())
    }
    _LoadPropertyTracksFromJson(e) {
        e.forEach((e,t)=>{
            const a = this._propertyTracks[t];
            a._LoadFromJson(e)
        }
        )
    }
    _LoadInstanceFromJson(e) {
        if (C3.IsFiniteNumber(e)) {
            const t = this.GetRuntime().GetInstanceByUID(e);
            if (t) {
                const e = this.GetTimeline();
                e.ClearTrackInstances(),
                e.SetTrackInstance(this._trackDataItem.GetId(), t)
            }
        }
    }
    _LoadLastKeyframeDataItemFromJson(e) {
        const t = this._trackDataItem.GetKeyframeData();
        this._lastKeyframeDataItem = t.GetKeyframeDataItemFromIndex(e)
    }
}
,
'use strict',
C3.PropertyTrackState = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._track = e,
        this._propertyTrackDataItem = t,
        this._propertyTrackData = t.GetPropertyTrackData(),
        this._sourceAdapter = this.GetSourceAdapter(),
        this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
    }
    static Create(e, t) {
        return C3.New(C3.PropertyTrackState, e, t)
    }
    Release() {
        this._track = null,
        this._sourceAdapter && (this._sourceAdapter.Release(),
        this._sourceAdapter = null),
        this._propertyKeyframeDataItems = null,
        this._propertyTrackDataItem = null,
        this._propertyTrackData = null
    }
    GetTrack() {
        return this._track
    }
    GetPropertyTrackDataItem() {
        return this._propertyTrackDataItem
    }
    GetPropertyTrackData() {
        return this._propertyTrackData
    }
    GetTimeline() {
        return this._track.GetTimeline()
    }
    GetRuntime() {
        return this._track.GetRuntime()
    }
    GetSourceAdapter() {
        if (this._sourceAdapter)
            return this._sourceAdapter;
        const e = this._propertyTrackDataItem.GetSourceAdapterId();
        let t;
        return 'behavior' === e ? t = new C3.PropertyTrackState.BehaviorSourceAdapter(this) : 'effect' === e ? t = new C3.PropertyTrackState.EffectSourceAdapter(this) : 'instance-variable' === e ? t = new C3.PropertyTrackState.InstanceVariableSourceAdapter(this) : 'plugin' === e ? t = new C3.PropertyTrackState.PluginSourceAdapter(this) : 'world-instance' === e ? t = new C3.PropertyTrackState.WorldInstanceSourceAdapter(this) : 'value' === e ? t = new C3.PropertyTrackState.ValueSourceAdapter(this) : void 0,
        this._sourceAdapter = t,
        this._sourceAdapter
    }
    GetSourceAdapterId() {
        return this._propertyTrackDataItem.GetSourceAdapterId()
    }
    SetSourceAdapterId(e) {
        this._propertyTrackDataItem.SetSourceAdapterId(e)
    }
    GetSourceAdapterArgs() {
        return this._propertyTrackDataItem.GetSourceAdapterArguments()
    }
    SetSourceAdapterArgs(e) {
        this._propertyTrackDataItem.SetSourceAdapterArguments(e)
    }
    GetSourceAdapterValue() {
        return this.GetSourceAdapter().GetValue()
    }
    GetPropertyName() {
        return this._propertyTrackDataItem.GetProperty()
    }
    SetPropertyName(e) {
        this._propertyTrackDataItem.SetProperty(e)
    }
    GetPropertyType() {
        return this._propertyTrackDataItem.GetType()
    }
    SetPropertyType(e) {
        this._propertyTrackDataItem.SetType(e)
    }
    GetPropertyKeyframeType() {
        return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
    }
    GetMin() {
        return this._propertyTrackDataItem.GetMin()
    }
    SetMin(e) {
        this._propertyTrackDataItem.SetMin(e)
    }
    GetMax() {
        return this._propertyTrackDataItem.GetMax()
    }
    SetMax(e) {
        this._propertyTrackDataItem.SetMax(e)
    }
    GetEnable() {
        return this._propertyTrackDataItem.GetEnable()
    }
    SetEnable(e) {
        this._propertyTrackDataItem.SetEnable(e)
    }
    GetInterpolationMode() {
        return this._propertyTrackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(e) {
        this._propertyTrackDataItem.SetInterpolationMode(e)
    }
    GetResultMode() {
        return this._propertyTrackDataItem.GetResultMode()
    }
    SetResultMode(e) {
        this._propertyTrackDataItem.SetResultMode(e)
    }
    SetEase(e) {
        for (const t of this.GetPropertyKeyframeDataItems())
            t.SetEase(e)
    }
    GetPropertyKeyframeDataItems() {
        return this._propertyKeyframeDataItems ? this._propertyKeyframeDataItems : (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(),
        this._propertyKeyframeDataItems)
    }
    *GetPropertyKeyframeValues() {
        for (const e of this.GetPropertyKeyframeDataItems())
            yield e.GetValueWithResultMode()
    }
    CleanCaches() {
        this.GetSourceAdapter().CleanCaches()
    }
    GetCurrentState() {
        return this.GetSourceAdapter().GetCurrentState()
    }
    SetInitialState() {
        this.GetSourceAdapter().SetInitialState()
    }
    SetResumeState() {
        this.GetSourceAdapter().SetResumeState()
    }
    Interpolate(t, a=!1) {
        const n = this._propertyTrackDataItem;
        let r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(t, n), i;
        return r ? i = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(t, n) : (r = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, n),
        i = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, n)),
        this.GetSourceAdapter().Interpolate(t, r, i, a)
    }
    static GetStartPropertyKeyframeForTime(t, a) {
        const n = a.GetPropertyTrackDataItem()
          , r = a._propertyTrackData;
        let i = r.GetPropertyKeyFrameDataItemAtTime(t, n);
        return i || (i = r.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, n)),
        i
    }
    static GetEndPropertyKeyframeForTime(t, a) {
        const n = a.GetPropertyTrackDataItem()
          , r = a._propertyTrackData;
        let i = r.GetPropertyKeyFrameDataItemAtTime(t, n);
        return i ? r.GetFirstPropertyKeyFrameDataItemHigherThan(t, n) : r.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, n)
    }
    AddPropertyKeyframe() {
        const e = this._propertyTrackDataItem.GetPropertyKeyframeData()
          , t = e.AddEmptyPropertyKeyframeDataItem();
        return t
    }
    DeletePropertyKeyframes(e) {
        const t = this._propertyTrackDataItem.GetPropertyKeyframeData();
        t.DeletePropertyKeyframeDataItems(e)
    }
    SaveState() {
        this.GetSourceAdapter().SaveState()
    }
    CompareInitialStateWithCurrent() {
        const e = this.GetSourceAdapter().CompareInitialStateWithCurrent();
        if (e) {
            const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem)
              , t = this.GetSourceAdapter().GetCurrentState();
            e.SetAbsoluteValue(t)
        }
    }
    CompareSaveStateWithCurrent() {
        const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
        return e && this.AddPropertyKeyframeAtCurrentTime(),
        this.GetSourceAdapter().ClearSaveState(),
        e
    }
    AddPropertyKeyframeAtCurrentTime() {
        const e = this.GetTimeline().GetTime()
          , t = this.GetSourceAdapter()
          , a = C3.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this)
          , n = this.AddPropertyKeyframe();
        n.SetType(a.GetType()),
        n.SetTime(e),
        n.SetEase(a.GetEase()),
        n.SetEnable(!0),
        n.SetValue(t.GetValueAtTime()),
        n.SetAbsoluteValue(t.GetCurrentState())
    }
    _SaveToJson() {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(e) {
        e && this.GetSourceAdapter()._LoadFromJson(e.sourceAdapterJson)
    }
}
,
'use strict';
{
    const t = C3.PropertyTrackState;
    t.PropertySourceAdapter = class {
        constructor(e) {
            this._propertyTrack = e,
            this._propertyAdapter = null
        }
        Release() {
            this._propertyAdapter && (this._propertyAdapter.Release(),
            this._propertyAdapter = null),
            this._propertyTrack = null
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        CleanCaches() {
            this._propertyAdapter && this._propertyAdapter.CleanCaches()
        }
        GetPropertyAdapter() {
            return this._propertyAdapter ? this._propertyAdapter : (this._propertyAdapter = this._CreatePropertyAdapter(),
            this._propertyAdapter)
        }
        GetEditorIndex() {}
        GetIndex() {
            return this.GetEditorIndex()
        }
        GetTarget() {}
        SetInitialState() {
            this.GetPropertyAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetPropertyAdapter().SetResumeState()
        }
        Interpolate(a, n, r, i) {
            const e = t.PropertySourceAdapter.GetInterpolateFunc(this._propertyTrack)
              , l = e(a, n, r, this._propertyTrack);
            return this.GetPropertyAdapter().ChangeProperty(a, l, n, r, i)
        }
        SaveState() {
            this.GetPropertyAdapter().SetSaveState()
        }
        ClearSaveState() {
            this.GetPropertyAdapter().ClearSaveState()
        }
        GetCurrentState() {
            return this.GetPropertyAdapter().GetCurrentState()
        }
        CompareInitialStateWithCurrent() {
            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
        }
        GetValueAtTime() {
            return t.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)
        }
        _CreatePropertyAdapter() {
            const e = this._propertyTrack.GetPropertyType()
              , a = this._propertyTrack.GetPropertyKeyframeType();
            return 'combo' === a || 'boolean' === a || 'text' === a || 'string' === a ? new t.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : 'numeric' === a || 'number' === a || 'angle' === a ? 'combo' === e ? new t.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new t.PropertyInterpolationAdapter.NumericInterpolationAdapter(this) : 'color' === a || 'offsetColor' === a ? new t.PropertyInterpolationAdapter.ColorInterpolationAdapter(this) : void 0
        }
        _SaveToJson() {
            return {
                propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(e) {
            e && this.GetPropertyAdapter()._LoadFromJson(e.propertyAdapterJson)
        }
        static GetValueAtTime(a) {
            const n = a.GetTrack()
              , r = n.GetTimeline().GetTime()
              , i = t.GetStartPropertyKeyframeForTime(r, a)
              , e = t.GetEndPropertyKeyframeForTime(r, a)
              , l = t.PropertySourceAdapter.GetInterpolateFunc(a);
            return l(r, i, e, a)
        }
        static GetValue(e, t, a) {
            let n = e.GetResultMode();
            return 'combo' === e.GetPropertyType() && (n = 'absolute'),
            'relative' === n ? t + a : 'absolute' === n ? a : void 0
        }
        static GetInterpolateFunc(e) {
            const a = e.GetPropertyKeyframeType();
            return 'numeric' === a ? t.NumericTypeAdapter.Interpolate : 'angle' === a ? t.AngleTypeAdapter.Interpolate : 'boolean' === a ? t.BooleanTypeAdapter.Interpolate : 'color' === a ? t.ColorTypeAdapter.Interpolate : 'text' === a ? t.TextTypeAdapter.Interpolate : void 0
        }
        static GetWillChangeFunc(e) {
            const a = e.GetPropertyKeyframeType();
            return 'numeric' === a ? t.NumericTypeAdapter.WillChange : 'angle' === a ? t.AngleTypeAdapter.WillChange : 'boolean' === a ? t.BooleanTypeAdapter.WillChange : 'color' === a ? t.ColorTypeAdapter.WillChange : 'text' === a ? t.TextTypeAdapter.WillChange : void 0
        }
    }
}
{
    class e extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
    }
    C3.PropertyTrackState.WorldInstanceSourceAdapter = e
}
{
    const e = 0;
    class t extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e),
            this._updatedIndex = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[e]
        }
        GetIndex() {
            return this._updatedIndex ? this._updatedIndex : super.GetIndex()
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance()
        }
        UpdateInstanceVariableIndex(t) {
            const a = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[e];
            a === t || (this._updatedIndex = t)
        }
        Interpolate(e, t, a, n) {
            this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, a, n)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                index: this._updatedIndex
            })
        }
        _LoadFromJson(e) {
            e && (super._LoadFromJson(e),
            this._updatedIndex = e.index)
        }
    }
    C3.PropertyTrackState.InstanceVariableSourceAdapter = t
}
{
    const t = 0;
    class e extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e),
            this._sid = NaN
        }
        GetEditorIndex() {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return e.GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            const a = this._propertyTrack.GetPropertyTrackDataItem()
              , n = this._propertyTrack.GetTrack()
              , r = this._sid ? this._sid : a.GetSourceAdapterArguments()[t]
              , i = n.GetInstance()
              , e = i.GetBehaviorIndexBySID(r)
              , l = i.GetBehaviorInstances()[e];
            return l.GetSdkInstance()
        }
        GetBehaviorType(e) {
            const t = this._propertyTrack.GetPropertyTrackDataItem()
              , a = t.GetSourceAdapterArguments()[2];
            return e.GetBehaviorTypeByName(a)
        }
        UpdateBehaviorTypeSid(e) {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            a.GetSourceAdapterArguments()[t] === e || (this._sid = e)
        }
        Interpolate(t, a, n, r) {
            const i = this._propertyTrack.GetTrack()
              , e = i.GetInstance();
            this.GetBehaviorType(e.GetObjectClass()) && super.Interpolate(t, a, n, r)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                sid: this._sid
            })
        }
        _LoadFromJson(e) {
            e && (super._LoadFromJson(e),
            this._sid = e.sid)
        }
    }
    C3.PropertyTrackState.BehaviorSourceAdapter = e
}
{
    class e extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            const t = this._propertyTrack
              , a = t.GetTrack()
              , n = a.GetWorldInfo()
              , r = n.GetInstanceEffectList()
              , i = r.GetEffectList()
              , e = this.GetEffectType(i)
              , l = e.GetIndex();
            return r.IsEffectIndexActive(l) ? r.GetEffectParametersForIndex(l) : null
        }
        GetEffectType(e) {
            const t = this._propertyTrack
              , a = t.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
            return e.GetEffectTypeByName(a)
        }
        Interpolate(e, t, a, n) {
            this._IsEffectActive() && super.Interpolate(e, t, a, n)
        }
        _IsEffectActive() {
            const t = this._propertyTrack
              , a = t.GetTrack()
              , n = a.GetWorldInfo()
              , r = n.GetInstanceEffectList()
              , i = r.GetEffectList()
              , e = this.GetEffectType(i);
            if (e) {
                const t = e.GetIndex();
                return r.IsEffectIndexActive(t)
            }
        }
    }
    C3.PropertyTrackState.EffectSourceAdapter = e
}
{
    class e extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
        }
        Interpolate(t, a, n, r) {
            const i = this._propertyTrack.GetTrack()
              , e = i.GetObjectClass().GetPlugin()
              , l = i.GetInstance().GetObjectClass().GetPlugin();
            e !== l || super.Interpolate(t, a, n, r)
        }
    }
    C3.PropertyTrackState.PluginSourceAdapter = e
}
{
    class e extends C3.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e),
            this._value = 0
        }
        SetInitialState() {
            const e = this._propertyTrack.GetPropertyTrackData();
            let t = this._propertyTrack.GetPropertyTrackDataItem();
            t = e.GetFirstPropertyKeyframeDataItem(t),
            this._value = t.GetValueWithResultMode()
        }
        SetResumeState() {}
        GetValue() {
            return this._value
        }
        Interpolate(e, t, a) {
            const n = C3.PropertyTrackState.NumericTypeAdapter.Interpolate;
            this._value = n(e, t, a, this._propertyTrack)
        }
        SaveState() {}
        ClearSaveState() {}
        GetCurrentState() {
            return this._value
        }
        CompareInitialStateWithCurrent() {
            return !1
        }
        CompareSaveStateWithCurrent() {
            return !1
        }
        _SaveToJson() {
            return {
                value: this._value
            }
        }
        _LoadFromJson(e) {
            e && (this._value = e.value)
        }
    }
    C3.PropertyTrackState.ValueSourceAdapter = e
}
'use strict',
C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(e) {
        this._sourceAdapter = e,
        this._propertyTrack = e.GetPropertyTrack(),
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(),
        this._property = this._propertyTrack.GetPropertyName(),
        this._firstAbsoluteUpdate = !1,
        this._saveState = null,
        this._target = null
    }
    Release() {
        this._sourceAdapter = null,
        this._propertyTrack = null,
        this._worldInfo = null,
        this._saveState = null,
        this._target = null
    }
    CleanCaches() {
        this._worldInfo = null,
        this._saveState = null,
        this._target = null
    }
    GetWorldInfo() {
        return this._worldInfo ? this._worldInfo : (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(),
        this._worldInfo)
    }
    SetFirstAbsoluteUpdate(e) {
        this._firstAbsoluteUpdate = !!e
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(e) {
        const t = typeof this._Getter();
        return t == typeof e
    }
    ChangeProperty() {}
    _FirstKeyframeGetter() {
        const e = this._PickTimelinePlaybackMode(()=>{
            const e = this._propertyTrack.GetPropertyTrackDataItem()
              , t = this._propertyTrack.GetPropertyTrackData();
            return t.GetFirstPropertyKeyframeDataItem(e)
        }
        , ()=>{
            const e = this._propertyTrack.GetPropertyTrackDataItem()
              , t = this._propertyTrack.GetPropertyTrackData();
            return t.GetLastPropertyKeyframeDataItem(e)
        }
        );
        return e.GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const e = this._propertyTrack.GetTimeline()
          , t = e.GetTime()
          , a = this._PickTimelinePlaybackMode(()=>{
            const e = this._propertyTrack.GetPropertyTrackDataItem()
              , a = this._propertyTrack.GetPropertyTrackData();
            return a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e)
        }
        , ()=>{
            const e = this._propertyTrack.GetPropertyTrackDataItem()
              , a = this._propertyTrack.GetPropertyTrackData()
              , n = a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e);
            return n ? n : a.GetLastPropertyKeyframeDataItem(e)
        }
        );
        return a.GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(e, t) {
        const a = this._propertyTrack.GetTimeline();
        return a.IsForwardPlayBack() ? e() : t()
    }
    _PickResultMode(e, t) {
        const a = this._propertyTrack.GetResultMode();
        return 'relative' === a ? e() : t()
    }
    _PickFirstAbsoluteUpdate(e, t) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1),
        e()) : t()
    }
    _GetAbsoluteInitialValue() {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : (this._target = this._sourceAdapter.GetTarget(),
        this._target)
    }
    _PickSource(t, a, n, r, i) {
        const e = this._propertyTrack.GetSourceAdapterId();
        return 'behavior' === e ? t() : 'effect' === e ? a() : 'instance-variable' === e ? n() : 'plugin' === e ? r() : 'world-instance' === e ? i() : void 0
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(e) {
        e && (this._firstAbsoluteUpdate = e.firstAbsoluteUpdate,
        this._saveState = e.saveState)
    }
}
,
'use strict';
{
    class e extends C3.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e),
            this._lastValueR = 0,
            this._lastValueG = 0,
            this._lastValueB = 0
        }
        SetInitialState() {
            this.SetFirstAbsoluteUpdate(!0);
            const e = this._GetAbsoluteInitialValue(this._FirstKeyframeGetter());
            this._lastValueR = e.getR(),
            this._lastValueG = e.getG(),
            this._lastValueB = e.getB()
        }
        SetResumeState() {
            if (!this._CompareColors(this._FirstKeyframeGetter(), this._CurrentKeyframeGetter())) {
                this.SetFirstAbsoluteUpdate(!0);
                const e = this._GetAbsoluteInitialValue(this._CurrentKeyframeGetter());
                this._lastValueR = e.getR(),
                this._lastValueG = e.getG(),
                this._lastValueB = e.getB()
            }
        }
        GetCurrentState() {
            const e = this._propertyTrack.GetSourceAdapterId()
              , t = this._GetTarget()
              , a = this._GetIndex();
            switch (e) {
            case 'behavior':
                t.GetPropertyValueByIndex(a);
                break;
            case 'effect':
                return t[a].toArray().slice(0, 3);
            case 'plugin':
                return t.GetPropertyValueByIndex(a);
            case 'world-instance':
                return this._Getter().toArray().slice(0, 3);
            }
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return !this._CompareColors(e, this._Getter())
        }
        CompareSaveStateWithCurrent() {
            return !C3.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter())
        }
        _CompareColors(e, t) {
            return e.equalsIgnoringAlpha(t)
        }
        _FirstKeyframeGetter() {
            const e = super._FirstKeyframeGetter();
            return this._GetColorFromArray(e)
        }
        _CurrentKeyframeGetter() {
            const e = super._CurrentKeyframeGetter();
            return this._GetColorFromArray(e)
        }
        _GetAbsoluteInitialValue(e) {
            const t = this._GetColorFromArray(e);
            return C3.Color.Diff(t, this._Getter())
        }
        _GetColorFromArray(e) {
            return C3.IsInstanceOf(e, C3.Color) ? e : new C3.Color(e[0],e[1],e[2])
        }
        CanChange() {
            return !0
        }
        ChangeProperty(t, a) {
            const n = a[0]
              , r = a[1]
              , e = a[2]
              , i = this._lastValueR
              , l = this._lastValueG
              , _ = this._lastValueB;
            return this._PickFirstAbsoluteUpdate(()=>{
                this._Setter(-i, -l, -_)
            }
            , ()=>{
                this._Setter(-i + n, -l + r, -_ + e)
            }
            ),
            this._lastValueR = n,
            this._lastValueG = r,
            this._lastValueB = e,
            C3.TimelineState.LAYOUT_RENDER_CHANGE
        }
        _Getter() {
            const e = this._propertyTrack.GetSourceAdapterId()
              , t = this._GetTarget()
              , a = this._GetIndex();
            return 'behavior' === e ? this._GetColorFromArray(t.GetPropertyValueByIndex(a)) : 'effect' === e ? t[a].clone() : 'plugin' === e ? this._GetColorFromArray(t.GetPropertyValueByIndex(a)) : 'world-instance' === e ? this.GetWorldInfo().GetUnpremultipliedColor().clone() : void 0
        }
        _Setter(t, a, n) {
            const r = this._propertyTrack.GetSourceAdapterId()
              , i = this._GetTarget()
              , e = this._GetIndex();
            'behavior' === r ? i.SetPropertyColorOffsetValueByIndex(e, t, a, n) : 'effect' === r ? i[e].addRgb(t, a, n) : 'plugin' === r ? i.SetPropertyColorOffsetValueByIndex(e, t, a, n) : 'world-instance' === r ? this.GetWorldInfo().OffsetUnpremultipliedColorRGB(t, a, n) : void 0
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                r: this._lastValueR,
                g: this._lastValueG,
                b: this._lastValueB
            })
        }
        _LoadFromJson(e) {
            e && (super._LoadFromJson(e),
            this._lastValueR = e.r,
            this._lastValueG = e.g,
            this._lastValueB = e.b)
        }
    }
    C3.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = e
}
{
    class e extends C3.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return e !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return !C3.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState()
        }
        ChangeProperty(t, a) {
            const n = C3.PropertyTrackState.PropertySourceAdapter.GetWillChangeFunc(this._propertyTrack)
              , r = this._propertyTrack.GetSourceAdapterId()
              , i = n(this._GetIndex(), this._GetTarget(), a, r);
            if (i)
                return this._Setter(a),
                'behavior' === r || 'effect' === r || 'instance-variable' === r ? void 0 : 'plugin' === r ? C3.TimelineState.LAYOUT_RENDER_CHANGE : void 0
        }
        _Getter() {
            const e = this._propertyTrack.GetSourceAdapterId()
              , t = this._GetTarget()
              , a = this._GetIndex();
            switch (e) {
            case 'behavior':
                return t.GetPropertyValueByIndex(a);
            case 'effect':
                return t[a];
            case 'instance-variable':
                return t.GetInstanceVariableValue(a);
            case 'plugin':
                return t.GetPropertyValueByIndex(a);
                ;
            }
        }
        _Setter(e) {
            const t = this._propertyTrack.GetSourceAdapterId()
              , a = this._GetTarget()
              , n = this._GetIndex();
            'behavior' === t ? a.SetPropertyValueByIndex(n, e) : 'effect' === t ? a[n] = e : 'instance-variable' === t ? a.SetInstanceVariableValue(n, e) : 'plugin' === t ? a.SetPropertyValueByIndex(n, e) : void 0
        }
    }
    C3.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = e
}
{
    const t = new Map
      , e = (a,n,r,i)=>t.set(a, {
        setter: n,
        getter: r,
        round: i
    });
    e('offsetX', (e,t)=>e.OffsetX(t), e=>e.GetX(), !0),
    e('offsetY', (e,t)=>e.OffsetY(t), e=>e.GetY(), !0),
    e('offsetWidth', (e,t)=>e.OffsetWidth(t), e=>e.GetWidth(), !0),
    e('offsetHeight', (e,t)=>e.OffsetHeight(t), e=>e.GetHeight(), !0),
    e('offsetAngle', (e,t)=>e.OffsetAngle(t), e=>e.GetAngle(), !1),
    e('offsetOpacity', (e,t)=>e.OffsetOpacity(t), e=>e.GetOpacity(), !1),
    e('offsetOriginX', (e,t)=>e.OffsetOriginX(t), e=>e.GetOriginX(), !1),
    e('offsetOriginY', (e,t)=>e.OffsetOriginY(t), e=>e.GetOriginY(), !1),
    e('offsetZElevation', (e,t)=>e.OffsetZElevation(t), e=>e.GetZElevation(), !0);
    class a extends C3.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e),
            this._lastValue = 0,
            this._instance_getter = null,
            this._instance_setter = null,
            this._round = !1;
            const a = this._propertyTrack.GetPropertyName();
            if ('world-instance' === this._propertyTrack.GetSourceAdapterId()) {
                const e = t.get(a);
                this._instance_getter = e.getter,
                this._instance_setter = e.setter,
                this._round = e.round
            }
        }
        Release() {
            this._instance_getter = null,
            this._instance_setter = null,
            super.Release()
        }
        SetInitialState() {
            this._lastValue = this._PickResultMode(()=>this._PickTimelinePlaybackMode(()=>0, ()=>C3.PropertyTrackState.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)), ()=>(this.SetFirstAbsoluteUpdate(!0),
            this._GetAbsoluteInitialValue(this._FirstKeyframeGetter())))
        }
        SetResumeState() {
            this._FirstKeyframeGetter() === this._CurrentKeyframeGetter() || this._PickResultMode(()=>{}
            , ()=>{
                this.SetFirstAbsoluteUpdate(!0),
                this._lastValue = this._GetAbsoluteInitialValue(this._CurrentKeyframeGetter())
            }
            )
        }
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return e !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return !C3.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState()
        }
        _GetAbsoluteInitialValue(e) {
            return e - this.GetCurrentState()
        }
        ChangeProperty(t, a, n, r, i) {
            return this._PickResultMode(()=>{
                this._Setter(a - this._lastValue, n, r),
                this._MaybeEnsureValue(t, n, r, i, this._lastValue, a)
            }
            , ()=>{
                this._PickFirstAbsoluteUpdate(()=>{
                    this._Setter(this._lastValue, n, r)
                }
                , ()=>{
                    this._Setter(a - this._lastValue, n, r),
                    this._MaybeEnsureValue(t, n, r, i, this._lastValue, a)
                }
                )
            }
            ),
            this._lastValue = a,
            this._PickSource(()=>{}
            , ()=>C3.TimelineState.LAYOUT_RENDER_CHANGE, ()=>{}
            , ()=>C3.TimelineState.LAYOUT_RENDER_CHANGE, ()=>C3.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        _Getter() {
            const e = this._GetTarget()
              , t = this._GetIndex();
            return this._PickSource(()=>e.GetPropertyValueByIndex(t), ()=>e[t], ()=>e.GetInstanceVariableValue(t), ()=>e.GetPropertyValueByIndex(t), ()=>this._instance_getter(this.GetWorldInfo()))
        }
        _Setter(e) {
            const t = this._GetTarget()
              , a = this._GetIndex();
            this._PickSource(()=>t.OffsetPropertyValueByIndex(a, e), ()=>t[a] += e, ()=>t.SetInstanceVariableOffset(a, e), ()=>t.OffsetPropertyValueByIndex(a, e), ()=>this._instance_setter(this.GetWorldInfo(), e))
        }
        _MaybeEnsureValue(t, a, n, r, i, e) {
            r ? a && t === a.GetTime() ? this._AddDelta(a.GetValueWithResultMode(), a, n) : n && t === n.GetTime() ? this._AddDelta(n.GetValueWithResultMode(), a, n) : !n && this._AddDelta(a.GetValueWithResultMode(), a, n) : a && t === a.GetTime() ? this._AddDelta(a.GetValueWithResultMode(), a, n) : n && t === n.GetTime() ? this._AddDelta(n.GetValueWithResultMode(), a, n) : 0 == e - i && this._AddDelta(a.GetValueWithResultMode(), a, n)
        }
        _AddDelta(t, a, n) {
            const r = t.toString()
              , i = r.split('.')[1] || ''
              , e = i.length
              , l = this._Getter();
            let _;
            _ = 0 === e ? this._round ? Math.round(l) : l : C3.toFixed(l, e),
            this._Setter(_ - l, a, n)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                v: this._lastValue
            })
        }
        _LoadFromJson(e) {
            e && (super._LoadFromJson(e),
            this._lastValue = e.v)
        }
    }
    C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = a
}
'use strict',
C3.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(t, a, n, r) {
        let i;
        return 'behavior' === r ? i = a.GetPropertyValueByIndex(t) : 'effect' === r ? i = a[t] : 'instance-variable' === r ? i = a.GetInstanceVariableValue(t) : 'plugin' === r ? i = a.GetPropertyValueByIndex(t) : void 0,
        i !== n
    }
    static Interpolate(t, r, _, u) {
        var d = Math.floor;
        if (!_) {
            let e = u.GetPropertyTrackDataItem();
            const t = u.GetPropertyTrackData();
            return e = t.GetLastPropertyKeyframeDataItem(e),
            e.GetValueWithResultMode()
        }
        let c = u.GetInterpolationMode();
        if ('default' === c && (c = 'continuous'),
        'combo' === u.GetPropertyType() && (c = 'discrete'),
        'discrete' === c)
            return r.GetValueWithResultMode();
        if ('continuous' === c || 'step' === c) {
            if ('step' === c) {
                const e = u.GetTimeline().GetStep();
                if (0 !== e) {
                    const a = 1 / e;
                    t = d(t * a) / a
                }
            }
            const g = r.GetTime()
              , p = _.GetTime()
              , i = r.GetValueWithResultMode()
              , h = _.GetValueWithResultMode();
            if (i === h)
                return i;
            const f = C3.normalize(t, g, p)
              , l = r.GetEase();
            let m;
            const e = r.GetAddOn('cubic-bezier')
              , n = _.GetAddOn('cubic-bezier');
            if (e && e.GetStartEnable() && n && n.GetEndEnable()) {
                const t = p - g;
                m = Ease.GetEase(l)(t * f, 0, 1, t),
                m = Ease.GetEase('cubicbezier')(m, i, i + e.GetStartAnchor(), h + n.GetEndAnchor(), h)
            } else
                m = Ease.GetEase(l)((p - g) * f, i, h - i, p - g);
            return 'integer' === u.GetPropertyType() ? d(m) : m
        }
    }
}
,
'use strict',
C3.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(t, a, n, r) {
        let i;
        return 'behavior' === r ? i = a.GetPropertyValueByIndex(t) : 'effect' === r ? i = a[t] : 'instance-variable' === r ? i = a.GetInstanceVariableValue(t) : 'plugin' === r ? i = a.GetPropertyValueByIndex(t) : void 0,
        i !== n
    }
    static Interpolate(t, n, r, i) {
        if (!r) {
            let e = i.GetPropertyTrackDataItem();
            const t = i.GetPropertyTrackData();
            return e = t.GetLastPropertyKeyframeDataItem(e),
            e.GetValueWithResultMode()
        }
        let l = i.GetInterpolationMode();
        if ('default' === l && (l = 'continuous'),
        'combo' === i.GetPropertyType() && (l = 'discrete'),
        'discrete' === l)
            return n.GetValueWithResultMode();
        if ('continuous' === l || 'step' === l) {
            if ('step' === l) {
                const e = i.GetTimeline().GetStep();
                if (0 !== e) {
                    const a = 1 / e;
                    t = Math.floor(t * a) / a
                }
            }
            const e = n.GetTime()
              , a = r.GetTime()
              , _ = n.GetValueWithResultMode()
              , d = r.GetValueWithResultMode();
            if (_ === d)
                return _;
            let u = C3.normalize(t, e, a);
            const c = Ease.GetEase(n.GetEase());
            return C3.angleLerp(_, d, c(u, 0, 1, 1))
        }
    }
}
,
'use strict',
C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(t, a, n, r) {
        let i;
        return 'behavior' === r ? i = a.GetPropertyValueByIndex(t) : 'effect' === r ? i = a[t] : 'instance-variable' === r ? i = a.GetInstanceVariableValue(t) : 'plugin' === r ? i = a.GetPropertyValueByIndex(t) : void 0,
        !!i != !!n
    }
    static Interpolate(e, t, a, n) {
        if (!a) {
            let e = n.GetPropertyTrackDataItem();
            const t = n.GetPropertyTrackData();
            return e = t.GetLastPropertyKeyframeDataItem(e),
            e.GetValueWithResultMode() ? 1 : 0
        }
        return t.GetValueWithResultMode() ? 1 : 0
    }
}
,
'use strict';
{
    const _ = [0, 0, 0]
      , t = [0, 0, 0];
    C3.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {}
        static WillChange(a, n, r, e) {
            var i = Math.floor;
            let l;
            return 'behavior' === e ? l = n.GetPropertyValueByIndex(a) : 'effect' === e ? l = n[a] : 'instance-variable' === e ? l = n.GetInstanceVariableValue(a) : 'plugin' === e ? l = n.GetPropertyValueByIndex(a) : void 0,
            Array.isArray(r) ? (_[0] = r[0],
            _[1] = r[1],
            _[2] = r[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(r),
            _[0] = i(255 * TEMP_COLOR_ARRAY_3.getR()),
            _[1] = i(255 * TEMP_COLOR_ARRAY_3.getG()),
            _[2] = i(255 * TEMP_COLOR_ARRAY_3.getB())),
            Array.isArray(l) ? (t[0] = l[0],
            t[1] = l[1],
            t[2] = l[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(l),
            t[0] = i(255 * TEMP_COLOR_ARRAY_3.getR()),
            t[1] = i(255 * TEMP_COLOR_ARRAY_3.getG()),
            t[2] = i(255 * TEMP_COLOR_ARRAY_3.getB())),
            _[0] !== t[0] || _[1] !== t[1] || _[2] !== t[2]
        }
        static Interpolate(S, a, c, t) {
            if (!c) {
                let a = t.GetPropertyTrackDataItem();
                const n = t.GetPropertyTrackData();
                a = n.GetLastPropertyKeyframeDataItem(a);
                const r = a.GetValueWithResultMode();
                return _[0] = r[0],
                _[1] = r[1],
                _[2] = r[2],
                _
            }
            let d = t.GetInterpolationMode();
            if ('default' === d && (d = 'continuous'),
            'discrete' === d) {
                const e = a.GetValueWithResultMode();
                return _[0] = e[0],
                _[1] = e[1],
                _[2] = e[2],
                _
            }
            if ('continuous' === d || 'step' === d) {
                if ('step' === d) {
                    const e = t.GetTimeline().GetStep();
                    if (0 !== e) {
                        const t = 1 / e;
                        S = Math.floor(S * t) / t
                    }
                }
                const g = a.GetTime()
                  , h = c.GetTime()
                  , i = a.GetValueWithResultMode()
                  , f = c.GetValueWithResultMode()
                  , y = C3.normalize(S, g, h)
                  , l = a.GetEase()
                  , m = i[0]
                  , e = i[1]
                  , n = i[2]
                  , G = f[0]
                  , p = f[1]
                  , b = f[2]
                  , r = Ease.GetEase(l)
                  , T = h - g
                  , I = T * y;
                return _[0] = m === G ? m : r(I, m, G - m, T),
                _[1] = e === p ? e : r(I, e, p - e, T),
                _[2] = n === b ? n : r(I, n, b - n, T),
                _
            }
        }
    }
}
'use strict',
C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(t, a, n, r) {
        let i;
        return 'behavior' === r ? i = a.GetPropertyValueByIndex(t) : 'effect' === r ? i = a[t] : 'instance-variable' === r ? i = a.GetInstanceVariableValue(t) : 'plugin' === r ? i = a.GetPropertyValueByIndex(t) : void 0,
        i !== n
    }
    static Interpolate(e, t, a, n) {
        if (!a) {
            let e = n.GetPropertyTrackDataItem();
            const t = n.GetPropertyTrackData();
            return e = t.GetLastPropertyKeyframeDataItem(e),
            e.GetValueWithResultMode()
        }
        return t.GetValueWithResultMode()
    }
}
,
'use strict',
C3.TimelineDataManager = class {
    constructor() {
        this._timelineDataItems = new Map
    }
    Release() {
        for (const e of this._timelineDataItems.values())
            e.Release();
        this._timelineDataItems.clear(),
        this._timelineDataItems = null
    }
    Add(e) {
        const t = new C3.TimelineDataItem(e)
          , a = t.GetName();
        this._timelineDataItems.set(a, t)
    }
    Get(e) {
        return this._timelineDataItems.get(e)
    }
    GetNameId() {
        return 0
    }
    static _CreateDataItems(t, a, n, r) {
        if (a)
            for (const i of a)
                C3.TimelineDataManager._CreateDataItem('create', i, t, n, r)
    }
    static _LoadDataItemsFromJson(e, t, a, n) {
        e.length ? t.forEach((t,a)=>{
            e[a]._LoadFromJson(t)
        }
        ) : t.forEach(t=>{
            C3.TimelineDataManager._CreateDataItem('load', t, e, a, n)
        }
        )
    }
    static _CreateDataItem(t, a, n, r, i) {
        let e;
        if ('function' == typeof r)
            'load' === t ? e = new r(null,i) : 'create' === t ? e = new r(a,i) : void 0;
        else if ('object' == typeof r) {
            const n = r.prop
              , l = a[n]
              , _ = r.map.get(l);
            'load' === t ? e = new _(null,i) : 'create' === t ? e = new _(a,i) : void 0
        }
        switch (t) {
        case 'load':
            e._LoadFromJson(a),
            n.push(e);
            break;
        case 'create':
            if ('function' == typeof e.GetEnable && !e.GetEnable())
                return e.Release();
            n.push(e);
        }
    }
}
,
'use strict',
C3.TimelineDataItem = class {
    constructor(e) {
        this._name = '',
        this._totalTime = NaN,
        this._step = 0,
        this._interpolationMode = 'default',
        this._resultMode = 'default',
        this._loop = !1,
        this._pingPong = !1,
        this._repeatCount = 1,
        this._trackData = null,
        e && (this._name = e[0],
        this._totalTime = e[1],
        this._step = e[2],
        this._interpolationMode = e[3],
        this._resultMode = e[4],
        this._loop = !!e[6],
        this._pingPong = !!e[7],
        this._repeatCount = e[8],
        this._trackData = new C3.TrackData(e[5],this))
    }
    Release() {
        this._trackData.Release(),
        this._trackData = null
    }
    GetTrackData() {
        return this._trackData || (this._trackData = new C3.TrackData(null,this)),
        this._trackData
    }
    GetName() {
        return this._name
    }
    SetName(e) {
        this._name = e
    }
    GetTotalTime() {
        return this._totalTime
    }
    SetTotalTime(e) {
        this._totalTime = e
    }
    GetStep() {
        return this._step
    }
    SetStep(e) {
        this._step = e
    }
    GetInterpolationMode() {
        return this._interpolationMode
    }
    SetInterpolationMode(e) {
        this._interpolationMode = e
    }
    GetResultMode() {
        return this._resultMode
    }
    SetResultMode(e) {
        this._resultMode = e
    }
    GetLoop() {
        return this._loop
    }
    GetPingPong() {
        return this._pingPong
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    _SaveToJson() {
        return {
            trackDataJson: this._trackData._SaveToJson(),
            name: this._name,
            totalTime: this._totalTime,
            step: this._step,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            loop: this._loop,
            pingPong: this._pingPong,
            repeatCount: this._repeatCount
        }
    }
    _LoadFromJson(e) {
        e && (this.GetTrackData()._LoadFromJson(e.trackDataJson),
        this._name = e.name,
        this._totalTime = e.totalTime,
        this._step = e.step,
        this._interpolationMode = e.interpolationMode,
        this._resultMode = e.resultMode,
        this._loop = e.loop,
        this._pingPong = e.pingPong,
        this._repeatCount = e.repeatCount)
    }
}
,
'use strict';
{
    const e = 0;
    class t {
        constructor(t, a) {
            this._trackData = a,
            this._instanceData = null,
            this._instanceUid = NaN,
            this._objectClassIndex = NaN,
            this._interpolationMode = 'default',
            this._resultMode = 'default',
            this._enabled = !1,
            this._keyframeData = null,
            this._propertyTrackData = null,
            this._id = '',
            t && (this._instanceData = t[e],
            this._instanceUid = t[e][2],
            this._objectClassIndex = t[e][1],
            this._interpolationMode = t[1],
            this._resultMode = t[2],
            this._enabled = !!t[3],
            t[6] && (this._id = t[6]),
            this._keyframeData = new C3.KeyframeData(t[4],this),
            this._propertyTrackData = new C3.PropertyTrackData(t[5],this))
        }
        Release() {
            this._trackData = null,
            this._keyframeData && (this._keyframeData.Release(),
            this._keyframeData = null),
            this._propertyTrackData && (this._propertyTrackData.Release(),
            this._propertyTrackData = null)
        }
        GetTrackData() {
            return this._trackData
        }
        GetKeyframeData() {
            return this._keyframeData || (this._keyframeData = new C3.KeyframeData(null,this)),
            this._keyframeData
        }
        GetPropertyTrackData() {
            return this._propertyTrackData || (this._propertyTrackData = new C3.PropertyTrackData(null,this)),
            this._propertyTrackData
        }
        GetInstanceData() {
            return this._instanceData
        }
        GetObjectClassIndex() {
            return this._objectClassIndex
        }
        SetObjectClassIndex(e) {
            this._objectClassIndex = e
        }
        GetInstanceUID() {
            return this._instanceUid
        }
        SetInstanceUID(e) {
            this._instanceUid = e
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(e) {
            this._interpolationMode = e
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(e) {
            this._resultMode = e
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(e) {
            this._enabled = !!e
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                keyframeDataJson: this._keyframeData._SaveToJson(),
                propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
                instanceData: this._instanceData,
                instanceUid: this._instanceUid,
                objectClassIndex: this._objectClassIndex,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                id: this._id
            }
        }
        _LoadFromJson(e) {
            e && (this._instanceData = e.instanceData,
            this._instanceUid = e.instanceUid,
            this._objectClassIndex = e.objectClassIndex,
            this._interpolationMode = e.interpolationMode,
            this._resultMode = e.resultMode,
            this._enabled = e.enabled,
            this._id = e.id,
            this.GetKeyframeData()._LoadFromJson(e.keyframeDataJson),
            this.GetPropertyTrackData()._LoadFromJson(e.propertyTrackDataJson))
        }
    }
    C3.TrackData = class {
        constructor(e, a) {
            this._timelineData = a,
            this._trackDataItems = [],
            this._keyframeTimeMap = new Map,
            C3.TimelineDataManager._CreateDataItems(this._trackDataItems, e, t, this)
        }
        Release() {
            this._timelineData = null;
            for (const e of this._trackDataItems)
                e.Release();
            C3.clearArray(this._trackDataItems),
            this._trackDataItems = null,
            this._keyframeTimeMap.clear(),
            this._keyframeTimeMap = null
        }
        AddEmptyTrackDataItem() {
            const e = new t(null,this);
            return this._trackDataItems.push(e),
            e
        }
        GetFirstKeyframeDataItem(e) {
            return e.GetKeyframeData().GetKeyframeDataItemArray()[0]
        }
        GetLastKeyframeDataItem(e) {
            const t = e.GetKeyframeData().GetKeyframeDataItemArray();
            return t[t.length - 1]
        }
        GetKeyFrameDataItemAtTime(e, t) {
            const a = this._keyframeTimeMap.get(t);
            if (!!a && a.has(e))
                return a.get(e);
            for (const n of t.GetKeyframeData().keyframeDataItems())
                if (n.GetTime() === e)
                    return a || this._keyframeTimeMap.set(t, new Map),
                    this._keyframeTimeMap.get(t).set(e, n),
                    n
        }
        GetFirstKeyFrameDataItemHigherThan(e, t) {
            for (const a of t.GetKeyframeData().keyframeDataItems())
                if (a.GetTime() > e)
                    return a
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(e, t) {
            for (const a of t.GetKeyframeData().keyframeDataItems())
                if (a.GetTime() >= e)
                    return a
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(e, t) {
            for (const a of t.GetKeyframeData().keyframeDataItemsReverse())
                if (a.GetTime() <= e)
                    return a
        }
        *trackDataItems() {
            for (const e of this._trackDataItems)
                yield e
        }
        _SaveToJson() {
            return {
                trackDataItemsJson: this._trackDataItems.map(e=>e._SaveToJson())
            }
        }
        _LoadFromJson(e) {
            e && C3.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, e.trackDataItemsJson, t, this)
        }
    }
}
{
    const e = 0;
    class t {
        constructor(t, a) {
            this._propertyTrackData = a,
            this._sourceAdapterId = '',
            this._sourceAdapterArguments = null,
            this._property = null,
            this._type = null,
            this._min = NaN,
            this._max = NaN,
            this._interpolationMode = 'default',
            this._resultMode = 'default',
            this._enabled = !1,
            this._propertyKeyframeData = null,
            t && (this._sourceAdapterId = t[e][0],
            this._sourceAdapterArguments = t[e].slice(1),
            this._property = t[1],
            this._type = t[2],
            this._min = t[3],
            this._max = t[4],
            this._interpolationMode = t[5],
            this._resultMode = t[6],
            this._enabled = !!t[7],
            this._propertyKeyframeData = new C3.PropertyKeyframeData(t[8],this))
        }
        Release() {
            this._propertyKeyframeData.Release(),
            this._propertyKeyframeData = null,
            this._propertyTrackData = null,
            this._sourceAdapterArguments = null
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetPropertyKeyframeData() {
            return this._propertyKeyframeData || (this._propertyKeyframeData = new C3.PropertyKeyframeData(null,this)),
            this._propertyKeyframeData
        }
        GetSourceAdapterId() {
            return this._sourceAdapterId
        }
        SetSourceAdapterId(e) {
            this._sourceAdapterId = e
        }
        GetSourceAdapterArguments() {
            return this._sourceAdapterArguments
        }
        SetSourceAdapterArguments(e) {
            this._sourceAdapterArguments = e
        }
        GetProperty() {
            return this._property
        }
        SetProperty(e) {
            this._property = e
        }
        GetType() {
            return this._type
        }
        SetType(e) {
            this._type = e
        }
        GetMin() {
            return this._min
        }
        SetMin(e) {
            this._min = e
        }
        GetMax() {
            return this._max
        }
        SetMax(e) {
            this._max = e
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(e) {
            this._interpolationMode = e
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(e) {
            this._resultMode = e
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(e) {
            this._enabled = !!e
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
                sourceAdapterId: this._sourceAdapterId,
                sourceAdapterArguments: this._sourceAdapterArguments,
                property: this._property,
                type: this._type,
                min: this._min,
                max: this._max,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled
            }
        }
        _LoadFromJson(e) {
            e && (this._sourceAdapterId = e.sourceAdapterId,
            this._sourceAdapterArguments = e.sourceAdapterArguments,
            this._property = e.property,
            this._type = e.type,
            this._min = e.min,
            this._max = e.max,
            this._interpolationMode = e.interpolationMode,
            this._resultMode = e.resultMode,
            this._enabled = e.enabled,
            this.GetPropertyKeyframeData()._LoadFromJson(e.propertyKeyframeDataJson))
        }
    }
    C3.PropertyTrackData = class {
        constructor(e, a) {
            this._trackDataItem = a,
            this._propertyTrackDataItems = [],
            this._propertyKeyframeTimeMap = new Map,
            C3.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, e, t, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const e of this._propertyTrackDataItems)
                e.Release();
            C3.clearArray(this._propertyTrackDataItems),
            this._propertyTrackDataItems = null,
            this._propertyKeyframeTimeMap.clear(),
            this._propertyKeyframeTimeMap = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        AddEmptyPropertyTrackDataItem() {
            const e = new t(null,this);
            return this._propertyTrackDataItems.push(e),
            e
        }
        GetFirstPropertyKeyframeDataItem(e) {
            const t = e.GetPropertyKeyframeData();
            return t.GetPropertyKeyframeDataItemArray()[0]
        }
        GetLastPropertyKeyframeDataItem(e) {
            const t = e.GetPropertyKeyframeData()
              , a = t.GetPropertyKeyframeDataItemArray();
            return a[a.length - 1]
        }
        GetPropertyKeyFrameDataItemAtTime(t, a) {
            const n = this._propertyKeyframeTimeMap.get(a);
            if (!!n && n.has(t))
                return n.get(t);
            const r = a.GetPropertyKeyframeData();
            for (const i of r.propertyKeyframeDataItems())
                if (i.GetTime() === t)
                    return n || this._propertyKeyframeTimeMap.set(a, new Map),
                    this._propertyKeyframeTimeMap.get(a).set(t, i),
                    i
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(e, t) {
            const a = t.GetPropertyKeyframeData();
            for (const n of a.propertyKeyframeDataItems())
                if (n.GetTime() > e)
                    return n
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, t) {
            const a = t.GetPropertyKeyframeData();
            for (const n of a.propertyKeyframeDataItems())
                if (n.GetTime() >= e)
                    return n
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, t) {
            const a = t.GetPropertyKeyframeData();
            for (const n of a.propertyKeyframeDataItemsReverse())
                if (n.GetTime() <= e)
                    return n
        }
        *propertyTrackDataItems() {
            for (const e of this._propertyTrackDataItems)
                yield e
        }
        _SaveToJson() {
            return {
                propertyTrackDataItemsJson: this._propertyTrackDataItems.map(e=>e._SaveToJson())
            }
        }
        _LoadFromJson(e) {
            e && C3.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, e.propertyTrackDataItemsJson, t, this)
        }
    }
}
{
    class e {
        constructor(e, t) {
            if (this._keyframeData = t,
            this._time = -1,
            this._ease = 'noease',
            this._enable = !1,
            this._tags = null,
            this._lowerTags = null,
            !!e) {
                this._time = e[0],
                this._ease = e[1],
                this._enable = !!e[2];
                const t = e[3];
                this._tags = t ? t.split(' ') : [],
                this._lowerTags = new Set(this._tags.map(e=>e.toLowerCase()))
            }
        }
        Release() {
            this._keyframeData = null,
            C3.clearArray(this._tags),
            this._tags = null,
            this._lowerTags.clear(),
            this._lowerTags = null
        }
        GetKeyframeData() {
            return this._keyframeData
        }
        GetTime() {
            return this._time
        }
        SetTime(e) {
            this._time = e
        }
        GetEase() {
            return this._ease
        }
        SetEase(e) {
            this._ease = e
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(e) {
            this._enable = !!e
        }
        GetTags() {
            return this._tags
        }
        SetTags(e) {
            this._tags = e ? e.split(' ') : [],
            this._lowerTags = new Set(this._tags.map(e=>e.toLowerCase()))
        }
        GetLowerTags() {
            return this._lowerTags
        }
        HasTag(e) {
            return this._lowerTags.has(e.toLowerCase())
        }
        _SaveToJson() {
            return {
                time: this._time,
                ease: this._ease,
                enable: this._enable,
                tags: this._tags
            }
        }
        _LoadFromJson(e) {
            e && (this._time = e.time,
            this._ease = e.ease,
            this._enable = e.enable,
            this._tags = e.tags,
            this._lowerTags = new Set(this._tags.map(e=>e.toLowerCase())))
        }
    }
    C3.KeyframeData = class {
        constructor(t, a) {
            this._trackDataItem = a,
            this._keyframeDataItems = [],
            C3.TimelineDataManager._CreateDataItems(this._keyframeDataItems, t, e, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const e of this._keyframeDataItems)
                e.Release();
            C3.clearArray(this._keyframeDataItems),
            this._keyframeDataItems = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetKeyframeDataItemCount() {
            return this._keyframeDataItems.length
        }
        GetKeyframeDataItemArray() {
            return this._keyframeDataItems
        }
        AddEmptyKeyframeDataItem() {
            const t = new e(null,this);
            return this._keyframeDataItems.push(t),
            t
        }
        DeleteKeyframeDataItems(e) {
            for (const t of this._keyframeDataItems) {
                if (!e(t))
                    continue;
                const a = this._keyframeDataItems.indexOf(t);
                -1 === a || (t.Release(),
                this._keyframeDataItems.splice(a, 1))
            }
            this.SortKeyframeDataItems()
        }
        SortKeyframeDataItems() {
            this._keyframeDataItems.sort((e,t)=>e.GetTime() - t.GetTime())
        }
        GetKeyframeDataItemIndex(e) {
            return this._keyframeDataItems.indexOf(e)
        }
        GetKeyframeDataItemFromIndex(e) {
            return this._keyframeDataItems[e]
        }
        *keyframeDataItems() {
            for (const e of this._keyframeDataItems)
                yield e
        }
        *keyframeDataItemsReverse() {
            for (let e = this._keyframeDataItems.length - 1; 0 <= e; e--)
                yield this._keyframeDataItems[e]
        }
        _SaveToJson() {
            return {
                keyframeDataItemsJson: this._keyframeDataItems.map(e=>e._SaveToJson())
            }
        }
        _LoadFromJson(t) {
            t && C3.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, t.keyframeDataItemsJson, e, this)
        }
    }
}
{
    const e = 0;
    class t {
        constructor(t, a) {
            this._propertyKeyframeData = a,
            this._value = null,
            this._aValue = null,
            this._type = '',
            this._time = NaN,
            this._ease = 'noease',
            this._enable = !1,
            this._addonData = null,
            t && (this._value = t[e][0],
            this._aValue = t[e][1],
            this._type = t[e][2],
            this._time = t[1],
            this._ease = t[2],
            this._enable = !!t[3],
            this._addonData = null,
            !!t[4] && (this._addonData = new C3.AddonData(t[4],this)))
        }
        Release() {
            this._propertyKeyframeData = null,
            this._addonData && (this._addonData.Release(),
            this._addonData = null)
        }
        GetAddonData() {
            return this._addonData
        }
        GetValue() {
            return this._value
        }
        SetValue(e) {
            'color' === this._type && C3.IsFiniteNumber(e) ? (this._value[0] = C3.GetRValue(e),
            this._value[1] = C3.GetGValue(e),
            this._value[2] = C3.GetBValue(e)) : this._value = e
        }
        GetAbsoluteValue() {
            return this._aValue
        }
        SetAbsoluteValue(e) {
            'color' === this._type && C3.IsFiniteNumber(e) ? (this._aValue[0] = C3.GetRValue(e),
            this._aValue[1] = C3.GetGValue(e),
            this._aValue[2] = C3.GetBValue(e)) : this._aValue = e
        }
        GetValueWithResultMode() {
            const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
            return 'relative' === e ? this.GetValue() : 'absolute' === e ? this.GetAbsoluteValue() : void 0
        }
        GetType() {
            return this._type
        }
        SetType(e) {
            this._type = e
        }
        GetTime() {
            return this._time
        }
        SetTime(e) {
            this._time = e
        }
        GetEase() {
            return this._ease
        }
        SetEase(e) {
            this._ease = e
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(e) {
            this._enable = !!e
        }
        GetAddOn(e) {
            if (this.GetAddonData())
                for (const t of this.GetAddonData().addonDataItems())
                    if (t.GetId() === e)
                        return t
        }
        _SaveToJson() {
            const e = this._addonData;
            return {
                addonDataJson: e ? e._SaveToJson() : e,
                value: this._value,
                aValue: this._aValue,
                type: this._type,
                time: this._time,
                ease: this._ease,
                enable: this._enable
            }
        }
        _LoadFromJson(e) {
            e && (e.addonDataJson && this._addonData._SetFromJson(e.addonDataJson),
            this._value = e.value,
            this._aValue = e.aValue,
            this._type = e.type,
            this._time = e.time,
            this._ease = e.ease,
            this._enable = e.enable)
        }
    }
    C3.PropertyKeyframeData = class {
        constructor(e, a) {
            this._propertyTrackDataItem = a,
            this._propertyKeyframeDataItems = [],
            C3.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, t, this)
        }
        Release() {
            this._propertyTrackDataItem = null;
            for (const e of this._propertyKeyframeDataItems)
                e.Release();
            C3.clearArray(this._propertyKeyframeDataItems),
            this._propertyKeyframeDataItems = null
        }
        AddEmptyPropertyKeyframeDataItem() {
            const e = new t(null,this);
            return this._propertyKeyframeDataItems.push(e),
            e
        }
        DeletePropertyKeyframeDataItems(e) {
            for (const t of this._propertyKeyframeDataItems) {
                if (!e(t))
                    continue;
                const a = this._propertyKeyframeDataItems.indexOf(t);
                -1 === a || (t.Release(),
                this._propertyKeyframeDataItems.splice(a, 1))
            }
            this.SortPropertyKeyFrameDataItems()
        }
        SortPropertyKeyFrameDataItems() {
            this._propertyKeyframeDataItems.sort((e,t)=>e.GetTime() - t.GetTime())
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyKeyframeDataItemCount() {
            this._propertyKeyframeDataItems.length
        }
        GetPropertyKeyframeDataItemArray() {
            return this._propertyKeyframeDataItems
        }
        *propertyKeyframeDataItems() {
            for (const e of this._propertyKeyframeDataItems)
                yield e
        }
        *propertyKeyframeDataItemsReverse() {
            for (let e = this._propertyKeyframeDataItems.length - 1; 0 <= e; e--)
                yield this._propertyKeyframeDataItems[e]
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(e=>e._SaveToJson())
            }
        }
        _LoadFromJson(e) {
            e && C3.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e.propertyKeyframeDataItemsJson, t, this)
        }
    }
}
{
    class e {
        constructor(e, t) {
            this._addonData = t,
            this._id = e[0],
            this._data = e[1]
        }
        Release() {
            this._addonData = null,
            this._data = null
        }
        GetAddonData() {
            return this._addonData
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                id: this._id,
                data: this._data
            }
        }
        _LoadFromJson(e) {
            e && (this._id = e.id,
            this._data = e.data)
        }
    }
    class t extends e {
        constructor(e, t) {
            super(e, t),
            this._startAnchor = this._data[0],
            this._startEnable = !!this._data[1],
            this._endAnchor = this._data[2],
            this._endEnable = !!this._data[3]
        }
        Release() {
            super.Release()
        }
        GetStartAnchor() {
            return this._startAnchor
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndAnchor() {
            return this._endAnchor
        }
        GetEndEnable() {
            return this._endEnable
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                startAnchor: this._startAnchor,
                startEnable: !!this._startEnable,
                endAnchor: this._endAnchor,
                endEnable: !!this._endEnable
            })
        }
        _LoadFromJson(e) {
            e && (super._LoadFromJson(e),
            this._startAnchor = e.startAnchor,
            this._startEnable = !!e.startEnable,
            this._endAnchor = e.endAnchor,
            this._endEnable = !!e.endEnable)
        }
    }
    C3.AddonData = class {
        constructor(e, a) {
            this._propertyKeyframeDataItem = a,
            this._addonDataItems = [],
            C3.TimelineDataManager._CreateDataItems(this._addonDataItems, e, {
                prop: 0,
                map: new Map([['cubic-bezier', t]])
            }, this)
        }
        Release() {
            this._propertyKeyframeDataItem = null;
            for (const e of this._addonDataItems)
                e.Release();
            C3.clearArray(this._addonDataItems),
            this._addonDataItems = null
        }
        GetPropertyKeyframeDataItem() {
            return this._propertyKeyframeDataItem
        }
        *addonDataItems() {
            for (const e of this._addonDataItems)
                yield e
        }
        _SaveToJson() {
            return {
                addonDataItemsJson: this._addonDataItems.map(e=>e._SaveToJson())
            }
        }
        _LoadFromJson(e) {
            e && C3.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, e.addonDataItemsJson, {
                prop: 'id',
                map: new Map([['cubic-bezier', t]])
            }, this)
        }
    }
}
{
    let e = 0;
    C3.Tween = class extends C3.TimelineState {
        constructor(t, a) {
            super(`tween-${e++}`, t, a),
            this._id = '',
            this._destroyInstanceOnComplete = !1,
            this._initialValueMode = 'start-value',
            this._on_completed_callbacks = null,
            this._on_started_callbacks = null
        }
        GetInstance() {
            const e = this.GetTracks();
            if (e && e.length) {
                const t = e[0];
                if (t) {
                    const e = t.GetInstance();
                    return t.IsInstanceValid() ? e : null
                }
            }
        }
        AddStartedCallback(e) {
            this._on_started_callbacks || (this._on_started_callbacks = []),
            this._on_started_callbacks.push(e)
        }
        AddCompletedCallback(e) {
            this._on_completed_callbacks || (this._on_completed_callbacks = []),
            this._on_completed_callbacks.push(e)
        }
        RemoveStartedCallback(e) {
            if (this._on_started_callbacks) {
                const t = this._on_started_callbacks.indexOf(e);
                -1 !== t && this._on_started_callbacks.splice(t, 1)
            }
        }
        RemoveCompletedCallback(e) {
            if (this._on_completed_callbacks) {
                const t = this._on_completed_callbacks.indexOf(e);
                -1 !== t && this._on_completed_callbacks.splice(t, 1)
            }
        }
        SetStartValue(t, a) {
            for (const e of this._tracks)
                for (const n of e._propertyTracks) {
                    if (n.GetPropertyName() !== a)
                        continue;
                    const r = n.GetPropertyTrackData()
                      , i = n.GetPropertyTrackDataItem()
                      , e = r.GetFirstPropertyKeyframeDataItem(i);
                    e.SetValue(t),
                    e.SetAbsoluteValue(t)
                }
        }
        _GetPropertyTrackState(e) {
            for (const t of this._tracks)
                for (const a of t._propertyTracks)
                    if (a.GetPropertyName() === e)
                        return a
        }
        BeforeSetEndValues(e, t) {
            for (const n of t) {
                const e = this._GetPropertyTrackState(n);
                this.SetStartValue(e.GetCurrentState(), n)
            }
            this.IsForwardPlayBack() ? (this.SetTotalTime(this.GetTotalTime() - this.GetTime()),
            this._SetTime(0)) : (this.SetTotalTime(this.GetTime()),
            this._SetTime(this.GetTotalTime())),
            this.SetInitialStateFromSetTime()
        }
        SetEndValue(t, a) {
            const n = this._GetPropertyTrackState(a)
              , r = n.GetPropertyTrackData()
              , i = n.GetPropertyTrackDataItem()
              , e = r.GetLastPropertyKeyframeDataItem(i);
            e.SetTime(this.GetTotalTime()),
            e.SetValue(t),
            e.SetAbsoluteValue(t)
        }
        SetId(e) {
            this._id = e
        }
        GetId() {
            return this._id
        }
        SetInitialValueMode(e) {
            this._initialValueMode = e
        }
        GetInitialValueMode() {
            return this._initialValueMode
        }
        SetDestroyInstanceOnComplete(e) {
            this._destroyInstanceOnComplete = e
        }
        GetDestroyInstanceOnComplete() {
            return this._destroyInstanceOnComplete
        }
        OnStarted() {
            if (this._on_started_callbacks)
                for (const e of this._on_started_callbacks)
                    e(this);
            if (!this.IsComplete())
                for (const e of this._tracks)
                    e.CompareSaveStateWithCurrent()
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (!this._finishedTriggers && (this._finishedTriggers = !0,
            this._on_completed_callbacks))
                for (const e of this._on_completed_callbacks)
                    e(this)
        }
        SetTime(e) {
            this._DeleteIntermediateKeyframes(),
            super.SetTime(e)
        }
        SetInitialState(e) {
            if (!this.InitialStateSet() && 'current-state' === this.GetInitialValueMode())
                for (const e of this._tracks)
                    e.CompareInitialStateWithCurrent();
            super.SetInitialState(e)
        }
        Stop(e=!1) {
            if (super.Stop(e),
            !this.IsComplete())
                for (const e of this._tracks)
                    e.SaveState()
        }
        Reset() {
            this._DeleteIntermediateKeyframes(),
            super.Reset()
        }
        _DeleteIntermediateKeyframes() {
            for (const e of this._tracks) {
                const t = e=>{
                    const t = e.GetTime()
                      , a = this.GetTotalTime();
                    return 0 !== t && t !== a
                }
                ;
                e.DeleteKeyframes(t),
                e.DeletePropertyKeyframes(t)
            }
        }
        MaybeTriggerKeyframeReachedConditions() {}
        Tick() {
            const e = this.GetInstance()
              , t = this.GetRuntime().GetDt(e);
            super.Tick(t, 1)
        }
        _SaveToJson() {
            const e = super._SaveToJson()
              , t = this.GetTimelineDataItem();
            return Object.assign(e, {
                tweenDataItemJson: t._SaveToJson(),
                id: this._id,
                destroyInstanceOnComplete: this._destroyInstanceOnComplete,
                initialValueMode: this._initialValueMode
            })
        }
        _LoadFromJson(e) {
            if (e) {
                const t = this.GetTimelineDataItem();
                t._LoadFromJson(e.tweenDataItemJson),
                super._LoadFromJson(e),
                this._id = e.id,
                this._destroyInstanceOnComplete = e.destroyInstanceOnComplete,
                this._initialValueMode = e.initialValueMode
            }
        }
        static IsPlaying(e) {
            return e.IsPlaying()
        }
        static Build(t) {
            const a = t.runtime.GetTimelineManager()
              , n = new C3.TimelineDataItem;
            if (t.json) {
                n._LoadFromJson(t.json.tweenDataItemJson);
                const e = new C3.Tween(n,a);
                return e._LoadFromJson(t.json),
                e
            } else {
                const r = new C3.Tween(n,a);
                C3.IsArray(t.propertyTracksConfig) || (t.propertyTracksConfig = [t.propertyTracksConfig]),
                r.SetId(t.id),
                r.SetTags(t.tags),
                r.SetInitialValueMode(t.initialValueMode),
                r.SetDestroyInstanceOnComplete(t.releaseOnComplete),
                r.SetTotalTime(t.time),
                r.SetStep(0),
                r.SetInterpolationMode('default'),
                r.SetResultMode(t.propertyTracksConfig[0].resultMode);
                const i = r.AddTrack();
                i.SetInstanceUID(t.instance.GetUID()),
                i.SetInterpolationMode('default'),
                i.SetResultMode(t.propertyTracksConfig[0].resultMode),
                i.SetEnable(!0),
                i.SetObjectClassIndex(t.instance.GetObjectClass().GetIndex());
                const e = i.AddKeyframe();
                e.SetTime(0),
                e.SetEase('noease'),
                e.SetEnable(!0),
                e.SetTags('');
                const l = i.AddKeyframe();
                l.SetTime(t.time),
                l.SetEase('noease'),
                l.SetEnable(!0),
                l.SetTags('');
                for (const e of t.propertyTracksConfig) {
                    const a = i.AddPropertyTrack();
                    a.SetSourceAdapterId(e.sourceId),
                    a.SetSourceAdapterArgs(e.sourceArgs),
                    a.SetPropertyName(e.property),
                    a.SetPropertyType(e.type),
                    a.SetMin(NaN),
                    a.SetMax(NaN),
                    a.SetInterpolationMode('default'),
                    a.SetResultMode(e.resultMode),
                    a.SetEnable(!0);
                    const n = a.AddPropertyKeyframe();
                    n.SetType(e.valueType),
                    n.SetTime(0),
                    n.SetEase(e.ease),
                    n.SetEnable(!0),
                    n.SetValue(e.startValue),
                    n.SetAbsoluteValue(e.startValue);
                    const r = a.AddPropertyKeyframe();
                    r.SetType(e.valueType),
                    r.SetTime(t.time),
                    r.SetEase(e.ease),
                    r.SetEnable(!0),
                    r.SetValue(e.endValue),
                    r.SetAbsoluteValue(e.endValue)
                }
                return r
            }
        }
    }
}
'use strict',
C3.Transition = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._name = e[0],
        this._transitionKeyframes = [];
        for (const t of e[1]) {
            const e = C3.TransitionKeyframe.Create(this, t);
            this._transitionKeyframes.push(e)
        }
        this._precalculatedSamples = new Map,
        this._transitionKeyframeCache = new Map,
        this._PreCalcSamples(),
        Ease.AddCustomEase(this._name, (e,t,a,n)=>this.Interpolate(e, t, a, n))
    }
    static Create(e) {
        return C3.New(C3.Transition, e)
    }
    Release() {
        for (const e of this._transitionKeyframes)
            e.Release();
        C3.clearArray(this._transitionKeyframes),
        this._transitionKeyframes = null,
        this._precalculatedSamples.clear(),
        this._precalculatedSamples = null,
        this._transitionKeyframeCache.clear(),
        this._transitionKeyframeCache = null
    }
    GetTransitionKeyFrameAt(e) {
        const t = this._transitionKeyframeCache.get(e);
        if (t)
            return t;
        for (const t of this._transitionKeyframes)
            if (t.GetValueX() === e)
                return this._transitionKeyframeCache.set(e, t),
                t
    }
    GetFirstTransitionKeyFrameHigherThan(e) {
        for (const t of this._transitionKeyframes)
            if (t.GetValueX() > e)
                return t
    }
    GetFirstTransitionKeyFrameHigherOrEqualThan(e) {
        for (const t of this._transitionKeyframes)
            if (t.GetValueX() >= e)
                return t
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(e) {
        for (let t = this._transitionKeyframes.length - 1; 0 <= t; t--) {
            const a = this._transitionKeyframes[t];
            if (a.GetValueX() <= e)
                return a
        }
    }
    Interpolate(t, a, _, u) {
        const d = t / u;
        let e = this.GetTransitionKeyFrameAt(d)
          , c = null;
        e ? c = this.GetFirstTransitionKeyFrameHigherThan(d) : (e = this.GetFirstTransitionKeyFrameLowerOrEqualThan(d),
        c = this.GetFirstTransitionKeyFrameHigherOrEqualThan(d));
        const S = c.GetValueX() - e.GetValueX()
          , h = C3.mapToRange(d, e.GetValueX(), c.GetValueX(), 0, S)
          , i = e.GetValueX()
          , y = e.GetValueY()
          , G = e.GetValueX() + e.GetStartAnchorX()
          , l = e.GetValueY() + e.GetStartAnchorY()
          , m = c.GetValueX() + c.GetEndAnchorX()
          , n = c.GetValueY() + c.GetEndAnchorY()
          , b = c.GetValueX()
          , p = c.GetValueY();
        let T = Ease.GetEase('spline')(h, i, y, G, l, m, n, b, p, this._precalculatedSamples.get(e));
        return T += e.GetValueY(),
        (1 - T) * a + T * (a + _)
    }
    _PreCalcSamples() {
        this._precalculatedSamples.clear();
        for (let t = 0; t < this._transitionKeyframes.length - 1; t++) {
            const a = this._transitionKeyframes[t];
            if (!a.GetStartEnable())
                continue;
            const n = a
              , r = this._transitionKeyframes[t + 1]
              , i = n.GetValueX()
              , e = n.GetValueX() + n.GetStartAnchorX()
              , l = r.GetValueX() + r.GetEndAnchorX()
              , _ = r.GetValueX();
            this._precalculatedSamples.set(n, Ease.GetBezierSamples(i, e, l, _))
        }
    }
}
,
'use strict',
C3.TransitionKeyframe = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._transition = e,
        this._valueX = t[0],
        this._valueY = t[1],
        this._startAnchorX = t[2],
        this._startAnchorY = t[3],
        this._endAnchorX = t[4],
        this._endAnchorY = t[5],
        this._startEnable = t[6],
        this._endEnable = t[7]
    }
    Release() {
        this._transition = null
    }
    static Create(e, t) {
        return C3.New(C3.TransitionKeyframe, e, t)
    }
    GetValueX() {
        return this._valueX
    }
    GetValueY() {
        return this._valueY
    }
    GetStartAnchorX() {
        return this._startAnchorX
    }
    GetStartAnchorY() {
        return this._startAnchorY
    }
    GetEndAnchorX() {
        return this._endAnchorX
    }
    GetEndAnchorY() {
        return this._endAnchorY
    }
    GetStartEnable() {
        return this._startEnable
    }
    GetEndEnable() {
        return this._endEnable
    }
}
,
'use strict',
C3.TransitionManager = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e,
        this._transitions = []
    }
    Release() {
        for (const e of this._transitions)
            e.Release();
        C3.clearArray(this._transitions),
        this._transitions = null
    }
    Create(e) {
        this._transitions.push(C3.Transition.Create(e))
    }
}
,
'use strict',
C3.SolStack = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._objectClass = e,
        this._stack = [],
        this._stack.push(C3.New(C3.Sol, this)),
        this._index = 0,
        this._current = this._stack[0]
    }
    Release() {
        for (const e of this._stack)
            e.Release();
        C3.clearArray(this._stack),
        this._current = null,
        this._objectClass = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetCurrentSol() {
        return this._current
    }
    Clear() {
        this.GetCurrentSol().Clear()
    }
    PushClean() {
        const e = this._stack
          , t = ++this._index;
        if (t === e.length) {
            const t = C3.New(C3.Sol, this);
            e.push(t),
            this._current = t
        } else {
            const a = e[t];
            a.Reset(),
            this._current = a
        }
    }
    PushCopy() {
        const e = this._stack
          , t = ++this._index;
        t === e.length && e.push(C3.New(C3.Sol, this));
        const a = e[t];
        a.Copy(e[t - 1]),
        this._current = a
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
    RemoveInstances(e) {
        const t = this._stack;
        for (let a = 0, n = t.length; a < n; ++a)
            t[a].RemoveInstances(e)
    }
}
,
'use strict',
C3.Sol = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._stack = e,
        this._objectClass = this._stack.GetObjectClass(),
        this._eventStack = this._objectClass.GetRuntime().GetEventStack(),
        this._selectAll = !0,
        this._instances = [],
        this._elseInstances = []
    }
    Release() {
        this.ClearArrays(),
        this._stack = null,
        this._objectClass = null,
        this._eventStack = null
    }
    ClearArrays() {
        C3.clearArray(this._instances),
        C3.clearArray(this._elseInstances)
    }
    GetObjectClass() {
        return this._objectClass
    }
    IsSelectAll() {
        return this._selectAll
    }
    HasAnyInstances() {
        return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length
    }
    GetInstances() {
        return this._selectAll ? this._objectClass.GetInstances() : this._instances
    }
    HasAnyElseInstances() {
        return !!this._elseInstances.length
    }
    GetElseInstances() {
        return this._elseInstances
    }
    GetExpressionInstances() {
        const e = this.GetInstances();
        return e.length ? e : this._elseInstances
    }
    Reset() {
        this._selectAll = !0,
        C3.clearArray(this._elseInstances)
    }
    Clear() {
        this._selectAll = !0
    }
    Copy(e) {
        e.IsSelectAll() ? this.Reset() : (this._selectAll = !1,
        C3.shallowAssignArray(this._instances, e._instances),
        C3.clearArray(this._elseInstances))
    }
    _PushInstance(e) {
        this._instances.push(e)
    }
    _PushElseInstance(e) {
        this._elseInstances.push(e)
    }
    _SetSelectAll(e) {
        this._selectAll = !!e
    }
    _GetOwnInstances() {
        return this._instances
    }
    _GetOwnElseInstances() {
        return this._elseInstances
    }
    SetSinglePicked(e) {
        this._selectAll = !1,
        C3.clearArray(this._instances),
        this._instances.push(e)
    }
    SetArrayPicked(e) {
        this._selectAll = !1,
        C3.shallowAssignArray(this._instances, e)
    }
    PickOne(e) {
        if (e)
            if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
                this.IsSelectAll() && (C3.clearArray(this._instances),
                C3.shallowAssignArray(this._elseInstances, e.GetObjectClass().GetInstances()),
                this._selectAll = !1);
                const t = this._elseInstances.indexOf(e);
                -1 !== t && (this._instances.push(this._elseInstances[t]),
                this._elseInstances.splice(t, 1))
            } else
                this.SetSinglePicked(e)
    }
    RemoveInstances(e) {
        C3.arrayRemoveAllInSet(this._instances, e),
        C3.arrayRemoveAllInSet(this._elseInstances, e)
    }
}
,
'use strict',
C3.EventStack = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._eventSheetManager = e,
        this._runtime = this._eventSheetManager.GetRuntime(),
        this._stack = [],
        this._stack.push(C3.New(C3.EventStackFrame, this, null)),
        this._index = 0,
        this._expFuncStack = []
    }
    Release() {
        for (const e of this._stack)
            e.Release();
        C3.clearArray(this._stack),
        C3.clearArray(this._expFuncStack),
        this._eventSheetManager = null,
        this._runtime = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrentStackFrame() {
        return this._stack[this._index]
    }
    Push(e) {
        const t = this._stack
          , a = ++this._index;
        if (a === t.length) {
            const a = C3.New(C3.EventStackFrame, this, e);
            return t.push(a),
            a
        } else {
            const n = t[a];
            return n.Reset(e),
            n
        }
    }
    Pop() {
        --this._index
    }
    PushExpFunc(e) {
        this._expFuncStack.push(e)
    }
    PopExpFunc() {
        this._expFuncStack.pop()
    }
    GetCurrentExpFuncStackFrame() {
        const e = this._expFuncStack;
        return 0 === e.length ? null : e[e.length - 1]
    }
}
,
'use strict',
C3.EventStackFrame = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._stack = e,
        this._runtime = this._stack.GetRuntime(),
        this._currentEvent = t,
        this._cndIndex = 0,
        this._actIndex = 0,
        this._lastEventTrue = !1,
        this._elseBranchRan = !1,
        this._expressionObjectClass = null,
        this._functionReturnType = 0,
        this._functionReturnValue = 0
    }
    Release() {
        this.Reset(null),
        this._stack = null,
        this._runtime = null
    }
    Reset(e) {
        this._currentEvent = e,
        this._cndIndex = 0,
        this._actIndex = 0,
        this._lastEventTrue = !1,
        this._elseBranchRan = !1
    }
    _Restore(e, t) {
        this._currentEvent = e,
        this._cndIndex = 0,
        this._actIndex = t
    }
    ResetQuick() {
        this._cndIndex = 0,
        this._actIndex = 0
    }
    GetCurrentEvent() {
        return this._currentEvent
    }
    SetCurrentEvent(e) {
        this._currentEvent = e
    }
    GetConditionIndex() {
        return this._cndIndex
    }
    SetConditionIndex(e) {
        this._cndIndex = e
    }
    GetActionIndex() {
        return this._actIndex
    }
    SetActionIndex(e) {
        this._actIndex = e
    }
    SetLastEventTrue(e) {
        this._lastEventTrue = !!e
    }
    GetLastEventTrue() {
        return this._lastEventTrue
    }
    SetElseBranchRan(e) {
        this._elseBranchRan = !!e
    }
    GetElseBranchRan() {
        return this._elseBranchRan
    }
    SetExpressionObjectClass(e) {
        this._expressionObjectClass = e
    }
    GetExpressionObjectClass() {
        return this._expressionObjectClass
    }
    InitCallFunctionExpression(e, t) {
        this._functionReturnType = e,
        this._functionReturnValue = t
    }
    GetFunctionReturnType() {
        return this._functionReturnType
    }
    SetFunctionReturnValue(e) {
        this._functionReturnValue = e
    }
    GetFunctionReturnValue() {
        return this._functionReturnValue
    }
    IsSolModifierAfterCnds() {
        const e = this._currentEvent;
        return !!e.IsSolWriterAfterCnds() || !!(this._cndIndex < e.GetConditionCount() - 1) && !!e.GetSolModifiers().length
    }
}
,
'use strict',
C3.LocalVarStack = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._eventSheetManager = e,
        this._runtime = this._eventSheetManager.GetRuntime(),
        this._stack = [],
        this._index = -1,
        this._current = null,
        this._initialValues = []
    }
    Release() {
        C3.clearArray(this._stack),
        this._eventSheetManager = null,
        this._runtime = null
    }
    _SetInitialValues(e) {
        this._initialValues = e;
        const t = this._initialValues.slice(0);
        this._stack.push(t),
        this._index = 0,
        this._current = t
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetCurrent() {
        return this._current
    }
    Push() {
        const e = ++this._index
          , t = this._stack;
        e === t.length ? t.push(this._initialValues.slice(0)) : C3.shallowAssignArray(t[e], this._initialValues),
        this._current = t[e]
    }
    Pop() {
        this._current = this._stack[--this._index]
    }
}
,
'use strict',
C3.LoopStack = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._eventSheetManager = e,
        this._runtime = this._eventSheetManager.GetRuntime(),
        this._stack = [],
        this._index = -1
    }
    Release() {
        C3.clearArray(this._stack),
        this._eventSheetManager = null,
        this._runtime = null
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    IsInLoop() {
        return 0 <= this._index
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        if (++this._index,
        this._index === this._stack.length) {
            const e = C3.New(C3.Loop, this);
            return this._stack.push(e),
            e
        } else {
            const e = this._stack[this._index];
            return e.Reset(),
            e
        }
    }
    Pop() {
        --this._index
    }
    FindByName(e) {
        const t = this._stack;
        for (let a = this._index; 0 <= a; --a) {
            const n = t[a];
            if (n.GetName() === e)
                return n
        }
        return null
    }
    _GetStack() {
        return this._stack.slice(0, this._index + 1)
    }
}
,
'use strict',
C3.Loop = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._loopStack = e,
        this._name = '',
        this._index = 0,
        this._isStopped = !1,
        this._end = NaN
    }
    Reset() {
        this._name = '',
        this._index = 0,
        this._isStopped = !1,
        this._end = NaN
    }
    SetName(e) {
        this._name = e
    }
    GetName() {
        return this._name
    }
    SetIndex(e) {
        this._index = e
    }
    GetIndex() {
        return this._index
    }
    Stop() {
        this._isStopped = !0
    }
    IsStopped() {
        return this._isStopped
    }
    SetEnd(e) {
        this._end = e
    }
    GetEnd() {
        return this._end
    }
}
,
'use strict',
C3.ArrayStack = class extends C3.DefendedBase {
    constructor() {
        super(),
        this._stack = [],
        this._index = -1
    }
    Release() {
        C3.clearArray(this._stack)
    }
    GetCurrent() {
        return this._stack[this._index]
    }
    Push() {
        if (++this._index,
        this._index === this._stack.length) {
            const e = [];
            return this._stack.push(e),
            e
        }
        return this._stack[this._index]
    }
    Pop() {
        --this._index
    }
}
,
'use strict';
{
    function e(e, t) {
        return e.GetIndex() - t.GetIndex()
    }
    function t(e, t) {
        for (let a = 0, n = e.length; a < n; ++a)
            if (e[a] !== t[a])
                return !1;
        return !0
    }
    C3.EventSheetManager = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._runtime = e,
            this._allSheets = [],
            this._sheetsByName = new Map,
            this._allGroups = [],
            this._groupsByName = new Map,
            this._blocksBySid = new Map,
            this._cndsBySid = new Map,
            this._actsBySid = new Map,
            this._allUniqueSolModifiers = new Map,
            this._eventVarsBySid = new Map,
            this._nextLocalVarIndex = 0,
            this._allGlobalVars = [],
            this._allLocalVars = [],
            this._localVarInitialValues = [],
            this._functionBlocksByName = new Map,
            this._eventStack = C3.New(C3.EventStack, this),
            this._localVarStack = C3.New(C3.LocalVarStack, this),
            this._loopStack = C3.New(C3.LoopStack, this),
            this._triggersToPostInit = [],
            this._queuedTriggers = [],
            this._queuedDebugTriggers = [],
            this._runningEventsDepth = 0,
            this._executingTriggerDepth = 0,
            this._blockFlushingDepth = 0,
            this._scheduledWaits = [],
            this._asyncActionPromises = [],
            self.c3_callFunction = (e,t)=>this._InvokeFunctionFromJS(e, t)
        }
        Release() {
            this.ClearAllScheduledWaits(),
            this._eventStack.Release(),
            this._eventStack = null,
            this._localVarStack.Release(),
            this._localVarStack = null,
            C3.clearArray(this._queuedTriggers),
            C3.clearArray(this._queuedDebugTriggers),
            this._runtime = null,
            C3.clearArray(this._allSheets),
            this._sheetsByName.clear()
        }
        Create(e) {
            const t = C3.New(C3.EventSheet, this, e);
            this._allSheets.push(t),
            this._sheetsByName.set(t.GetName().toLowerCase(), t)
        }
        _AddTriggerToPostInit(e) {
            this._triggersToPostInit.push(e)
        }
        _PostInit() {
            for (const e of this._functionBlocksByName.values())
                e._PostInit(!1);
            for (const e of this._allSheets)
                e._PostInit();
            for (const e of this._allSheets)
                e._UpdateDeepIncludes();
            for (const e of this._triggersToPostInit)
                e._PostInit(!1);
            C3.clearArray(this._triggersToPostInit),
            this._localVarStack._SetInitialValues(this._localVarInitialValues)
        }
        GetRuntime() {
            return this._runtime
        }
        GetEventSheetByName(e) {
            return this._sheetsByName.get(e.toLowerCase()) || null
        }
        _RegisterGroup(e) {
            this._allGroups.push(e),
            this._groupsByName.set(e.GetGroupName(), e)
        }
        _RegisterEventBlock(e) {
            this._blocksBySid.set(e.GetSID(), e)
        }
        _RegisterCondition(e) {
            this._cndsBySid.set(e.GetSID(), e)
        }
        _RegisterAction(e) {
            this._actsBySid.set(e.GetSID(), e)
        }
        _RegisterFunctionBlock(e) {
            this._functionBlocksByName.set(e.GetFunctionName().toLowerCase(), e)
        }
        _RegisterEventVariable(e) {
            this._eventVarsBySid.set(e.GetSID(), e),
            e.IsGlobal() ? this._allGlobalVars.push(e) : this._allLocalVars.push(e)
        }
        _DeduplicateSolModifierList(n) {
            2 <= n.length && n.sort(e);
            let r = this._allUniqueSolModifiers.get(n.length);
            r || (r = [],
            this._allUniqueSolModifiers.set(n.length, r));
            for (let i = 0, a = r.length; i < a; ++i) {
                const a = r[i];
                if (t(n, a))
                    return a
            }
            return r.push(n),
            n
        }
        _GetNextLocalVarIndex(e) {
            return this._localVarInitialValues.push(e.GetInitialValue()),
            this._nextLocalVarIndex++
        }
        GetEventStack() {
            return this._eventStack
        }
        GetCurrentEventStackFrame() {
            return this.GetEventStack().GetCurrentStackFrame()
        }
        GetCurrentEvent() {
            return this.GetCurrentEventStackFrame().GetCurrentEvent()
        }
        GetCurrentCondition() {
            const e = this.GetCurrentEventStackFrame()
              , t = e.GetCurrentEvent();
            return t.GetConditionAt(e.GetConditionIndex())
        }
        GetCurrentAction() {
            const e = this.GetCurrentEventStackFrame()
              , t = e.GetCurrentEvent();
            return t.GetActionAt(e.GetActionIndex())
        }
        GetLocalVarStack() {
            return this._localVarStack
        }
        GetLoopStack() {
            return this._loopStack
        }
        GetEventVariableByName(e, t) {
            for (t = t.GetScopeParent(); t; ) {
                const a = t._GetEventVariableNameInScope(e);
                if (a)
                    return a;
                t = t.GetScopeParent()
            }
            for (const a of this._allGlobalVars)
                if (C3.equalsNoCase(e, a.GetName()))
                    return a;
            return null
        }
        GetAllLocalVariablesInScope(e) {
            const t = [];
            for (e = e.GetScopeParent(); e; )
                C3.appendArray(t, e._GetAllLocalVariablesInScope()),
                e = e.GetScopeParent();
            return t
        }
        _GetLocalVariablesScriptInterface(e) {
            const t = {};
            for (const a of this.GetAllLocalVariablesInScope(e))
                t[a.GetJsPropName()] = a._GetScriptInterfaceDescriptor();
            return Object.create(Object.prototype, t)
        }
        GetEventVariableBySID(e) {
            return this._eventVarsBySid.get(e) || null
        }
        GetEventBlockBySID(e) {
            return this._blocksBySid.get(e) || null
        }
        GetConditionBySID(e) {
            return this._cndsBySid.get(e) || null
        }
        GetActionBySID(e) {
            return this._actsBySid.get(e) || null
        }
        GetFunctionBlockByName(e) {
            return this._functionBlocksByName.get(e.toLowerCase()) || null
        }
        GetAllGlobalVariables() {
            return this._allGlobalVars
        }
        GetAllLocalVariables() {
            return this._allLocalVars
        }
        ResetAllGlobalsToInitialValue() {
            for (const e of this._allGlobalVars)
                e.ResetToInitialValue()
        }
        GetEventGroupByName(e) {
            return this._groupsByName.get(e.toLowerCase()) || null
        }
        GetEventGroupBySID(e) {
            const t = this._blocksBySid.get(e);
            return t && t.IsGroup() ? t : null
        }
        GetAllGroups() {
            return this._allGroups
        }
        ResetAllGroupsInitialActivation() {
            for (const e of this._allGroups)
                e.ResetInitialActivation()
        }
        _ResetAllHasRunFlags() {
            for (const e of this._allSheets)
                e._ResetHasRunFlag()
        }
        RunEvents(e) {
            this._ResetAllHasRunFlags(),
            this._runningEventsDepth++;
            for (const t of e.runningLayouts()) {
                const e = t.GetEventSheet();
                e && (this._runtime.PushCurrentLayout(t),
                e.Run(),
                this._runtime.PopCurrentLayout())
            }
            this._runningEventsDepth--
        }
        async DebugRunEvents(e) {
            this._ResetAllHasRunFlags(),
            this._runningEventsDepth++;
            for (const t of this._DebugRunEventsGen(e))
                await this._runtime.DebugBreak(t);
            this._runningEventsDepth--
        }
        *_DebugRunEventsGen(e) {
            for (const t of e.runningLayouts()) {
                const e = t.GetEventSheet();
                e && (this._runtime.PushCurrentLayout(t),
                yield*e.DebugRun(),
                this._runtime.PopCurrentLayout())
            }
        }
        _Trigger(t, n, r, i) {
            let l = !1;
            if (!t.GetMainRunningLayout())
                return this.QueueTrigger(n, r, i);
            this._executingTriggerDepth++;
            for (const e of t.runningLayouts()) {
                const t = e.GetEventSheet();
                if (!t)
                    continue;
                this._runtime.PushCurrentLayout(e);
                for (const e of t.deepIncludes()) {
                    const t = e._Trigger(n, r, i);
                    l = l || t
                }
                const a = t._Trigger(n, r, i);
                l = l || a,
                this._runtime.PopCurrentLayout()
            }
            return this._executingTriggerDepth--,
            l
        }
        *_DebugTrigger(t, n, r, i) {
            let l = !1;
            if (!t.GetMainRunningLayout())
                return this.QueueTrigger(n, r, i);
            this._executingTriggerDepth++;
            for (const e of t.runningLayouts()) {
                const t = e.GetEventSheet();
                if (!t)
                    continue;
                this._runtime.PushCurrentLayout(e);
                for (const e of t.deepIncludes()) {
                    const t = yield*e._DebugTrigger(n, r, i);
                    l = l || t
                }
                const a = yield*t._DebugTrigger(n, r, i);
                l = l || a,
                this._runtime.PopCurrentLayout()
            }
            return this._executingTriggerDepth--,
            l
        }
        QueueTrigger(e, t, a) {
            return this._queuedTriggers.push([e, t, a]),
            !1
        }
        QueueDebugTrigger(t, a, n) {
            let r = null;
            const i = new Promise(e=>r = e);
            return this._queuedDebugTriggers.push([t, a, n, r]),
            i
        }
        *_RunQueuedDebugTriggersGen() {
            if (this._runtime.HitBreakpoint())
                throw new Error('should not be in breakpoint');
            for (const t = this._runtime.GetLayoutManager(); this._queuedDebugTriggers.length; ) {
                const [a,n,r,i] = this._queuedDebugTriggers.shift()
                  , e = yield*this._DebugTrigger(t, a, n, r);
                i(e)
            }
        }
        async RunQueuedDebugTriggersAsync() {
            for (const e of this._RunQueuedDebugTriggersGen())
                await this._runtime.DebugBreak(e)
        }
        _FastTrigger(t, n, r, i) {
            let l = !1;
            const _ = t.GetMainRunningLayout()
              , d = _.GetEventSheet();
            if (d) {
                this._executingTriggerDepth++,
                this._runtime.PushCurrentLayout(_);
                const e = d.deepIncludes();
                for (let t = 0, a = e.length; t < a; ++t) {
                    const a = e[t]._FastTrigger(n, r, i);
                    l = l || a
                }
                const t = d._FastTrigger(n, r, i);
                return l = l || t,
                this._runtime.PopCurrentLayout(),
                this._executingTriggerDepth--,
                l
            }
        }
        *_DebugFastTrigger(t, n, r, i) {
            let l = !1;
            const _ = t.GetMainRunningLayout()
              , d = _.GetEventSheet();
            if (d) {
                this._executingTriggerDepth++,
                this._runtime.PushCurrentLayout(_);
                const e = d.deepIncludes();
                for (let t = 0, a = e.length; t < a; ++t) {
                    const a = yield*e[t]._DebugFastTrigger(n, r, i);
                    l = l || a
                }
                const t = yield*d._DebugFastTrigger(n, r, i);
                return l = l || t,
                this._runtime.PopCurrentLayout(),
                this._executingTriggerDepth--,
                l
            }
        }
        GetTriggerDepth() {
            return this._executingTriggerDepth
        }
        IsInTrigger() {
            return 0 < this.GetTriggerDepth()
        }
        _IncTriggerDepth() {
            return ++this._executingTriggerDepth
        }
        _DecTriggerDepth() {
            --this._executingTriggerDepth
        }
        IsRunningEvents() {
            return 0 < this._runningEventsDepth
        }
        IsInEventEngine() {
            return this.IsRunningEvents() || this.IsInTrigger()
        }
        _RunQueuedTriggers(e) {
            for (const [t,a,n] of this._queuedTriggers)
                this._Trigger(e, t, a, n);
            C3.clearArray(this._queuedTriggers)
        }
        BlockFlushingInstances(e) {
            e ? this._blockFlushingDepth++ : this._blockFlushingDepth--
        }
        IsFlushingBlocked() {
            return 0 < this._blockFlushingDepth
        }
        ClearSol(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                e[t].GetSolStack().Clear()
        }
        PushCleanSol(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                e[t].GetSolStack().PushClean()
        }
        PushCopySol(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                e[t].GetSolStack().PushCopy()
        }
        PopSol(e) {
            for (let t = 0, a = e.length; t < a; ++t)
                e[t].GetSolStack().Pop()
        }
        AddScheduledWait() {
            const e = C3.New(C3.ScheduledWait, this);
            return this._scheduledWaits.push(e),
            e
        }
        scheduledWaits() {
            return this._scheduledWaits
        }
        RunScheduledWaits() {
            if (!this._scheduledWaits.length)
                return;
            const e = this.GetCurrentEventStackFrame();
            let t = !1;
            this._runningEventsDepth++;
            for (let a = 0, n = this._scheduledWaits.length; a < n; ++a) {
                const n = this._scheduledWaits[a];
                n._ShouldRun() && n._Run(e),
                n.ShouldRelease() && (t = !0)
            }
            t && this._FilterScheduledWaitsToRelease(),
            this._runningEventsDepth--
        }
        async DebugRunScheduledWaits() {
            if (!this._scheduledWaits.length)
                return;
            const e = this.GetCurrentEventStackFrame();
            let t = !1;
            this._runningEventsDepth++;
            for (let a = 0, n = this._scheduledWaits.length; a < n; ++a) {
                const n = this._scheduledWaits[a];
                n._ShouldRun() && (await n._DebugRun(e)),
                n.ShouldRelease() && (t = !0)
            }
            t && this._FilterScheduledWaitsToRelease(),
            this._runningEventsDepth--
        }
        _FilterScheduledWaitsToRelease() {
            const e = C3.arrayFilterOut(this._scheduledWaits, e=>e.ShouldRelease());
            for (const t of e)
                t.Release()
        }
        ClearAllScheduledWaits() {
            for (const e of this._scheduledWaits)
                e.Release();
            C3.clearArray(this._scheduledWaits)
        }
        RemoveInstancesFromScheduledWaits(e) {
            for (const t of this._scheduledWaits)
                t.RemoveInstances(e)
        }
        AddAsyncActionPromise(e) {
            this._asyncActionPromises.push(e)
        }
        ClearAsyncActionPromises() {
            C3.clearArray(this._asyncActionPromises)
        }
        GetPromiseForAllAsyncActions() {
            const e = Promise.all(this._asyncActionPromises);
            return this._asyncActionPromises = [],
            e
        }
        _SaveToJson() {
            return {
                groups: this._SaveGroupsToJson(),
                cnds: this._SaveCndsToJson(),
                acts: this._SaveActsToJson(),
                vars: this._SaveVarsToJson(),
                waits: this._SaveScheduledWaitsToJson()
            }
        }
        _LoadFromJson(e) {
            this._LoadGroupsFromJson(e.groups),
            this._LoadCndsFromJson(e.cnds),
            this._LoadActsFromJson(e.acts),
            this._LoadVarsFromJson(e.vars),
            this._LoadScheduledWaitsFromJson(e.waits)
        }
        _SaveGroupsToJson() {
            const e = {};
            for (const t of this.GetAllGroups())
                e[t.GetSID().toString()] = t.IsGroupActive();
            return e
        }
        _LoadGroupsFromJson(e) {
            for (const [t,n] of Object.entries(e)) {
                const e = parseInt(t, 10)
                  , a = this.GetEventGroupBySID(e);
                a && a.SetGroupActive(n)
            }
        }
        _SaveCndsToJson() {
            const e = {};
            for (const [t,a] of this._cndsBySid) {
                const n = a._SaveToJson();
                n && (e[t.toString()] = n)
            }
            return e
        }
        _LoadCndsFromJson(e) {
            for (const [t,n] of Object.entries(e)) {
                const e = parseInt(t, 10)
                  , a = this.GetConditionBySID(e);
                a && a._LoadFromJson(n)
            }
        }
        _SaveActsToJson() {
            const e = {};
            for (const [t,a] of this._actsBySid) {
                const n = a._SaveToJson();
                n && (e[t.toString()] = n)
            }
            return e
        }
        _LoadActsFromJson(e) {
            for (const [t,n] of Object.entries(e)) {
                const e = parseInt(t, 10)
                  , a = this.GetActionBySID(e);
                a && a._LoadFromJson(n)
            }
        }
        _SaveVarsToJson() {
            const e = {};
            for (const [t,a] of this._eventVarsBySid)
                !a.IsConstant() && (a.IsGlobal() || a.IsStatic()) && (e[t.toString()] = a.GetValue());
            return e
        }
        _LoadVarsFromJson(e) {
            for (const [t,n] of Object.entries(e)) {
                const e = parseInt(t, 10)
                  , a = this.GetEventVariableBySID(e);
                a && a.SetValue(n)
            }
        }
        _SaveScheduledWaitsToJson() {
            return this._scheduledWaits.filter(e=>!e.IsPromise()).map(e=>e._SaveToJson())
        }
        _LoadScheduledWaitsFromJson(e) {
            this.ClearAllScheduledWaits();
            for (const t of e) {
                const e = C3.ScheduledWait._CreateFromJson(this, t);
                e && this._scheduledWaits.push(e)
            }
        }
        _GetPerfRecords() {
            return [...this._runtime.GetLayoutManager().runningLayouts()].map(e=>e.GetEventSheet()).filter(e=>e).map(e=>e._GetPerfRecord())
        }
        FindFirstFunctionBlockParent(e) {
            for (; e; ) {
                const t = e.GetScopeParent();
                if (t instanceof C3.FunctionBlock)
                    return t;
                e = e.GetParent()
            }
            return null
        }
        _InvokeFunctionFromJS(t, a) {
            Array.isArray(a) || (a = []);
            const n = this.GetFunctionBlockByName(t.toLowerCase());
            if (!n)
                return null;
            if (!n.IsEnabled())
                return n.GetDefaultReturnValue();
            const r = n.GetFunctionParameters();
            if (a.length < r.length) {
                a = a.slice(0);
                do
                    a.push(r[a.length].GetInitialValue());
                while (a.length < r.length)
            }
            const i = n.GetEventBlock();
            return i.RunAsExpressionFunctionCall(i.GetSolModifiersIncludingParents(), n.GetReturnType(), n.GetDefaultReturnValue(), ...a)
        }
    }
}
'use strict',
C3.EventSheet = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._eventSheetManager = e,
        this._runtime = e.GetRuntime(),
        this._name = t[0],
        this._events = [],
        this._triggers = new Map,
        this._fastTriggers = new Map,
        this._eventsByDisplayNumber = new Map,
        this._hasRun = !1,
        this._shallowIncludes = [],
        this._deepIncludes = [],
        this._alreadyIncludedSheets = new Set;
        for (const a of t[1])
            this._CreateEvent(a, null, this._events);
        this._perfRecord = this._runtime.IsDebug() ? {
            type: 'sheet',
            name: this._name,
            totalTimeCounter: 0,
            children: []
        } : null
    }
    Release() {
        this._eventSheetManager = null,
        this._runtime = null
    }
    _CreateEvent(e, t, a) {
        switch (e[0]) {
        case 0:
        case 3:
            this._CreateEventBlock(e, t, a);
            break;
        case 1:
            this._CreateEventVariable(e, t, a);
            break;
        case 2:
            this._CreateInclude(e, t, a);
            break;
        case 4:
            this._CreateFunctionBlock(e, t);
            break;
        case 5:
            this._CreateScriptBlock(e, t, a);
            break;
        default:
            throw new Error('invalid event type');
        }
    }
    _CreateEventBlock(e, t, n) {
        const r = C3.EventBlock.Create(this, t, e);
        if (r.IsOrBlock()) {
            n.push(r);
            const e = r.GetConditions();
            for (let t = 0, a = e.length; t < a; ++t)
                e[t].IsTrigger() && this._InitTrigger(r, t)
        } else
            r.IsTrigger() ? this._InitTrigger(r, 0) : n.push(r)
    }
    _CreateFunctionBlock(e, t) {
        const a = C3.FunctionBlock.Create(this, t, e);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateEventVariable(e, t, a) {
        const n = C3.EventVariable.Create(this, t, e);
        a.push(n)
    }
    _CreateInclude(e, t, a) {
        const n = C3.EventInclude.Create(this, t, e);
        a.push(n)
    }
    _CreateScriptBlock(e, t, a) {
        const n = C3.EventScript.Create(this, t, e);
        a.push(n)
    }
    _InitTrigger(t, a) {
        t.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(t);
        const n = t.GetConditionAt(a)
          , r = n._GetFunc()
          , l = n.GetObjectClass();
        if (n.IsFastTrigger()) {
            let e = this._fastTriggers.get(l);
            e || (e = new Map,
            this._fastTriggers.set(l, e));
            const _ = n.GetFastTriggerValue().toLowerCase();
            let d = e.get(r);
            d || (d = new Map,
            e.set(r, d));
            let u = d.get(_);
            u || (u = [],
            d.set(_, u)),
            u.push([t, a])
        } else {
            let e = this._triggers.get(l);
            e || (e = {
                methodMap: new Map,
                behaviors: new Map
            },
            this._triggers.set(l, e));
            const _ = n.GetBehaviorType();
            let d;
            _ ? (d = e.behaviors.get(_),
            !d && (d = new Map,
            e.behaviors.set(_, d))) : d = e.methodMap;
            let u = d.get(r);
            u || (u = [],
            d.set(r, u)),
            u.push([t, a])
        }
    }
    _PostInit() {
        const e = this._events;
        for (let t = 0, a = e.length; t < a; ++t) {
            const n = t < a - 1 && e[t + 1]instanceof C3.EventBlock && e[t + 1].IsElseBlock();
            e[t]._PostInit(n)
        }
    }
    _AddShallowInclude(e) {
        this._shallowIncludes.push(e)
    }
    _UpdateDeepIncludes() {
        C3.clearArray(this._deepIncludes),
        this._AddDeepIncludes(this),
        this._alreadyIncludedSheets.clear()
    }
    _AddDeepIncludes(t) {
        const a = t._deepIncludes
          , n = t._alreadyIncludedSheets;
        for (const r of this._shallowIncludes) {
            const i = r.GetIncludeSheet();
            !r.IsActive() || t === i || n.has(i) || (n.add(i),
            i._AddDeepIncludes(t),
            a.push(i))
        }
    }
    deepIncludes() {
        return this._deepIncludes
    }
    GetEventSheetManager() {
        return this._eventSheetManager
    }
    GetRuntime() {
        return this._runtime
    }
    GetName() {
        return this._name
    }
    _RegisterEventByDisplayNumber(e, t) {
        this._eventsByDisplayNumber.set(t, e)
    }
    _GetEventByDisplayNumber(e) {
        return this._eventsByDisplayNumber.get(e) || null
    }
    _ResetHasRunFlag() {
        this._hasRun = !1
    }
    Run() {
        if (!this._hasRun) {
            const e = this._runtime
              , t = e.IsCPUProfiling()
              , a = t ? performance.now() : 0;
            this._hasRun = !0;
            const n = this.GetEventSheetManager()
              , r = n.GetCurrentEventStackFrame();
            for (const t of this._events)
                t.Run(r),
                n.ClearSol(t.GetSolModifiers()),
                n.ClearAsyncActionPromises(),
                e.FlushPendingInstances();
            r.Reset(null),
            t && (this._perfRecord.totalTimeCounter += performance.now() - a)
        }
    }
    *DebugRun() {
        if (!this._hasRun) {
            this._hasRun = !0;
            const e = this._runtime
              , t = this.GetEventSheetManager()
              , a = t.GetCurrentEventStackFrame();
            for (const n of this._events)
                yield*n.DebugRun(a),
                t.ClearSol(n.GetSolModifiers()),
                t.ClearAsyncActionPromises(),
                e.FlushPendingInstances();
            a.Reset(null)
        }
    }
    _Trigger(t, a, n) {
        if (a) {
            const r = a.GetObjectClass();
            let i = !1
              , e = this._TriggerForClass(t, a, r, n);
            i = i || e;
            for (const l of r.GetFamilies())
                e = this._TriggerForClass(t, a, l, n),
                i = i || e
        } else
            return this._TriggerForClass(t, a, null, null)
    }
    _TriggerForClass(t, n, a, r) {
        const i = this._triggers.get(a);
        if (!i)
            return !1;
        const e = r ? i.behaviors.get(r) : i.methodMap;
        if (!e)
            return !1;
        const l = e.get(t);
        if (!l)
            return !1;
        let _ = !1;
        for (const [i,e] of l) {
            const t = this._ExecuteTrigger(n, i, e);
            _ = _ || t
        }
        return _
    }
    *_DebugTrigger(t, a, n) {
        if (a) {
            const r = a.GetObjectClass();
            let i = !1
              , e = yield*this._DebugTriggerForClass(t, a, r, n);
            i = i || e;
            for (const l of r.GetFamilies())
                e = yield*this._DebugTriggerForClass(t, a, l, n),
                i = i || e
        } else
            return yield*this._DebugTriggerForClass(t, a, null, null)
    }
    *_DebugTriggerForClass(t, n, a, r) {
        const i = this._triggers.get(a);
        if (!i)
            return !1;
        const e = r ? i.behaviors.get(r) : i.methodMap;
        if (!e)
            return !1;
        const l = e.get(t);
        if (!l)
            return !1;
        let _ = !1;
        for (const [i,e] of l) {
            let t;
            t = i.DebugCanRunFast() ? this._ExecuteTrigger(n, i, e) : yield*this._DebugExecuteTrigger(n, i, e),
            _ = _ || t
        }
        return _
    }
    _FastTrigger(t, a, n) {
        const r = a.GetObjectClass()
          , i = this._fastTriggers.get(r);
        if (!i)
            return !1;
        const e = i.get(t);
        if (!e)
            return !1;
        const l = e.get(n);
        if (!l)
            return !1;
        let _ = !1;
        for (let r = 0, i = l.length; r < i; ++r) {
            const e = l[r]
              , t = this._ExecuteTrigger(null, e[0], e[1]);
            _ = _ || t
        }
        return _
    }
    *_DebugFastTrigger(t, a, n) {
        const r = a.GetObjectClass()
          , i = this._fastTriggers.get(r);
        if (!i)
            return !1;
        const e = i.get(t);
        if (!e)
            return !1;
        const l = e.get(n);
        if (!l)
            return !1;
        let _ = !1;
        for (let r = 0, i = l.length; r < i; ++r) {
            const t = l[r]
              , a = t[0]
              , n = t[1];
            let i;
            i = a.DebugCanRunFast() ? this._ExecuteTrigger(null, a, n) : yield*this._DebugExecuteTrigger(null, a, n),
            _ = _ || i
        }
        return _
    }
    _ExecuteTrigger(t, n, a) {
        const r = this._runtime
          , _ = this._eventSheetManager
          , e = _.GetCurrentEvent()
          , d = _.GetEventStack()
          , u = _.GetTriggerDepth();
        let c = !1;
        e && _.PushCleanSol(e.GetSolModifiersIncludingParents()),
        _.PushCleanSol(n.GetSolModifiersIncludingParents());
        const g = 1 < u;
        g && _.GetLocalVarStack().Push();
        const m = d.Push(n);
        if (t) {
            const r = n.GetConditions()[a].GetObjectClass()
              , i = r.GetCurrentSol();
            i.SetSinglePicked(t),
            t.IsInContainer() && t.SetSiblingsSinglePicked()
        }
        let p = !0;
        if (n.GetParent()) {
            const e = n.GetTriggerParents();
            for (let t = 0, a = e.length; t < a; ++t)
                if (!e[t].RunPreTrigger(m)) {
                    p = !1;
                    break
                }
        }
        return p && (r.IncrementExecCount(),
        n.IsOrBlock() ? n.RunOrBlockTrigger(m, a) : n.Run(m),
        c = m.GetLastEventTrue()),
        d.Pop(),
        g && _.GetLocalVarStack().Pop(),
        _.PopSol(n.GetSolModifiersIncludingParents()),
        e && _.PopSol(e.GetSolModifiersIncludingParents()),
        e || 1 !== u || _.IsFlushingBlocked() || r.FlushPendingInstances(),
        c
    }
    *_DebugExecuteTrigger(t, n, a) {
        const r = this._runtime
          , _ = this._eventSheetManager
          , e = _.GetCurrentEvent()
          , d = _.GetEventStack()
          , u = _.GetTriggerDepth();
        let c = !1;
        e && _.PushCleanSol(e.GetSolModifiersIncludingParents()),
        _.PushCleanSol(n.GetSolModifiersIncludingParents());
        const g = 1 < u;
        g && _.GetLocalVarStack().Push();
        const m = d.Push(n);
        if (t) {
            const r = n.GetConditions()[a].GetObjectClass()
              , i = r.GetCurrentSol();
            i.SetSinglePicked(t),
            t.IsInContainer() && t.SetSiblingsSinglePicked()
        }
        let p = !0;
        if (n.GetParent()) {
            const e = n.GetTriggerParents();
            for (let t = 0, a = e.length; t < a; ++t)
                if (!(yield*e[t].DebugRunPreTrigger(m))) {
                    p = !1;
                    break
                }
        }
        return p && (r.IncrementExecCount(),
        n.IsOrBlock() ? yield*n.DebugRunOrBlockTrigger(m, a) : yield*n.DebugRun(m),
        c = m.GetLastEventTrue()),
        d.Pop(),
        g && _.GetLocalVarStack().Pop(),
        _.PopSol(n.GetSolModifiersIncludingParents()),
        e && _.PopSol(e.GetSolModifiersIncludingParents()),
        e || 1 !== u || _.IsFlushingBlocked() || r.FlushPendingInstances(),
        c
    }
    _GetPerfRecord() {
        return this._perfRecord
    }
}
,
'use strict';
{
    function t() {
        return !0
    }
    function *a() {
        return !0
    }
    const n = [];
    C3.EventBlock = class extends C3.DefendedBase {
        constructor(r, i, e) {
            super(),
            this._eventSheet = r,
            this._runtime = r.GetRuntime(),
            this._parent = i,
            this._scopeParent = null,
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(),
            this._solModifiers = [],
            this._solModifiersIncludingParents = [],
            this._hasGotSolModifiersIncludingParents = !1,
            this._isSolWriterAfterCnds = !1,
            this._isTopLevelGroup = !1,
            this._hasElseBlock = !1,
            this._isOrBlock = !!e[2],
            this._isElseBlock = !1,
            this._triggerParents = null,
            this._conditions = [],
            this._actions = [],
            this._subEvents = [],
            this._RunActions = t,
            this._DebugRunActions = a,
            this._isGroup = !1,
            this._isInitiallyActive = !1,
            this._groupName = '',
            this._isGroupActive = !1,
            this._containedIncludes = null,
            this._perfRecord = null,
            this._sid = e[4],
            this._displayNumber = e[5],
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber),
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: e[3][0],
                isBreakable: e[3][1],
                canRunAllConditionsFast: !1,
                canRunAllActionsFast: !1,
                canRunAllSubEventsFast: !1,
                canRunSelfFast: !1
            } : null,
            this.GetEventSheetManager()._RegisterEventBlock(this),
            3 === e[0] && this._InitGroup(e[1]);
            let l = 0;
            for (const t of e[6]) {
                const e = C3.Condition.Create(this, t, l++);
                this._conditions.push(e),
                this._AddSolModifier(e.GetObjectClass())
            }
            l = 0;
            for (const t of e[7]) {
                const e = C3.Action.Create(this, t, l++);
                this._actions.push(e)
            }
            if (9 === e.length) {
                const t = e[8];
                for (const e of t)
                    this._eventSheet._CreateEvent(e, this, this._subEvents)
            }
            this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C3.Plugins.System.Cnds.Else),
            0 === this._conditions.length && (this._conditions = n),
            0 === this._actions.length && (this._actions = n),
            0 === this._subEvents.length && (this._subEvents = n)
        }
        static Create(e, t, a) {
            return C3.New(C3.EventBlock, e, t, a)
        }
        _InitGroup(e) {
            this._isGroup = !0,
            this._isInitiallyActive = !!e[0],
            this._isGroupActive = this._isInitiallyActive,
            this._groupName = e[1].toLowerCase(),
            this._containedIncludes = [],
            this.GetEventSheetManager()._RegisterGroup(this),
            this._runtime.IsDebug() && (this._perfRecord = {
                type: 'group',
                name: e[1],
                totalTimeCounter: 0,
                children: []
            })
        }
        _AddContainedInclude(e) {
            this._containedIncludes.push(e)
        }
        _AddContainerSolModifierToList(e, t) {
            for (const a of e.GetContainer().objectTypes())
                t.includes(a) || t.push(a)
        }
        _AddSolModifierToList(e, t) {
            if (e)
                if (t.includes(e) || t.push(e),
                e.IsFamily())
                    for (const a of e.GetFamilyMembers())
                        a.IsInContainer() && this._AddContainerSolModifierToList(a, t);
                else
                    e.IsInContainer() && this._AddContainerSolModifierToList(e, t)
        }
        _AddSolModifier(e) {
            this._AddSolModifierToList(e, this._solModifiers)
        }
        _AddParentSolModifier(e) {
            this._AddSolModifierToList(e, this._solModifiersIncludingParents)
        }
        SetAllSolModifiers() {
            this._solModifiers = this._runtime.GetAllObjectClasses()
        }
        _PostInit(e) {
            this._hasElseBlock = !!e,
            this._IdentifyTopLevelGroup(),
            this._IdentifyTriggerParents();
            for (const t of this._conditions)
                t._PostInit();
            if (0 < this._actions.length) {
                let e = !1;
                for (const t of this._actions)
                    t._PostInit(),
                    t.HasReturnType() && (e = !0);
                e ? (this._RunActions = this._RunActions_ReturnValue,
                this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast,
                this._DebugRunActions = this._DebugRunActions_Fast)
            }
            const t = this._subEvents;
            for (let n = 0, r = t.length; n < r; ++n) {
                const e = n < r - 1 && t[n + 1]instanceof C3.EventBlock && t[n + 1].IsElseBlock();
                t[n]._PostInit(e)
            }
            this._debugData && this._UpdateCanRunFast(),
            this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
        _GetPerfRecordParent() {
            for (let e = this.GetParent(); e; ) {
                if (e.IsGroup())
                    return e;
                e = e.GetParent()
            }
            return this._eventSheet
        }
        _UpdateCanRunFast() {
            const e = this._debugData;
            e.canRunAllConditionsFast = this._conditions.every(e=>e.DebugCanRunFast()),
            e.canRunAllActionsFast = this._actions.every(e=>e.DebugCanRunFast()),
            e.canRunAllSubEventsFast = this._subEvents.every(e=>e.DebugCanRunFast()),
            e.canRunSelfFast = e.canRunAllConditionsFast && e.canRunAllActionsFast && e.canRunAllSubEventsFast
        }
        _UpdateCanRunFastRecursive() {
            let e = this;
            do
                e._UpdateCanRunFast(),
                e = e.GetParent();
            while (e)
        }
        _IdentifyTopLevelGroup() {
            if (!this.IsGroup())
                return;
            let e = this.GetParent();
            for (this._isTopLevelGroup = !0; e; ) {
                if (!e.IsGroup()) {
                    this._isTopLevelGroup = !1;
                    break
                }
                e = e.GetParent()
            }
        }
        _IdentifySolModifiersIncludingParents() {
            const e = this._runtime.GetAllObjectClasses();
            if (this._solModifiers === e)
                this._solModifiersIncludingParents = e;
            else {
                this._solModifiersIncludingParents = C3.cloneArray(this._solModifiers);
                for (let e = this.GetParent(); e; ) {
                    for (const t of e._solModifiers)
                        this._AddParentSolModifier(t);
                    e = e.GetParent()
                }
                const e = this.GetEventSheetManager();
                this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers),
                this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents)
            }
        }
        _IdentifyTriggerParents() {
            if (this.HasAnyTriggeredCondition()) {
                this._triggerParents = [];
                for (let e = this.GetParent(); e; )
                    this._triggerParents.push(e),
                    e = e.GetParent();
                this._triggerParents.reverse()
            }
        }
        SetSolWriterAfterCnds() {
            this._isSolWriterAfterCnds = !0,
            this._parent && this._parent.SetSolWriterAfterCnds()
        }
        IsSolWriterAfterCnds() {
            return this._isSolWriterAfterCnds
        }
        GetSolModifiers() {
            return this._solModifiers
        }
        GetSolModifiersIncludingParents() {
            return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0,
            this._IdentifySolModifiersIncludingParents()),
            this._solModifiersIncludingParents
        }
        HasSolModifier(e) {
            return this._solModifiers.includes(e)
        }
        GetTriggerParents() {
            return this._triggerParents
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetEventSheetManager() {
            return this._eventSheet.GetEventSheetManager()
        }
        GetRuntime() {
            return this._runtime
        }
        GetParent() {
            return this._parent
        }
        _SetScopeParent(e) {
            this._scopeParent = e
        }
        GetScopeParent() {
            return this._scopeParent || this._parent
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(e) {
            this._debugData.isBreakpoint = !!e,
            this._UpdateCanRunFastRecursive()
        }
        IsGroup() {
            return this._isGroup
        }
        IsTopLevelGroup() {
            return this._isTopLevelGroup
        }
        IsElseBlock() {
            return this._isElseBlock
        }
        HasElseBlock() {
            return this._hasElseBlock
        }
        GetGroupName() {
            return this._groupName
        }
        IsGroupActive() {
            return this._isGroupActive
        }
        ResetInitialActivation() {
            this.SetGroupActive(this._isInitiallyActive)
        }
        SetGroupActive(e) {
            if (e = !!e,
            !this._isGroup)
                throw new Error('not a group');
            if (this._isGroupActive !== e) {
                this._isGroupActive = e;
                for (const e of this._containedIncludes)
                    e.UpdateActive();
                if (this._containedIncludes.length) {
                    const e = this._runtime.GetCurrentLayout()
                      , t = e.GetEventSheet();
                    t && t._UpdateDeepIncludes()
                }
            }
        }
        GetSID() {
            return this._sid
        }
        IsOrBlock() {
            return this._isOrBlock
        }
        IsTrigger() {
            return this._conditions.length && this._conditions[0].IsTrigger()
        }
        IsForFunctionBlock() {
            return this._scopeParent && this._scopeParent instanceof C3.FunctionBlock
        }
        HasAnyTriggeredCondition() {
            return this.IsForFunctionBlock() || this._conditions.some(e=>e.IsTrigger())
        }
        GetConditions() {
            return this._conditions
        }
        GetConditionCount() {
            return this._conditions.length
        }
        GetConditionAt(e) {
            if (e = Math.floor(e),
            0 > e || e >= this._conditions.length)
                throw new RangeError('invalid condition index');
            return this._conditions[e]
        }
        GetConditionByDebugIndex(e) {
            return this.GetConditionAt(e)
        }
        IsFirstConditionOfType(e) {
            let t = e.GetIndex();
            if (0 === t)
                return !0;
            for (--t; 0 <= t; --t)
                if (this._conditions[t].GetObjectClass() === e.GetObjectClass())
                    return !1;
            return !0
        }
        GetActions() {
            return this._actions
        }
        GetActionCount() {
            return this._actions.length
        }
        GetActionAt(e) {
            if (e = Math.floor(e),
            0 > e || e >= this._actions.length)
                throw new RangeError('invalid action index');
            return this._actions[e]
        }
        GetActionByDebugIndex(e) {
            e = Math.floor(e);
            const t = this._actions.find(t=>t.GetDebugIndex() === e);
            if (!t)
                throw new RangeError('invalid action debug index');
            return t
        }
        _HasActionIndex(e) {
            return e = Math.floor(e),
            0 <= e && e < this._actions.length
        }
        GetSubEvents() {
            return this._subEvents
        }
        _GetEventVariableNameInScope(e) {
            for (const t of this._subEvents)
                if (t instanceof C3.EventVariable && C3.equalsNoCase(e, t.GetName()))
                    return t;
            return null
        }
        _GetAllLocalVariablesInScope() {
            return this._subEvents.filter(e=>e instanceof C3.EventVariable)
        }
        RunPreTrigger(t) {
            t.SetCurrentEvent(this);
            let a = !1;
            const n = this._conditions;
            for (let r = 0, e = n.length; r < e; ++r) {
                const e = n[r];
                if (t.SetConditionIndex(r),
                e.IsLooping())
                    throw new Error('trigger cannot be used as sub-event to a loop');
                if (e.Run())
                    a = !0;
                else if (!this._isOrBlock)
                    return !1
            }
            return !this._isOrBlock || a
        }
        RunOrBlockTrigger(e, t) {
            e.SetCurrentEvent(this),
            this._conditions[t].Run() && (this._RunActions(e, 0) && this._RunSubEvents(e),
            e.SetLastEventTrue(!0))
        }
        *DebugRunPreTrigger(t) {
            t.SetCurrentEvent(this);
            let a = !1;
            const n = this._conditions;
            for (let r = 0, e = n.length; r < e; ++r) {
                const e = n[r];
                if (t.SetConditionIndex(r),
                e.IsLooping())
                    throw new Error('trigger cannot be used as sub-event to a loop');
                let i;
                if (i = e.DebugCanRunFast() ? e.Run() : yield*e.DebugRun(),
                i)
                    a = !0;
                else if (!this._isOrBlock)
                    return !1
            }
            return !this._isOrBlock || a
        }
        *DebugRunOrBlockTrigger(e, t) {
            e.SetCurrentEvent(this);
            const a = this._conditions[t];
            let n;
            if (n = a.DebugCanRunFast() ? a.Run() : yield*a.DebugRun(),
            n) {
                let t;
                t = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield*this._DebugRunActions(e, 0),
                t && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
                e.SetLastEventTrue(!0)
            }
        }
        Run(e) {
            e.SetCurrentEvent(this),
            this._isElseBlock || e.SetElseBranchRan(!1),
            this._isOrBlock ? this._RunOrBlock(e) : this._RunAndBlock(e)
        }
        *DebugRun(e) {
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            e.SetCurrentEvent(this),
            this._isElseBlock || e.SetElseBranchRan(!1),
            this._isOrBlock ? yield*this._DebugRunOrBlock(e) : yield*this._DebugRunAndBlock(e)
        }
        _RunOrBlock(t) {
            const a = this._conditions;
            let n = 0 === a.length;
            for (let r = 0, e = a.length; r < e; ++r) {
                const e = a[r];
                if (e.IsTrigger())
                    continue;
                t.SetConditionIndex(r);
                const i = e.Run();
                n = n || i
            }
            t.SetLastEventTrue(n),
            n && (this._RunActions(t, 0) && this._RunSubEvents(t),
            this._hasElseBlock && t.SetElseBranchRan(!0))
        }
        *_DebugRunOrBlock(t) {
            const a = this._conditions;
            let n = 0 === a.length;
            for (let r = 0, e = a.length; r < e; ++r) {
                const e = a[r];
                if (e.IsTrigger())
                    continue;
                t.SetConditionIndex(r);
                let i;
                i = e.DebugCanRunFast() ? e.Run() : yield*e.DebugRun(),
                n = n || i
            }
            if (t.SetLastEventTrue(n),
            n) {
                let e;
                e = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield*this._DebugRunActions(t, 0),
                e && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
                this._hasElseBlock && t.SetElseBranchRan(!0)
            }
        }
        _RunAndBlock(t) {
            const a = this._conditions;
            for (let n = 0, e = a.length; n < e; ++n) {
                const r = a[n];
                t.SetConditionIndex(n);
                const e = r.Run();
                if (!e)
                    return void t.SetLastEventTrue(!1)
            }
            t.SetLastEventTrue(!0),
            this._RunActions(t, 0) && this._RunSubEvents(t),
            t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(!0)
        }
        *_DebugRunAndBlock(t) {
            const a = this._conditions;
            for (let n = 0, e = a.length; n < e; ++n) {
                const r = a[n];
                t.SetConditionIndex(n);
                let e;
                if (e = r.DebugCanRunFast() ? r.Run() : yield*r.DebugRun(),
                !e)
                    return void t.SetLastEventTrue(!1)
            }
            t.SetLastEventTrue(!0);
            let e;
            e = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield*this._DebugRunActions(t, 0),
            e && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
            t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(!0)
        }
        _RunActions_Fast(t, n) {
            const a = this._actions;
            for (let r = n, i = a.length; r < i; ++r) {
                const n = a[r];
                t.SetActionIndex(r),
                n.Run()
            }
            return !0
        }
        *_DebugRunActions_Fast(t, n) {
            const a = this._actions;
            for (let r = n, i = a.length; r < i; ++r) {
                const n = a[r];
                t.SetActionIndex(r),
                n.DebugCanRunFast() ? n.Run() : yield*n.DebugRun()
            }
            return !0
        }
        _RunActions_ReturnValue(t, n) {
            const r = this.GetEventSheetManager()
              , i = this._actions;
            for (let l = n, e = i.length; l < e; ++l) {
                const e = i[l];
                t.SetActionIndex(l);
                const n = e.Run();
                if (e.CanBailOut() && !0 === n)
                    return !1;
                e.IsAsync() && n instanceof Promise && r.AddAsyncActionPromise(n)
            }
            return !0
        }
        *_DebugRunActions_ReturnValue(t, n) {
            const r = this.GetEventSheetManager()
              , i = this._actions;
            for (let l = n, e = i.length; l < e; ++l) {
                const e = i[l];
                t.SetActionIndex(l);
                let n;
                if (n = e.DebugCanRunFast() ? e.Run() : yield*e.DebugRun(),
                e.CanBailOut() && !0 === n)
                    return !1;
                e.IsAsync() && n instanceof Promise && r.AddAsyncActionPromise(n)
            }
            return !0
        }
        _ResumeActionsAndSubEvents(e) {
            this._RunActions(e, e.GetActionIndex()) && this._RunSubEvents()
        }
        *_DebugResumeActionsAndSubEvents(e) {
            (yield*this._DebugRunActions(e, e.GetActionIndex())) && (yield*this._DebugRunSubEvents())
        }
        _RunSubEvents() {
            if (this._subEvents.length) {
                const e = this.IsGroup() && this._runtime.IsCPUProfiling()
                  , t = e ? performance.now() : 0
                  , a = this._eventStack
                  , n = a.Push(this);
                this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(n) : this._RunSubEvents_Fast(n),
                a.Pop(),
                e && (this._perfRecord.totalTimeCounter += performance.now() - t)
            }
        }
        _RunSubEvents_SolWriterAfterCnds(t) {
            const a = this._isGroup
              , n = this._isTopLevelGroup
              , r = this.GetEventSheetManager()
              , l = this._subEvents;
            for (let _ = 0, d = l.length; _ < d; ++_) {
                const u = l[_]
                  , i = u.GetSolModifiers()
                  , e = !n || !a && _ < d - 1;
                e && r.PushCopySol(i),
                u.Run(t),
                e ? r.PopSol(i) : r.ClearSol(i)
            }
        }
        _RunSubEvents_Fast(e) {
            const t = this._subEvents;
            for (let a = 0, n = t.length; a < n; ++a)
                t[a].Run(e)
        }
        *_DebugRunSubEvents() {
            if (this._subEvents.length) {
                const e = this._eventStack
                  , t = e.Push(this);
                this._isSolWriterAfterCnds ? yield*this._DebugRunSubEvents_SolWriterAfterCnds(t) : yield*this._DebugRunSubEvents_Fast(t),
                e.Pop()
            }
        }
        *_DebugRunSubEvents_SolWriterAfterCnds(t) {
            const a = this._isGroup
              , n = this._isTopLevelGroup
              , r = this.GetEventSheetManager()
              , l = this._subEvents;
            for (let _ = 0, d = l.length; _ < d; ++_) {
                const u = l[_]
                  , i = u.GetSolModifiers()
                  , e = !n || !a && _ < d - 1;
                e && r.PushCopySol(i),
                yield*u.DebugRun(t),
                e ? r.PopSol(i) : r.ClearSol(i)
            }
        }
        *_DebugRunSubEvents_Fast(e) {
            const t = this._subEvents;
            for (let a = 0, n = t.length; a < n; ++a)
                yield*t[a].DebugRun(e)
        }
        Retrigger(t, n) {
            this._runtime.IncrementExecCount(),
            n.ResetQuick();
            const r = this._conditions;
            if (!this.IsOrBlock())
                for (let i = t.GetConditionIndex() + 1, e = r.length; i < e; ++i) {
                    const e = r[i];
                    n.SetConditionIndex(i);
                    const t = e.Run();
                    if (!t)
                        return !1
                }
            return this._RunActions(n, 0) && this._RunSubEvents(n),
            !0
        }
        *DebugRetrigger(t, n) {
            this._runtime.IncrementExecCount(),
            n.ResetQuick();
            const r = this._conditions;
            if (!this.IsOrBlock())
                for (let i = t.GetConditionIndex() + 1, e = r.length; i < e; ++i) {
                    const e = r[i];
                    n.SetConditionIndex(i);
                    let t;
                    if (t = e.DebugCanRunFast() ? e.Run() : yield*e.DebugRun(),
                    !t)
                        return !1
                }
            let e;
            return e = this.DebugCanRunActionsFast() ? this._RunActions(n, 0) : yield*this._DebugRunActions(n, 0),
            e && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield*this._DebugRunSubEvents()),
            !0
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
        }
        DebugCanRunActionsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
        }
        DebugCanRunSubEventsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
        }
        _CheckParentsOKToRun(e) {
            if (this.GetParent()) {
                const t = this.GetTriggerParents();
                for (let a = 0, n = t.length; a < n; ++a)
                    if (!t[a].RunPreTrigger(e))
                        return !1
            }
            return !0
        }
        *_DebugCheckParentsOKToRun(e) {
            if (this.GetParent()) {
                const t = this.GetTriggerParents();
                for (let a = 0, n = t.length; a < n; ++a)
                    if (!(yield*t[a].DebugRunPreTrigger(e)))
                        return !1
            }
            return !0
        }
        _EvaluateFunctionCallParameters(e, t, a) {
            if (!(0 < t.length))
                a && e.GetLocalVarStack().Push();
            else if (a) {
                const a = t.map(e=>e.Get(0));
                e.GetLocalVarStack().Push(),
                this._scopeParent.SetFunctionParameters(a)
            } else
                this._scopeParent.EvaluateFunctionParameters(t)
        }
        RunAsFunctionCall(t, a) {
            let n, r;
            const l = 0 < t.length
              , e = this._runtime
              , _ = this._eventStack
              , u = e.GetEventSheetManager()
              , g = u._IncTriggerDepth()
              , i = 1 < g;
            this._EvaluateFunctionCallParameters(u, a, i),
            l && u.PushCleanSol(t);
            const m = _.Push(this);
            if (this._CheckParentsOKToRun(m)) {
                e.IncrementExecCount(),
                m.SetCurrentEvent(this);
                const t = this._scopeParent.IsAsync();
                t && ([r,n] = this._scopeParent.StartAsyncFunctionCall()),
                this._RunAndBlock(m),
                t && this._scopeParent.MaybeFinishAsyncFunctionCall(r)
            }
            return _.Pop(),
            i && u.GetLocalVarStack().Pop(),
            l && u.PopSol(t),
            u._DecTriggerDepth(),
            n
        }
        *DebugRunAsFunctionCall(t, a) {
            let n, r;
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const l = 0 < t.length
              , e = this._runtime
              , _ = this._eventStack
              , u = e.GetEventSheetManager()
              , g = u._IncTriggerDepth()
              , i = 1 < g;
            this._EvaluateFunctionCallParameters(u, a, i),
            l && u.PushCleanSol(t);
            const m = _.Push(this);
            if (yield*this._DebugCheckParentsOKToRun(m)) {
                e.IncrementExecCount(),
                m.SetCurrentEvent(this);
                const t = this._scopeParent.IsAsync();
                t && ([r,n] = this._scopeParent.StartAsyncFunctionCall()),
                yield*this._DebugRunAndBlock(m),
                t && this._scopeParent.MaybeFinishAsyncFunctionCall(r)
            }
            return _.Pop(),
            i && u.GetLocalVarStack().Pop(),
            l && u.PopSol(t),
            u._DecTriggerDepth(),
            n
        }
        RunAsMappedFunctionCall(t) {
            const a = this.GetSolModifiersIncludingParents()
              , n = 0 < a.length
              , r = this._runtime
              , l = this._eventStack
              , e = r.GetEventSheetManager()
              , _ = e._IncTriggerDepth()
              , d = 1 < _;
            d && e.GetLocalVarStack().Push(),
            this._scopeParent.SetFunctionParameters(t),
            n && e.PushCleanSol(a);
            const u = l.Push(this);
            this._CheckParentsOKToRun(u) && (r.IncrementExecCount(),
            u.SetCurrentEvent(this),
            this._RunAndBlock(u)),
            l.Pop(),
            d && e.GetLocalVarStack().Pop(),
            n && e.PopSol(a),
            e._DecTriggerDepth()
        }
        *DebugRunAsMappedFunctionCall(t) {
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const a = this.GetSolModifiersIncludingParents()
              , n = 0 < a.length
              , r = this._runtime
              , l = this._eventStack
              , e = r.GetEventSheetManager()
              , _ = e._IncTriggerDepth()
              , d = 1 < _;
            d && e.GetLocalVarStack().Push(),
            this._scopeParent.SetFunctionParameters(t),
            n && e.PushCleanSol(a);
            const u = l.Push(this);
            (yield*this._DebugCheckParentsOKToRun(u)) && (r.IncrementExecCount(),
            u.SetCurrentEvent(this),
            yield*this._DebugRunAndBlock(u)),
            l.Pop(),
            d && e.GetLocalVarStack().Pop(),
            n && e.PopSol(a),
            e._DecTriggerDepth()
        }
        RunAsExpressionFunctionCall(t, a, n, ...r) {
            let _, d;
            const u = 0 < t.length
              , c = this._runtime
              , g = this._eventStack
              , i = c.GetEventSheetManager()
              , p = i._IncTriggerDepth()
              , h = 1 < p;
            h && i.GetLocalVarStack().Push(),
            0 < r.length && this._scopeParent.SetFunctionParameters(r),
            u && i.PushCleanSol(t);
            const l = g.Push(this);
            if (l.InitCallFunctionExpression(a, n),
            g.PushExpFunc(l),
            c.SetDebuggingEnabled(!1),
            this._CheckParentsOKToRun(l)) {
                c.IncrementExecCount(),
                l.SetCurrentEvent(this);
                const e = this._scopeParent.IsAsync();
                e && ([d,_] = this._scopeParent.StartAsyncFunctionCall()),
                this._RunAndBlock(l),
                e && this._scopeParent.MaybeFinishAsyncFunctionCall(d)
            }
            return c.SetDebuggingEnabled(!0),
            g.Pop(),
            g.PopExpFunc(),
            h && i.GetLocalVarStack().Pop(),
            u && i.PopSol(t),
            i._DecTriggerDepth(),
            _ || l.GetFunctionReturnValue()
        }
    }
}
{
    const e = [];
    let t = !1;
    C3.EventScript = class extends C3.DefendedBase {
        constructor(t, a, n) {
            super();
            const r = t.GetRuntime()
              , i = t.GetEventSheetManager();
            this._eventSheet = t,
            this._eventSheetManager = i,
            this._runtime = t.GetRuntime(),
            this._parent = a;
            const e = r.GetObjectReference(n[1]);
            this._func = e,
            this._displayNumber = n[2],
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber),
            this._debugData = r.IsDebug() ? {
                isBreakpoint: n[3][0],
                isBreakable: n[3][1]
            } : null
        }
        static Create(e, t, a) {
            return C3.New(C3.EventScript, e, t, a)
        }
        _PostInit() {
            const e = this._func
              , t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
            this._func = e.bind(null, this._runtime.GetIRuntime(), t)
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(e) {
            this._debugData.isBreakpoint = !!e
        }
        IsElseBlock() {
            return !1
        }
        GetSolModifiers() {
            return e
        }
        GetSolModifiersIncludingParents() {
            return this._parent ? this._parent.GetSolModifiersIncludingParents() : e
        }
        Run(e) {
            e.SetCurrentEvent(this),
            this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
        }
        async _RunUserScript() {
            try {
                await this._func()
            } catch (e) {
                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, 'font-size: 1.2em; font-weight: bold;', e),
                self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                t || (console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, 'font-weight: bold; text-decoration: underline', '', 'font-weight: bold'),
                t = !0)
            }
        }
        *DebugRun(e) {
            e.SetCurrentEvent(this),
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this.Run(e)
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
        }
        static HadUserScriptException() {
            return t
        }
        static SetHadUserScriptException() {
            t = !0
        }
    }
}
'use strict',
C3.FunctionBlock = class extends C3.DefendedBase {
    constructor(e, t, a) {
        super(),
        this._eventSheet = e,
        this._runtime = e.GetRuntime(),
        this._parent = t;
        const n = a[1];
        this._functionName = n[0],
        this._returnType = n[1],
        this._functionParameters = n[2].map(t=>C3.EventVariable.Create(e, this, t)),
        this._isEnabled = n[3],
        this._isAsync = n[4],
        this._nextAsyncId = 0,
        this._currentAsyncId = -1,
        this._asyncMap = new Map,
        this._eventBlock = C3.EventBlock.Create(e, t, a),
        this._eventBlock._SetScopeParent(this)
    }
    static Create(e, t, a) {
        return C3.New(C3.FunctionBlock, e, t, a)
    }
    _PostInit() {
        for (const e of this._functionParameters)
            e._PostInit();
        this._eventBlock._PostInit(!1)
    }
    _GetEventVariableNameInScope(e) {
        for (const t of this._functionParameters)
            if (C3.equalsNoCase(e, t.GetName()))
                return t;
        return null
    }
    _GetAllLocalVariablesInScope() {
        return this._functionParameters
    }
    GetFunctionParameters() {
        return this._functionParameters
    }
    GetFunctionParameterCount() {
        return this._functionParameters.length
    }
    EvaluateFunctionParameters(e) {
        const t = this._functionParameters;
        for (let a = 0, n = t.length; a < n; ++a)
            t[a].SetValue(e[a].Get(0))
    }
    SetFunctionParameters(e) {
        const t = this._functionParameters;
        for (let a = 0, n = t.length; a < n; ++a)
            t[a].SetValue(e[a])
    }
    CaptureFunctionParameters() {
        return this._functionParameters.map(e=>e.GetValue())
    }
    GetParent() {
        return this._parent
    }
    GetScopeParent() {
        return this._parent
    }
    GetFunctionName() {
        return this._functionName
    }
    GetReturnType() {
        return this._returnType
    }
    IsEnabled() {
        return this._isEnabled
    }
    GetDefaultReturnValue() {
        switch (this._returnType) {
        case 0:
            return null;
        case 2:
            return '';
        default:
            return 0;
        }
    }
    GetEventBlock() {
        return this._eventBlock
    }
    IsAsync() {
        return this._isAsync
    }
    StartAsyncFunctionCall() {
        const e = this._nextAsyncId++;
        this._currentAsyncId = e;
        let t;
        const a = new Promise(e=>t = e);
        return this._asyncMap.set(e, {
            resolve: t,
            pauseCount: 0
        }),
        [e, a]
    }
    MaybeFinishAsyncFunctionCall(e) {
        const t = this._asyncMap.get(e);
        0 === t.pauseCount && (t.resolve(),
        this._asyncMap.delete(e)),
        this._currentAsyncId = -1
    }
    PauseCurrentAsyncFunction() {
        const e = this._asyncMap.get(this._currentAsyncId);
        return e.pauseCount++,
        this._currentAsyncId
    }
    ResumeAsyncFunction(e) {
        this._currentAsyncId = e;
        const t = this._asyncMap.get(e);
        t.pauseCount--
    }
}
,
'use strict';
{
    const e = [];
    C3.EventVariable = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super();
            const n = e.GetEventSheetManager();
            this._eventSheet = e,
            this._eventSheetManager = n,
            this._runtime = e.GetRuntime(),
            this._parent = t,
            this._localVarStack = n.GetLocalVarStack(),
            this._name = a[1],
            this._type = a[2],
            this._initialValue = a[3],
            this._isStatic = !!a[4],
            this._isConstant = !!a[5],
            this._isFunctionParameter = t instanceof C3.FunctionBlock,
            this._sid = a[6],
            this._jsPropName = this._runtime.GetJsPropName(a[8]),
            this._scriptSetter = e=>this.SetValue(e),
            this._scriptGetter = ()=>this.GetValue(),
            this._hasSingleValue = !this._parent || this._isStatic || this._isConstant,
            this._value = this._initialValue,
            this._localIndex = -1,
            this.IsBoolean() && (this._value = this._value ? 1 : 0),
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = n._GetNextLocalVarIndex(this)),
            n._RegisterEventVariable(this)
        }
        static Create(e, t, a) {
            return C3.New(C3.EventVariable, e, t, a)
        }
        _PostInit() {}
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetParent() {
            return this._parent
        }
        IsGlobal() {
            return !this.GetParent()
        }
        IsLocal() {
            return !this.IsGlobal()
        }
        IsFunctionParameter() {
            return this._isFunctionParameter
        }
        IsStatic() {
            return this._isStatic
        }
        IsConstant() {
            return this._isConstant
        }
        IsNumber() {
            return 0 === this._type
        }
        IsString() {
            return 1 === this._type
        }
        IsBoolean() {
            return 2 === this._type
        }
        IsElseBlock() {
            return !1
        }
        GetSID() {
            return this._sid
        }
        GetInitialValue() {
            return this._initialValue
        }
        GetSolModifiers() {
            return e
        }
        Run() {
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
        }
        DebugCanRunFast() {
            return !0
        }
        *DebugRun(e) {
            this.Run(e)
        }
        SetValue(e) {
            this.IsNumber() ? 'number' != typeof e && (e = parseFloat(e)) : this.IsString() ? 'string' != typeof e && (e = e.toString()) : this.IsBoolean() && (e = e ? 1 : 0),
            this._hasSingleValue ? this._value = e : this._localVarStack.GetCurrent()[this._localIndex] = e
        }
        GetValue() {
            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
        }
        GetTypedValue() {
            let e = this.GetValue();
            return this.IsBoolean() && (e = !!e),
            e
        }
        ResetToInitialValue() {
            this._value = this._initialValue
        }
        _GetScriptInterfaceDescriptor() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._scriptGetter,
                set: this._scriptSetter
            }
        }
    }
}
{
    const e = [];
    C3.EventInclude = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super();
            const n = e.GetEventSheetManager();
            this._eventSheet = e,
            this._eventSheetManager = n,
            this._runtime = e.GetRuntime(),
            this._parent = t,
            this._includeSheet = null,
            this._includeSheetName = a[1],
            this._isActive = !0
        }
        static Create(e, t, a) {
            return C3.New(C3.EventInclude, e, t, a)
        }
        _PostInit() {
            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName),
            this._eventSheet._AddShallowInclude(this);
            for (let e = this.GetParent(); e; )
                e instanceof C3.EventBlock && e.IsGroup() && e._AddContainedInclude(this),
                e = e.GetParent();
            this.UpdateActive(),
            this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
        }
        GetParent() {
            return this._parent
        }
        GetSolModifiers() {
            return e
        }
        GetIncludeSheet() {
            return this._includeSheet
        }
        Run() {
            const e = !!this.GetParent()
              , t = this._runtime.GetAllObjectClasses();
            e && this._eventSheetManager.PushCleanSol(t),
            this._includeSheet.Run(),
            e && this._eventSheetManager.PopSol(t)
        }
        *DebugRun() {
            const e = !!this.GetParent()
              , t = this._runtime.GetAllObjectClasses();
            e && this._eventSheetManager.PushCleanSol(t),
            yield*this._includeSheet.DebugRun(),
            e && this._eventSheetManager.PopSol(t)
        }
        DebugCanRunFast() {
            return !1
        }
        IsActive() {
            return this._isActive
        }
        UpdateActive() {
            for (let e = this.GetParent(); e; ) {
                if (e instanceof C3.EventBlock && e.IsGroup() && !e.IsGroupActive())
                    return void (this._isActive = !1);
                e = e.GetParent()
            }
            this._isActive = !0
        }
    }
}
{
    function t(e, t) {
        return e >= t ? e % t : 0 > e ? (e <= -t && (e %= t),
        0 > e && (e += t),
        e) : e
    }
    C3.ExpNode = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._owner = e,
            this._runtime = e.GetRuntime()
        }
        _PostInit() {}
        static CreateNode(t, a) {
            const u = a[0];
            return C3.New([e, l, _, d, n, r][u], t, a)
        }
    }
    ;
    class n extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._systemPlugin = this._runtime.GetSystemPlugin(),
            this._func = this._runtime.GetObjectReference(t[1]),
            (this._func === C3.Plugins.System.Exps.random || this._func === C3.Plugins.System.Exps.choose) && this._owner.SetVariesPerInstance()
        }
        GetBoundMethod() {
            return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
        }
    }
    class r extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._functionBlock = null,
            this._functionName = t[1],
            this._owner.SetVariesPerInstance()
        }
        _PostInit() {
            const e = this._runtime.GetEventSheetManager();
            this._functionBlock = e.GetFunctionBlockByName(this._functionName),
            this._functionName = null;
            const t = this._owner.GetEventBlock()
              , a = this._functionBlock.GetEventBlock();
            this._combinedSolModifiers = [...new Set([...t.GetSolModifiersIncludingParents(), ...a.GetSolModifiersIncludingParents()])],
            this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers)
        }
        GetBoundMethod() {
            const e = this._functionBlock;
            if (e.IsEnabled()) {
                const t = e.GetEventBlock();
                return C3.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t, this._combinedSolModifiers, e.GetReturnType(), e.GetDefaultReturnValue())
            } else {
                const t = e.GetDefaultReturnValue();
                return ()=>t
            }
        }
    }
    class l extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._objectClass = this._runtime.GetObjectClassByIndex(t[1]),
            this._func = this._runtime.GetObjectReference(t[2]),
            this._returnsString = !!t[3],
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(),
            this._owner._MaybeVaryFor(this._objectClass)
        }
        GetBoundMethod() {
            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
        }
        ExpObject(...a) {
            const n = this._objectClass
              , r = n.GetCurrentSol().GetExpressionInstances()
              , i = r.length;
            if (0 === i)
                return this._returnsString ? '' : 0;
            const e = t(this._owner.GetSolIndex(), i);
            return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(n),
            this._func.apply(r[e].GetSdkInstance(), a)
        }
        ExpObject_InstExpr(a, ...n) {
            const r = this._objectClass
              , i = r.GetInstances()
              , e = i.length;
            if (0 === e)
                return this._returnsString ? '' : 0;
            const l = t(a, e);
            return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r),
            this._func.apply(i[l].GetSdkInstance(), n)
        }
    }
    class _ extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._objectClass = this._runtime.GetObjectClassByIndex(t[1]),
            this._varIndex = t[3],
            this._returnsString = !!t[2],
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpInstVar() {
            const e = this._objectClass.GetCurrentSol().GetExpressionInstances()
              , a = e.length;
            if (0 === a)
                return this._returnsString ? '' : 0;
            const n = t(this._owner.GetSolIndex(), a);
            return e[n]._GetInstanceVariableValueUnchecked(this._varIndex)
        }
        ExpInstVar_Family() {
            const a = this._objectClass
              , n = a.GetCurrentSol().GetExpressionInstances()
              , r = n.length;
            if (0 === r)
                return this._returnsString ? '' : 0;
            const i = t(this._owner.GetSolIndex(), r)
              , e = n[i]
              , l = e.GetObjectClass().GetFamilyInstanceVariableOffset(a.GetFamilyIndex());
            return e._GetInstanceVariableValueUnchecked(this._varIndex + l)
        }
        ExpInstVar_InstExpr(a) {
            const n = this._objectClass
              , r = n.GetInstances()
              , i = r.length;
            if (0 === i)
                return this._returnsString ? '' : 0;
            const e = t(a, i)
              , l = r[e];
            let _ = 0;
            return n.IsFamily() && (_ = l.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex())),
            l._GetInstanceVariableValueUnchecked(this._varIndex + _)
        }
    }
    class e extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._objectClass = this._runtime.GetObjectClassByIndex(t[1]),
            this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]),
            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]),
            this._func = this._runtime.GetObjectReference(t[3]),
            this._returnsString = !!t[4],
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(),
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpBehavior(...a) {
            const n = this._objectClass
              , r = n.GetCurrentSol().GetExpressionInstances()
              , i = r.length;
            if (0 === i)
                return this._returnsString ? '' : 0;
            const e = t(this._owner.GetSolIndex(), i);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(n);
            const l = r[e];
            let _ = 0;
            return n.IsFamily() && (_ = l.GetObjectClass().GetFamilyBehaviorOffset(n.GetFamilyIndex())),
            this._func.apply(l.GetBehaviorInstances()[this._behaviorIndex + _].GetSdkInstance(), a)
        }
        ExpBehavior_InstExpr(a, ...n) {
            const r = this._objectClass
              , l = r.GetInstances()
              , e = l.length;
            if (0 === e)
                return this._returnsString ? '' : 0;
            const _ = t(a, e);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r);
            const d = l[_];
            let u = 0;
            return r.IsFamily() && (u = d.GetObjectClass().GetFamilyBehaviorOffset(r.GetFamilyIndex())),
            this._func.apply(d.GetBehaviorInstances()[this._behaviorIndex + u].GetSdkInstance(), n)
        }
    }
    class d extends C3.ExpNode {
        constructor(e, t) {
            super(e),
            this._eventVar = null,
            this._eventVarName = t[1]
        }
        _PostInit() {
            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableByName(this._eventVarName, this._owner.GetEventBlock()),
            this._eventVarName = null
        }
        GetVar() {
            return this._eventVar
        }
    }
}
{
    function t(e) {
        const t = self.C3_ExpressionFuncs[e];
        if (!t)
            throw new Error('invalid expression number');
        return t
    }
    C3.Parameter = class extends C3.DefendedBase {
        constructor(e, t, a) {
            super(),
            this._owner = e,
            this._index = a,
            this._type = t,
            this.Get = null,
            this._variesPerInstance = !1,
            this._isConstant = !1
        }
        static Create(t, a, p) {
            const G = a[0];
            return C3.New([_, u, i, d, f, c, g, _, d, d, S, y, i, m, u, h, e, l, n][G], t, G, p, a)
        }
        _PostInit() {}
        SetVariesPerInstance() {
            this._variesPerInstance = !0
        }
        _MaybeVaryFor(e) {
            !this._variesPerInstance && e && (e.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0))
        }
        VariesPerInstance() {
            return this._variesPerInstance
        }
        GetIndex() {
            return this._index
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        GetEventBlock() {
            return this._owner.GetEventBlock()
        }
        IsConstant() {
            return this._isConstant
        }
    }
    ;
    class _ extends C3.Parameter {
        constructor(a, n, r, i) {
            super(a, n, r),
            this._solIndex = 0;
            const e = i[1];
            this._expressionNumber = e[0],
            this._numberedNodes = [],
            this._expressionFunc = null;
            for (let t = 1, l = e.length; t < l; ++t)
                this._numberedNodes.push(C3.ExpNode.CreateNode(this, e[t]));
            this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = t(this._expressionNumber),
            this._isConstant = !0)
        }
        _GetNode(e) {
            if (0 > e || e >= this._numberedNodes.length)
                throw new RangeError('invalid numbered node');
            return this._numberedNodes[e]
        }
        _PostInit() {
            for (const e of this._numberedNodes)
                e._PostInit();
            const e = t(this._expressionNumber);
            this._expressionFunc = this._numberedNodes.length ? e(this) : e
        }
        GetSolIndex() {
            return this._solIndex
        }
        GetExpression(e) {
            return this._solIndex = e,
            this._expressionFunc()
        }
    }
    class u extends _ {
        constructor(e, t, a, n) {
            super(e, t, a, n),
            this.Get = this.GetStringExpression,
            14 === t && (this.GetEventBlock().SetAllSolModifiers(),
            this._owner instanceof C3.Action && this.GetEventBlock().SetSolWriterAfterCnds())
        }
        GetStringExpression(e) {
            this._solIndex = e;
            const t = this._expressionFunc();
            return 'string' == typeof t ? t : ''
        }
        _GetFastTriggerValue() {
            return t(this._expressionNumber)()
        }
    }
    class c extends _ {
        constructor(e, t, a, n) {
            super(e, t, a, n),
            this.Get = this.GetLayer,
            this._isConstant = !1
        }
        GetLayer(e) {
            this._solIndex = e;
            const t = this._expressionFunc()
              , a = this.GetRuntime().GetCurrentLayout();
            return a.GetLayer(t)
        }
    }
    class d extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._combo = n[1],
            this.Get = this.GetCombo,
            this._isConstant = !0
        }
        GetCombo() {
            return this._combo
        }
    }
    class e extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._bool = n[1],
            this.Get = this.GetBoolean,
            this._isConstant = !0
        }
        GetBoolean() {
            return this._bool
        }
    }
    class f extends C3.Parameter {
        constructor(t, a, n, r) {
            super(t, a, n),
            this._objectClass = this.GetRuntime().GetObjectClassByIndex(r[1]),
            this.Get = this.GetObjectClass;
            const i = this.GetEventBlock();
            i._AddSolModifier(this._objectClass),
            this._owner instanceof C3.Action ? i.SetSolWriterAfterCnds() : i.GetParent() && i.GetParent().SetSolWriterAfterCnds(),
            this._isConstant = !0
        }
        GetObjectClass() {
            return this._objectClass
        }
    }
    class g extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(n[1]),
            this.Get = this.GetLayout,
            this._isConstant = !0
        }
        GetLayout() {
            return this._layout
        }
    }
    class h extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(n[1]),
            this.Get = this.GetTimeline,
            this._isConstant = !0
        }
        GetTimeline() {
            return this._timeline
        }
    }
    class i extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._fileInfo = n[1],
            this.Get = this.GetFile,
            this._isConstant = !0
        }
        GetFile() {
            return this._fileInfo
        }
    }
    class S extends C3.Parameter {
        constructor(t, a, n, r) {
            super(t, a, n),
            this._instVarIndex = r[1];
            const i = this._owner.GetObjectClass();
            i && i.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable,
            this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable,
            this._isConstant = !0)
        }
        GetInstanceVariable() {
            return this._instVarIndex
        }
        GetFamilyInstanceVariable(t) {
            t = t || 0;
            const n = this._owner.GetObjectClass()
              , r = n.GetCurrentSol()
              , i = r.GetInstances();
            let l = null;
            if (i.length)
                l = i[t % i.length].GetObjectClass();
            else if (r.HasAnyElseInstances()) {
                const e = r.GetElseInstances();
                l = e[t % e.length].GetObjectClass()
            } else if (0 < n.GetInstanceCount()) {
                const e = n.GetInstances();
                l = e[t % e.length].GetObjectClass()
            } else
                return 0;
            return this._instVarIndex + l.GetFamilyInstanceVariableOffset(n.GetFamilyIndex())
        }
    }
    class y extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._eventVarName = n[1],
            this._eventVar = null,
            this.Get = this.GetEventVariable,
            this._isConstant = !0
        }
        _PostInit() {
            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableByName(this._eventVarName, this.GetEventBlock()),
            this._eventVarName = null
        }
        GetEventVariable() {
            return this._eventVar
        }
    }
    class l extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._functionBlockName = n[1],
            this._functionBlock = null,
            this.Get = this.GetFunction,
            this._isConstant = !0
        }
        _PostInit() {
            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName),
            this._functionBlockName = null
        }
        GetFunction() {
            return this._functionBlock
        }
    }
    class m extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._subParams = [],
            this._variadicRet = [],
            this._isConstant = !0;
            for (let r = 1, i = n.length; r < i; ++r) {
                const e = C3.Parameter.Create(this._owner, n[r], 0);
                this._subParams.push(e),
                this._variadicRet.push(0),
                e.IsConstant() || (this._isConstant = !1)
            }
            this.Get = this.GetVariadic
        }
        _PostInit() {
            for (const e of this._subParams)
                e._PostInit()
        }
        GetVariadic() {
            const e = this._subParams
              , t = this._variadicRet;
            for (let a = 0, n = e.length; a < n; ++a)
                t[a] = e[a].Get(0);
            return t
        }
    }
    class n extends C3.Parameter {
        constructor(e, t, a, n) {
            super(e, t, a),
            this._easeIndex = n[1],
            this.Get = this.GetEase,
            this._isConstant = !0
        }
        GetEase() {
            return this._easeIndex
        }
    }
}
{
    function e(e, t) {
        for (let a = 0, n = e.length; a < n; ++a)
            t[a] = e[a].Get(0)
    }
    const t = []
      , n = function() {};
    C3.Condition = class extends C3.DefendedBase {
        constructor(r, i, a) {
            if (super(),
            this._eventBlock = r,
            this._runtime = r.GetRuntime(),
            this._index = a,
            this._func = this._runtime.GetObjectReference(i[1]),
            this._isTrigger = 0 < i[3],
            this._isFastTrigger = 2 === i[3],
            this._isLooping = !!i[4],
            this._isInverted = !!i[5],
            this._isStatic = !!i[6],
            this._sid = i[7],
            this._isInOrBlock = this._eventBlock.IsOrBlock(),
            this._objectClass = null,
            this._behaviorType = null,
            this._behaviorIndex = -1,
            this._systemPlugin = null,
            this.Run = n,
            this.DebugRun = n,
            this._parameters = [],
            this._results = [],
            this._anyParamVariesPerInstance = !1,
            this._savedData = null,
            this._unsavedData = null,
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: i[8][0],
                canDebug: i[8][1]
            } : null,
            -1 === i[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(i[0]),
            i[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(i[2]),
            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(i[2])),
            this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()),
            10 === i.length) {
                let e = i[9];
                for (let t of e)
                    this._parameters.push(C3.Parameter.Create(this, t, this._parameters.length)),
                    this._results.push(0)
            }
            0 === this._parameters.length && (this._parameters = t,
            this._results = t),
            this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
        }
        static Create(e, t, a) {
            return C3.New(C3.Condition, e, t, a)
        }
        _PostInit() {
            for (const e of this._parameters)
                e._PostInit(),
                e.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            this._isFastTrigger ? (this.Run = this._RunFastTrigger,
            this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(),
            this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
            this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic,
            this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject,
            this.DebugRun = this._DebugRunObject)
        }
        _SetSystemRunMethod() {
            const e = this._systemPlugin
              , t = this._systemPlugin;
            this._SetRunMethodForBoundFunc(e, t, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const e = this._objectClass.GetPlugin()
              , t = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(e, t, this._RunSingleGlobal)
        }
        _SetRunMethodForBoundFunc(t, a, n) {
            const r = this._func
              , i = this._isInverted
              , e = this._parameters;
            if (0 === e.length) {
                const e = t._GetBoundACEMethod(r, a);
                this.Run = i ? function() {
                    return C3.xor(e(), i)
                }
                : e
            } else if (1 === e.length) {
                const n = e[0];
                if (!i && n.IsConstant())
                    this.Run = t._GetBoundACEMethod_1param(r, a, n.Get(0));
                else {
                    const e = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return C3.xor(e(n.Get(0)), i)
                    }
                }
            } else if (2 === e.length) {
                const n = e[0]
                  , l = e[1];
                if (!i && n.IsConstant() && l.IsConstant())
                    this.Run = t._GetBoundACEMethod_2params(r, a, n.Get(0), l.Get(0));
                else {
                    const e = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return C3.xor(e(n.Get(0), l.Get(0)), i)
                    }
                }
            } else if (3 === e.length) {
                const n = e[0]
                  , l = e[1]
                  , _ = e[2];
                if (!i && n.IsConstant() && l.IsConstant() && _.IsConstant())
                    this.Run = t._GetBoundACEMethod_3params(r, a, n.Get(0), l.Get(0), _.Get(0));
                else {
                    const e = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return C3.xor(e(n.Get(0), l.Get(0), _.Get(0)), i)
                    }
                }
            } else
                this.Run = n
        }
        GetSID() {
            return this._sid
        }
        _GetFunc() {
            return this._func
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this.GetIndex()
        }
        IsTrigger() {
            return this._isTrigger
        }
        IsFastTrigger() {
            return this._isFastTrigger
        }
        IsInverted() {
            return this._isInverted
        }
        IsLooping() {
            return this._isLooping
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(e) {
            this._debugData.isBreakpoint = !!e,
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            return this._savedData || (this._savedData = new Map),
            this._savedData
        }
        GetUnsavedDataMap() {
            return this._unsavedData || (this._unsavedData = new Map),
            this._unsavedData
        }
        _RunSystem() {
            const t = this._results;
            return e(this._parameters, t),
            C3.xor(this._func.apply(this._systemPlugin, t), this._isInverted)
        }
        *_DebugRunSystem() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                let a = this._func.apply(this._systemPlugin, t);
                return C3.IsIterator(a) && (a = yield*a),
                C3.xor(a, this._isInverted)
            }
            return this.Run()
        }
        _RunSingleGlobal() {
            const t = this._results;
            e(this._parameters, t);
            const a = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            return C3.xor(this._func.apply(a, t), this._isInverted)
        }
        *_DebugRunSingleGlobal() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                const a = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
                let n = this._func.apply(a, t);
                return C3.IsIterator(n) && (n = yield*n),
                C3.xor(n, this._isInverted)
            }
            return this.Run()
        }
        _RunFastTrigger() {
            return !0
        }
        *_DebugRunFastTrigger() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            !0
        }
        _RunStatic() {
            const t = this._results;
            e(this._parameters, t);
            const a = this._func.apply(this._behaviorType || this._objectClass, t);
            return this._objectClass.ApplySolToContainer(),
            a
        }
        *_DebugRunStatic() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                let a = this._func.apply(this._behaviorType || this._objectClass, t);
                return C3.IsIterator(a) && (a = yield*a),
                this._objectClass.ApplySolToContainer(),
                a
            }
            return this.Run()
        }
        _RunObject() {
            const e = this._parameters
              , t = this._results
              , a = this._objectClass.GetCurrentSol();
            for (let a = 0, n = e.length; a < n; ++a) {
                const n = e[a];
                n.VariesPerInstance() || (t[a] = n.Get(0))
            }
            return a.IsSelectAll() ? this._RunObject_FirstFilter(a) : this._RunObject_NextFilter(a)
        }
        *_DebugRunObject() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._RunObject()
        }
        _EvaluateVaryingParameters(t) {
            const a = this._parameters
              , n = this._results;
            for (let r = 0, i = a.length; r < i; ++r) {
                const i = a[r];
                i.VariesPerInstance() && (n[r] = i.Get(t))
            }
        }
        _RunObject_FirstFilter(t) {
            const a = this._objectClass
              , n = a.IsFamily()
              , r = a.GetFamilyIndex()
              , _ = this._behaviorIndex
              , e = a.GetInstances()
              , d = this._anyParamVariesPerInstance
              , u = this._results
              , c = this._func
              , g = this._isInverted
              , p = this._isInOrBlock && !this._isTrigger;
            t.ClearArrays();
            for (let a = 0, l = e.length; a < l; ++a) {
                const l = e[a];
                d && this._EvaluateVaryingParameters(a);
                let i;
                if (0 <= _) {
                    const e = n ? l.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                    i = c.apply(l.GetBehaviorInstances()[_ + e].GetSdkInstance(), u)
                } else
                    i = c.apply(l.GetSdkInstance(), u);
                C3.xor(i, g) ? t._PushInstance(l) : p && t._PushElseInstance(l)
            }
            return a.FinishCondition(!0),
            t._SetSelectAll(!1),
            a.ApplySolToContainer(),
            t.HasAnyInstances()
        }
        _RunObject_NextFilter(t) {
            const a = this._objectClass
              , _ = a.IsFamily()
              , u = a.GetFamilyIndex()
              , d = a.IsInContainer()
              , e = this._behaviorIndex
              , c = this._anyParamVariesPerInstance
              , g = this._results
              , h = this._func
              , f = this._isInverted
              , l = this._isInOrBlock && !this._isTrigger
              , m = t._GetOwnInstances()
              , n = t._GetOwnElseInstances()
              , S = l && !this._eventBlock.IsFirstConditionOfType(this)
              , p = S ? n : m;
            let y = 0
              , G = !1;
            for (let r = 0, a = p.length; r < a; ++r) {
                const t = p[r];
                c && this._EvaluateVaryingParameters(r);
                let a;
                if (0 <= e) {
                    const n = _ ? t.GetObjectClass().GetFamilyBehaviorOffset(u) : 0;
                    a = h.apply(t.GetBehaviorInstances()[e + n].GetSdkInstance(), g)
                } else
                    a = h.apply(t.GetSdkInstance(), g);
                C3.xor(a, f) ? (G = !0,
                S ? (m.push(t),
                d && t._PushSiblingsToSolInstances()) : (p[y] = t,
                d && t._SetSiblingsToSolInstancesIndex(y),
                ++y)) : S ? (p[y] = t,
                d && t._SetSiblingsToSolElseInstancesIndex(y),
                ++y) : l && (n.push(t),
                d && t._PushSiblingsToSolElseInstances())
            }
            C3.truncateArray(p, y),
            d && a._TruncateContainerSols(S, y);
            const b = G;
            return S && !G && (G = this._OrBlockCheckInstances(m)),
            a.FinishCondition(b || l),
            l ? G : t.HasAnyInstances()
        }
        _OrBlockCheckInstances(t) {
            const a = this._objectClass
              , n = a.IsFamily()
              , r = a.GetFamilyIndex()
              , l = this._anyParamVariesPerInstance
              , e = this._behaviorIndex
              , _ = this._results
              , d = this._func
              , u = this._isInverted;
            for (let a = 0, c = t.length; a < c; ++a) {
                const c = t[a];
                l && this._EvaluateVaryingParameters(a);
                let i;
                if (0 <= e) {
                    const t = n ? c.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                    i = d.apply(c.GetBehaviorInstances()[e + t].GetSdkInstance(), _)
                } else
                    i = d.apply(c.GetSdkInstance(), _);
                if (C3.xor(i, u))
                    return !0
            }
            return !1
        }
        ReevaluateParameter(e, t) {
            return this._parameters[e].Get(t)
        }
        GetFastTriggerValue() {
            const e = this._parameters;
            if (!e.length)
                throw new Error('no parameters');
            return e[0]._GetFastTriggerValue()
        }
        _SaveToJson() {
            if (!this._savedData || !this._savedData.size)
                return null;
            const e = {};
            for (const [t,a] of this._savedData.entries()) {
                let n = a;
                'collmemory' === t && (n = [...a.entries()].map(e=>[e[0].GetUID(), e[1].GetUID(), e[2]])),
                e[t] = n
            }
            return {
                ex: e
            }
        }
        _LoadFromJson(e) {
            const t = this._runtime
              , n = e.ex;
            if (n) {
                const r = this.GetSavedDataMap();
                r.clear();
                for (const [a,i] of Object.entries(n)) {
                    let e = i;
                    'collmemory' === a && (e = C3.New(C3.PairMap, i.map(e=>[t.GetInstanceByUID(e[0]), t.GetInstanceByUID(e[1]), e[2]]).filter(e=>e[0] && e[1]))),
                    r.set(a, e)
                }
            } else
                this._savedData && (this._savedData.clear(),
                this._savedData = null)
        }
    }
}
{
    function e(e, t) {
        for (let a = 0, n = e.length; a < n; ++a)
            t[a] = e[a].Get(0)
    }
    const t = []
      , n = function() {}
      , r = function*() {};
    C3.Action = class extends C3.DefendedBase {
        constructor(r, i, a) {
            super(),
            this._eventBlock = r;
            const e = r.GetRuntime();
            this._runtime = e,
            this._index = a,
            this._sid = 4 <= i.length ? i[3] : -1,
            this._actionReturnType = 5 <= i.length ? i[4] : 0,
            this._func = null,
            this._objectClass = null,
            this._behaviorType = null,
            this._behaviorIndex = -1,
            this._systemPlugin = null,
            this._callFunctionName = '',
            this._callEventBlock = null,
            this._combinedSolModifiers = null,
            this.Run = n,
            this.DebugRun = n,
            this._parameters = [],
            this._results = [],
            this._anyParamVariesPerInstance = !1,
            this._savedData = null,
            this._unsavedData = null;
            const l = -3 === i[0]
              , _ = l ? i[2] : i[5];
            if (this._debugData = e.IsDebug() || l ? {
                isBreakpoint: _[0],
                canDebug: _[1],
                index: _[2]
            } : null,
            -1 === i[0])
                this._systemPlugin = e.GetSystemPlugin(),
                this._func = e.GetObjectReference(i[1]);
            else if (-2 === i[0])
                this._callFunctionName = i[1];
            else if (l) {
                const t = e.GetObjectReference(i[1]);
                this._func = t,
                this.Run = this.RunUserScript,
                this.DebugRun = this.DebugRunUserScript,
                this._actionReturnType = 1
            } else
                this._func = e.GetObjectReference(i[1]),
                this._objectClass = e.GetObjectClassByIndex(i[0]),
                i[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(i[2]),
                this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(i[2]));
            if (7 === i.length) {
                const e = i[6];
                for (const t of e)
                    this._parameters.push(C3.Parameter.Create(this, t, this._parameters.length)),
                    this._results.push(0)
            }
            0 === this._parameters.length && (this._parameters = t,
            this._results = t),
            this._eventBlock.GetEventSheetManager()._RegisterAction(this)
        }
        static Create(e, t, a) {
            return C3.New(C3.Action, e, t, a)
        }
        _PostInit() {
            for (const e of this._parameters)
                e._PostInit(),
                e.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            if (this._systemPlugin)
                this._SetSystemRunMethod(),
                this.DebugRun = this._DebugRunSystem;
            else if (this._callFunctionName)
                this._SetCallFunctionRunMethod(),
                this._callFunctionName = '';
            else if (this.Run === this.RunUserScript) {
                const e = this._func
                  , t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
                this._func = e.bind(null, this._runtime.GetIRuntime(), t)
            } else
                this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async,
                this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior,
                this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(),
                this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async,
                this.DebugRun = this._DebugRunObject_Async) : this._parameters.length ? this._parameters.every(e=>e.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
                this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary,
                this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(e=>e.IsConstant()) ? (e(this._parameters, this._results),
                this.Run = this._RunObject_ParamsConst,
                this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary,
                this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst,
                this.DebugRun = this._DebugRunObject_ParamsConst)
        }
        _SetSystemRunMethod() {
            const e = this._systemPlugin
              , t = this._systemPlugin;
            this._SetRunMethodForBoundFunc(e, t, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const e = this._objectClass.GetPlugin()
              , t = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(e, t, this._RunSingleGlobal)
        }
        _SetCallFunctionRunMethod() {
            const e = this._eventBlock.GetEventSheetManager()
              , t = e.GetFunctionBlockByName(this._callFunctionName);
            t.IsEnabled() ? (this._callEventBlock = t.GetEventBlock(),
            this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])],
            this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers),
            this.Run = C3.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters),
            this.DebugRun = this._DebugRunCallFunction) : (this.Run = n,
            this.DebugRun = r)
        }
        _SetRunMethodForBoundFunc(t, a, n) {
            const r = this._func
              , i = this._parameters;
            if (0 === i.length)
                this.Run = t._GetBoundACEMethod(r, a);
            else if (1 === i.length) {
                const n = i[0];
                if (n.IsConstant())
                    this.Run = t._GetBoundACEMethod_1param(r, a, n.Get(0));
                else {
                    const i = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return i(n.Get(0))
                    }
                }
            } else if (2 === i.length) {
                const n = i[0]
                  , l = i[1];
                if (n.IsConstant() && l.IsConstant())
                    this.Run = t._GetBoundACEMethod_2params(r, a, n.Get(0), l.Get(0));
                else {
                    const i = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return i(n.Get(0), l.Get(0))
                    }
                }
            } else if (3 === i.length) {
                const n = i[0]
                  , l = i[1]
                  , _ = i[2];
                if (n.IsConstant() && l.IsConstant() && _.IsConstant())
                    this.Run = t._GetBoundACEMethod_3params(r, a, n.Get(0), l.Get(0), _.Get(0));
                else {
                    const i = t._GetBoundACEMethod(r, a);
                    this.Run = function() {
                        return i(n.Get(0), l.Get(0), _.Get(0))
                    }
                }
            } else
                this.Run = n
        }
        GetSID() {
            return this._sid
        }
        IsAsync() {
            return 1 === this._actionReturnType
        }
        CanBailOut() {
            return 2 === this._actionReturnType
        }
        HasReturnType() {
            return 0 !== this._actionReturnType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this._debugData.index
        }
        GetCombinedSolModifiers() {
            return this._combinedSolModifiers
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(e) {
            this._debugData.isBreakpoint = !!e,
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            return this._savedData || (this._savedData = new Map),
            this._savedData
        }
        GetUnsavedDataMap() {
            return this._unsavedData || (this._unsavedData = new Map),
            this._unsavedData
        }
        _RunSystem() {
            const t = this._results;
            return e(this._parameters, t),
            this._func.apply(this._systemPlugin, t)
        }
        *_DebugRunSystem() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                const a = yield*this._func.apply(this._systemPlugin, t);
                return a
            }
            return this.Run()
        }
        *_DebugRunCallFunction() {
            (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const e = yield*this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters);
            return e
        }
        _RunSingleGlobal() {
            const t = this._results;
            return e(this._parameters, t),
            this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t)
        }
        *_DebugRunSingleGlobal() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                const a = yield*this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);
                return a
            }
            return this.Run()
        }
        _RunObject_ParamsConst() {
            const e = this._results
              , t = this._objectClass.GetCurrentSol().GetInstances();
            for (let a = 0, n = t.length; a < n; ++a)
                this._func.apply(t[a].GetSdkInstance(), e)
        }
        *_DebugRunObject_ParamsConst() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const e = this._results
                  , t = this._objectClass.GetCurrentSol().GetInstances();
                for (let a = 0, n = t.length; a < n; ++a)
                    yield*this._func.apply(t[a].GetSdkInstance(), e)
            } else
                this._RunObject_ParamsConst()
        }
        _RunObject_ParamsDontVary() {
            const t = this._results;
            e(this._parameters, t);
            const n = this._objectClass.GetCurrentSol().GetInstances();
            for (let e = 0, a = n.length; e < a; ++e)
                this._func.apply(n[e].GetSdkInstance(), t)
        }
        *_DebugRunObject_ParamsDontVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._results;
                e(this._parameters, t);
                const n = this._objectClass.GetCurrentSol().GetInstances();
                for (let e = 0, a = n.length; e < a; ++e)
                    yield*this._func.apply(n[e].GetSdkInstance(), t)
            } else
                this._RunObject_ParamsDontVary()
        }
        _RunObject_AllParamsVary() {
            const t = this._parameters
              , a = this._results
              , n = this._func
              , r = this._objectClass.GetCurrentSol().GetInstances();
            for (let i = 0, e = r.length; i < e; ++i) {
                const e = r[i];
                for (let e = 0, n = t.length; e < n; ++e)
                    a[e] = t[e].Get(i);
                n.apply(e.GetSdkInstance(), a)
            }
        }
        *_DebugRunObject_AllParamsVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._parameters
                  , a = this._results
                  , n = this._func
                  , r = this._objectClass.GetCurrentSol().GetInstances();
                for (let i = 0, e = r.length; i < e; ++i) {
                    const e = r[i];
                    for (let e = 0, n = t.length; e < n; ++e)
                        a[e] = t[e].Get(i);
                    yield*n.apply(e.GetSdkInstance(), a)
                }
            } else
                this._RunObject_AllParamsVary()
        }
        _RunObject_SomeParamsVary() {
            const t = this._parameters
              , a = this._results
              , n = this._func
              , r = this._objectClass.GetCurrentSol().GetInstances();
            for (let e = 0, n = t.length; e < n; ++e) {
                const n = t[e];
                n.VariesPerInstance() || (a[e] = n.Get(0))
            }
            for (let i = 0, e = r.length; i < e; ++i) {
                const e = r[i];
                for (let e = 0, n = t.length; e < n; ++e) {
                    const n = t[e];
                    n.VariesPerInstance() && (a[e] = n.Get(i))
                }
                n.apply(e.GetSdkInstance(), a)
            }
        }
        *_DebugRunObject_SomeParamsVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._parameters
                  , a = this._results
                  , n = this._func
                  , r = this._objectClass.GetCurrentSol().GetInstances();
                for (let e = 0, n = t.length; e < n; ++e) {
                    const n = t[e];
                    n.VariesPerInstance() || (a[e] = n.Get(0))
                }
                for (let i = 0, e = r.length; i < e; ++i) {
                    const e = r[i];
                    for (let e = 0, n = t.length; e < n; ++e) {
                        const n = t[e];
                        n.VariesPerInstance() && (a[e] = n.Get(i))
                    }
                    yield*n.apply(e.GetSdkInstance(), a)
                }
            } else
                this._RunObject_SomeParamsVary()
        }
        _RunBehavior() {
            const t = this._objectClass
              , n = t.IsFamily()
              , r = t.GetFamilyIndex()
              , i = this._parameters
              , l = this._anyParamVariesPerInstance
              , e = this._results
              , _ = this._func
              , d = this._behaviorIndex
              , u = t.GetCurrentSol().GetInstances();
            for (let t = 0, a = i.length; t < a; ++t) {
                const a = i[t];
                a.VariesPerInstance() || (e[t] = a.Get(0))
            }
            for (let t = 0, a = u.length; t < a; ++t) {
                const a = u[t];
                if (l)
                    for (let a = 0, n = i.length; a < n; ++a) {
                        const n = i[a];
                        n.VariesPerInstance() && (e[a] = n.Get(t))
                    }
                const c = n ? a.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                _.apply(a.GetBehaviorInstances()[d + c].GetSdkInstance(), e)
            }
        }
        *_DebugRunBehavior() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._objectClass
                  , n = t.IsFamily()
                  , r = t.GetFamilyIndex()
                  , i = this._parameters
                  , l = this._anyParamVariesPerInstance
                  , e = this._results
                  , _ = this._func
                  , d = this._behaviorIndex
                  , u = t.GetCurrentSol().GetInstances();
                for (let t = 0, a = i.length; t < a; ++t) {
                    const a = i[t];
                    a.VariesPerInstance() || (e[t] = a.Get(0))
                }
                for (let t = 0, a = u.length; t < a; ++t) {
                    const a = u[t];
                    if (l)
                        for (let a = 0, n = i.length; a < n; ++a) {
                            const n = i[a];
                            n.VariesPerInstance() && (e[a] = n.Get(t))
                        }
                    const c = n ? a.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                    yield*_.apply(a.GetBehaviorInstances()[d + c].GetSdkInstance(), e)
                }
            } else
                this._RunBehavior()
        }
        _RunObject_Async() {
            const t = this._parameters
              , a = this._results
              , n = this._func
              , r = this._objectClass.GetCurrentSol().GetInstances()
              , i = [];
            for (let e = 0, l = r.length; e < l; ++e) {
                const l = r[e];
                for (let n = 0, r = t.length; n < r; ++n)
                    a[n] = t[n].Get(e);
                i.push(n.apply(l.GetSdkInstance(), a))
            }
            return Promise.all(i)
        }
        *_DebugRunObject_Async() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._parameters
                  , a = this._results
                  , n = this._func
                  , r = this._objectClass.GetCurrentSol().GetInstances()
                  , i = [];
                for (let e = 0, l = r.length; e < l; ++e) {
                    const l = r[e];
                    for (let n = 0, r = t.length; n < r; ++n)
                        a[n] = t[n].Get(e);
                    i.push((yield*n.apply(l.GetSdkInstance(), a)))
                }
                return Promise.all(i)
            }
            return this._RunObject_Async()
        }
        _RunBehavior_Async() {
            const t = this._objectClass
              , n = t.IsFamily()
              , r = t.GetFamilyIndex()
              , i = this._parameters
              , l = this._results
              , e = this._func
              , _ = this._behaviorIndex
              , d = t.GetCurrentSol().GetInstances()
              , u = [];
            for (let t = 0, a = d.length; t < a; ++t) {
                const a = d[t];
                for (let e = 0, a = i.length; e < a; ++e)
                    l[e] = i[e].Get(t);
                const c = n ? a.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                u.push(e.apply(a.GetBehaviorInstances()[_ + c].GetSdkInstance(), l))
            }
            return Promise.all(u)
        }
        *_DebugRunBehavior_Async() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this._DebugReturnsGenerator()) {
                const t = this._objectClass
                  , n = t.IsFamily()
                  , r = t.GetFamilyIndex()
                  , i = this._parameters
                  , l = this._results
                  , e = this._func
                  , _ = this._behaviorIndex
                  , d = t.GetCurrentSol().GetInstances()
                  , u = [];
                for (let t = 0, a = d.length; t < a; ++t) {
                    const a = d[t];
                    for (let e = 0, a = i.length; e < a; ++e)
                        l[e] = i[e].Get(t);
                    const c = n ? a.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                    u.push((yield*e.apply(a.GetBehaviorInstances()[_ + c].GetSdkInstance(), l)))
                }
                return Promise.all(u)
            }
            return this._RunBehavior_Async()
        }
        async RunUserScript() {
            try {
                await this._func()
            } catch (e) {
                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, 'font-size: 1.2em; font-weight: bold;', e),
                self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                C3.EventScript.HadUserScriptException() || (console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, 'font-weight: bold; text-decoration: underline', '', 'font-weight: bold'),
                C3.EventScript.SetHadUserScriptException())
            }
        }
        *DebugRunUserScript() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this),
            this.RunUserScript()
        }
        _SaveToJson() {
            return this._savedData && this._savedData.size ? {
                ex: C3.ToSuperJSON(this._savedData)
            } : null
        }
        _LoadFromJson(e) {
            this._savedData && (this._savedData.clear(),
            this._savedData = null);
            const t = e.ex;
            t && (this._savedData = C3.FromSuperJSON(t))
        }
    }
}
{
    function ee(e, t) {
        return C3.compare(this.GetWorldInfo().GetX(), e, t)
    }
    function a(e, t) {
        return C3.compare(this.GetWorldInfo().GetY(), e, t)
    }
    function b() {
        const e = this.GetWorldInfo();
        return e.IsInViewport(e.GetLayer().GetViewport())
    }
    function c() {
        const e = this.GetWorldInfo()
          , t = e.GetLayout()
          , a = e.GetBoundingBox();
        return 0 > a.getRight() || 0 > a.getBottom() || a.getLeft() > t.GetWidth() || a.getTop() > t.GetHeight()
    }
    function d(t, a, n) {
        const r = this.GetCurrentSol()
          , l = r.GetInstances();
        if (!l.length)
            return !1;
        let e = l[0]
          , _ = e.GetWorldInfo()
          , u = e
          , c = C3.distanceSquared(_.GetX(), _.GetY(), a, n);
        for (let r = 1, d = l.length; r < d; ++r) {
            e = l[r],
            _ = e.GetWorldInfo();
            const d = C3.distanceSquared(_.GetX(), _.GetY(), a, n);
            (0 === t && d < c || 1 === t && d > c) && (c = d,
            u = e)
        }
        return r.PickOne(u),
        !0
    }
    function e(e) {
        const t = this.GetWorldInfo();
        t.GetX() === e || (t.SetX(e),
        t.SetBboxChanged())
    }
    function f(e) {
        const t = this.GetWorldInfo();
        t.GetY() === e || (t.SetY(e),
        t.SetBboxChanged())
    }
    function g(e, t) {
        const a = this.GetWorldInfo();
        a.EqualsXY(e, t) || (a.SetXY(e, t),
        a.SetBboxChanged())
    }
    function h(e, t) {
        if (e) {
            const n = e.GetPairedInstance(this._inst);
            if (n) {
                const [r,a] = n.GetImagePoint(t)
                  , i = this.GetWorldInfo();
                i.GetX() === r && i.GetY() === a || (i.SetXY(r, a),
                i.SetBboxChanged())
            }
        }
    }
    function i(e) {
        if (0 !== e) {
            const t = this.GetWorldInfo();
            t.OffsetXY(t.GetCosAngle() * e, t.GetSinAngle() * e),
            t.SetBboxChanged()
        }
    }
    function j(e, t) {
        if (0 !== t) {
            const a = this.GetWorldInfo();
            e = C3.toRadians(e),
            a.OffsetXY(Math.cos(e) * t, Math.sin(e) * t),
            a.SetBboxChanged()
        }
    }
    function k() {
        return this.GetWorldInfo().GetX()
    }
    function l() {
        return this.GetWorldInfo().GetY()
    }
    function m() {
        return this._runtime.GetDt(this._inst)
    }
    function n(e, t) {
        return C3.compare(this.GetWorldInfo().GetWidth(), e, t)
    }
    function te(e, t) {
        return C3.compare(this.GetWorldInfo().GetHeight(), e, t)
    }
    function p(e) {
        const t = this.GetWorldInfo();
        t.GetWidth() === e || (t.SetWidth(e),
        t.SetBboxChanged())
    }
    function q(e) {
        const t = this.GetWorldInfo();
        t.GetHeight() === e || (t.SetHeight(e),
        t.SetBboxChanged())
    }
    function r(e, t) {
        const a = this.GetWorldInfo();
        a.GetWidth() === e && a.GetHeight() === t || (a.SetSize(e, t),
        a.SetBboxChanged())
    }
    function ae() {
        return this.GetWorldInfo().GetWidth()
    }
    function t() {
        return this.GetWorldInfo().GetHeight()
    }
    function u() {
        return this.GetWorldInfo().GetBoundingBox().getLeft()
    }
    function v() {
        return this.GetWorldInfo().GetBoundingBox().getTop()
    }
    function w() {
        return this.GetWorldInfo().GetBoundingBox().getRight()
    }
    function x() {
        return this.GetWorldInfo().GetBoundingBox().getBottom()
    }
    function y(e, t) {
        return C3.angleDiff(this.GetWorldInfo().GetAngle(), C3.toRadians(t)) <= C3.toRadians(e)
    }
    function z(e) {
        return C3.angleClockwise(this.GetWorldInfo().GetAngle(), C3.toRadians(e))
    }
    function A(t, n) {
        const a = C3.toRadians(t)
          , r = C3.toRadians(n)
          , i = this.GetWorldInfo().GetAngle()
          , e = !C3.angleClockwise(r, a);
        return e ? C3.angleClockwise(i, a) || !C3.angleClockwise(i, r) : C3.angleClockwise(i, a) && !C3.angleClockwise(i, r)
    }
    function B(e) {
        const t = this.GetWorldInfo()
          , a = C3.clampAngle(C3.toRadians(e));
        isNaN(a) || t.GetAngle() === a || (t.SetAngle(a),
        t.SetBboxChanged())
    }
    function C(e) {
        if (!(isNaN(e) || 0 === e)) {
            const t = this.GetWorldInfo();
            t.SetAngle(t.GetAngle() + C3.toRadians(e)),
            t.SetBboxChanged()
        }
    }
    function D(e) {
        if (!(isNaN(e) || 0 === e)) {
            const t = this.GetWorldInfo();
            t.SetAngle(t.GetAngle() - C3.toRadians(e)),
            t.SetBboxChanged()
        }
    }
    function E(t, n) {
        const r = this.GetWorldInfo()
          , i = r.GetAngle()
          , e = C3.angleRotate(i, C3.toRadians(n), C3.toRadians(t));
        isNaN(e) || i === e || (r.SetAngle(e),
        r.SetBboxChanged())
    }
    function F(t, n, r) {
        const l = this.GetWorldInfo()
          , e = l.GetAngle()
          , _ = n - l.GetX()
          , a = r - l.GetY()
          , d = Math.atan2(a, _)
          , u = C3.angleRotate(e, d, C3.toRadians(t));
        isNaN(u) || e === u || (l.SetAngle(u),
        l.SetBboxChanged())
    }
    function G(t, n) {
        const r = this.GetWorldInfo()
          , i = r.GetAngle()
          , e = t - r.GetX()
          , a = n - r.GetY()
          , l = Math.atan2(a, e);
        isNaN(l) || i === l || (r.SetAngle(l),
        r.SetBboxChanged())
    }
    function H() {
        return C3.toDegrees(this.GetWorldInfo().GetAngle())
    }
    function I(e, t) {
        return C3.compare(C3.round6dp(100 * this.GetWorldInfo().GetOpacity()), e, t)
    }
    function J() {
        return this.GetWorldInfo().IsVisible()
    }
    function K(e) {
        const t = this.GetWorldInfo();
        e = 2 === e ? !t.IsVisible() : 0 != e,
        t.IsVisible() === e || (t.SetVisible(e),
        this._runtime.UpdateRender())
    }
    function L(e) {
        const t = C3.clamp(e / 100, 0, 1)
          , a = this.GetWorldInfo();
        a.GetOpacity() === t || (a.SetOpacity(t),
        this._runtime.UpdateRender())
    }
    function M(e) {
        xe.setFromRgbValue(e);
        const t = this.GetWorldInfo();
        t.GetUnpremultipliedColor().equalsIgnoringAlpha(xe) || (t.SetUnpremultipliedColor(xe),
        this._runtime.UpdateRender())
    }
    function N() {
        const e = this.GetWorldInfo().GetUnpremultipliedColor();
        return C3.PackRGBAEx(e.getR(), e.getG(), e.getB(), e.getA())
    }
    function O() {
        return C3.round6dp(100 * this.GetWorldInfo().GetOpacity())
    }
    function P(e) {
        return !!e && this.GetWorldInfo().GetLayer() === e
    }
    function Q(t) {
        const a = this.GetCurrentSol()
          , n = a.GetInstances();
        if (!n.length)
            return !1;
        let r = n[0]
          , l = r;
        for (let e = 1, a = n.length; e < a; ++e) {
            const a = n[e]
              , r = a.GetWorldInfo()
              , _ = l.GetWorldInfo()
              , d = r.GetLayer().GetIndex()
              , u = _.GetLayer().GetIndex();
            0 === t ? (d > u || d === u && r.GetZIndex() > _.GetZIndex()) && (l = a) : (d < u || d === u && r.GetZIndex() < _.GetZIndex()) && (l = a)
        }
        return a.PickOne(l),
        !0
    }
    function R(t, a, n) {
        const r = this.GetWorldInfo()
          , i = 0 === t ? r.GetZElevation() : r.GetTotalZElevation();
        return C3.compare(i, a, n)
    }
    function S() {
        this.GetWorldInfo().ZOrderMoveToTop()
    }
    function T() {
        this.GetWorldInfo().ZOrderMoveToBottom()
    }
    function U(e) {
        e && this.GetWorldInfo().ZOrderMoveToLayer(e)
    }
    function V(e, t) {
        if (t) {
            const a = t.GetFirstPicked(this.GetInstance());
            a && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(a, 0 === e)
        }
    }
    function W(e) {
        const t = this.GetWorldInfo();
        t.GetZElevation() === e || (t.SetZElevation(e),
        this._runtime.UpdateRender())
    }
    function X() {
        return this.GetWorldInfo().GetLayer().GetIndex()
    }
    function Y() {
        return this.GetWorldInfo().GetLayer().GetName()
    }
    function Z() {
        return this.GetWorldInfo().GetZIndex()
    }
    function $() {
        return this.GetWorldInfo().GetZElevation()
    }
    function _() {
        return this.GetWorldInfo().GetTotalZElevation()
    }
    function ne(t, e) {
        const a = this.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
        if (a) {
            const n = a.GetIndex()
              , r = 1 === t
              , i = this.GetWorldInfo().GetInstanceEffectList();
            i.IsEffectIndexActive(n) === r || (i.SetEffectIndexActive(n, r),
            i.UpdateActiveEffects(),
            this._runtime.UpdateRender())
        }
    }
    function re(e, t, n) {
        const r = this.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
        if (r) {
            const i = r.GetIndex()
              , a = this.GetWorldInfo().GetInstanceEffectList()
              , e = a.GetEffectParametersForIndex(i);
            if (t = Math.floor(t),
            !(0 > t || t >= e.length)) {
                const l = r.GetShaderProgram().GetParameterType(t);
                if ('color' === l) {
                    xe.setFromRgbValue(n);
                    const r = e[t];
                    if (xe.equalsIgnoringAlpha(r))
                        return;
                    r.copyRgb(xe)
                } else {
                    if ('percent' === l && (n /= 100),
                    e[t] === n)
                        return;
                    e[t] = n
                }
                a.IsEffectIndexActive(i) && this._runtime.UpdateRender()
            }
        }
    }
    function ie(e, t, a) {
        return C3.compare(this.GetInstance().GetInstanceVariableValue(e), t, a)
    }
    function se(e) {
        return !!this.GetInstance().GetInstanceVariableValue(e)
    }
    function oe(t, a) {
        const n = this.GetCurrentSol()
          , r = n.GetInstances();
        if (!r.length)
            return !1;
        let i = r[0]
          , l = i
          , _ = i.GetInstanceVariableValue(a);
        for (let e = 1, n = r.length; e < n; ++e) {
            i = r[e];
            const n = i.GetInstanceVariableValue(a);
            (0 === t && n < _ || 1 === t && n > _) && (_ = n,
            l = i)
        }
        return n.PickOne(l),
        !0
    }
    function le(e) {
        return this._runtime.GetCurrentCondition().IsInverted() ? de(this, e) : _e(this, e)
    }
    function _e(e, t) {
        const a = e.GetRuntime().GetInstanceByUID(t);
        if (!a)
            return !1;
        const n = e.GetCurrentSol();
        if (!n.IsSelectAll() && !n._GetOwnInstances().includes(a))
            return !1;
        if (e.IsFamily()) {
            if (a.GetObjectClass().BelongsToFamily(e))
                return n.PickOne(a),
                e.ApplySolToContainer(),
                !0;
        } else if (a.GetObjectClass() === e)
            return n.PickOne(a),
            e.ApplySolToContainer(),
            !0;
        return !1
    }
    function de(t, n) {
        const r = t.GetCurrentSol();
        if (r.IsSelectAll()) {
            r._SetSelectAll(!1),
            r.ClearArrays();
            const i = t.GetInstances();
            for (let t = 0, a = i.length; t < a; ++t) {
                const a = i[t];
                a.GetUID() === n ? r._PushElseInstance(a) : r._PushInstance(a)
            }
            return t.ApplySolToContainer(),
            !!r._GetOwnInstances().length
        } else {
            const i = r._GetOwnInstances();
            let l = 0;
            for (let e = 0, t = i.length; e < t; ++e) {
                const t = i[e];
                i[l] = t,
                t.GetUID() === n ? r._PushElseInstance(t) : ++l
            }
            return C3.truncateArray(i, l),
            t.ApplySolToContainer(),
            !!i.length
        }
    }
    function ue() {
        this._runtime.DestroyInstance(this._inst)
    }
    function ce() {
        return !0
    }
    function ge() {
        return !0
    }
    function me(e, t) {
        this.GetInstance().SetInstanceVariableValue(e, t)
    }
    function pe(e, t) {
        const a = this.GetInstance()
          , n = a.GetInstanceVariableValue(e);
        'number' == typeof n && 'number' != typeof t ? t = parseFloat(t) : 'string' == typeof n && 'string' != typeof t && (t = t.toString()),
        a.SetInstanceVariableValue(e, n + t)
    }
    function he(e, t) {
        const a = this.GetInstance()
          , n = a.GetInstanceVariableValue(e);
        'number' != typeof n || ('number' != typeof t && (t = parseFloat(t)),
        a.SetInstanceVariableValue(e, n - t))
    }
    function fe(e, t) {
        this.GetInstance().SetInstanceVariableValue(e, t ? 1 : 0)
    }
    function Se(e) {
        const t = this.GetInstance();
        t.SetInstanceVariableValue(e, 0 === t.GetInstanceVariableValue(e) ? 1 : 0)
    }
    function ye(e) {
        let t;
        try {
            t = JSON.parse(e)
        } catch (e) {
            return void console.error('Failed to load from JSON string: ', e)
        }
        this.GetInstance().LoadFromJson(t, 'state')
    }
    function Ge() {
        return JSON.stringify(this.GetInstance().SaveToJson('state'))
    }
    function be() {
        return this.GetInstance().GetObjectClass().GetName()
    }
    function Te() {
        const e = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let t = e.GetInstanceCount();
        const a = this._runtime._GetInstancesPendingCreate();
        for (const n of a)
            e.IsFamily() ? n.GetObjectClass().BelongsToFamily(e) && ++t : n.GetObjectClass() === e && ++t;
        return t
    }
    function Ie() {
        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
    }
    function Ce() {
        return this._inst.GetIID()
    }
    function ve() {
        return this._inst.GetUID()
    }
    const xe = new C3.Color;
    C3.AddCommonACEs = function(_e, de) {
        const xe = _e[1]
          , Pe = _e[3]
          , Ae = _e[4]
          , Re = _e[5]
          , Ee = _e[6]
          , De = _e[7]
          , Be = _e[8]
          , ke = de.Cnds
          , we = de.Acts
          , Le = de.Exps;
        Pe && (ke.CompareX = ee,
        ke.CompareY = a,
        ke.IsOnScreen = b,
        ke.IsOutsideLayout = c,
        ke.PickDistance = d,
        we.SetX = e,
        we.SetY = f,
        we.SetPos = g,
        we.SetPosToObject = h,
        we.MoveForward = i,
        we.MoveAtAngle = j,
        Le.X = k,
        Le.Y = l,
        Le.dt = m),
        Ae && (ke.CompareWidth = n,
        ke.CompareHeight = te,
        we.SetWidth = p,
        we.SetHeight = q,
        we.SetSize = r,
        Le.Width = ae,
        Le.Height = t,
        Le.BBoxLeft = u,
        Le.BBoxTop = v,
        Le.BBoxRight = w,
        Le.BBoxBottom = x),
        Re && (ke.AngleWithin = y,
        ke.IsClockwiseFrom = z,
        ke.IsBetweenAngles = A,
        we.SetAngle = B,
        we.RotateClockwise = C,
        we.RotateCounterclockwise = D,
        we.RotateTowardAngle = E,
        we.RotateTowardPosition = F,
        we.SetTowardPosition = G,
        Le.Angle = H),
        Ee && (ke.IsVisible = J,
        ke.CompareOpacity = I,
        we.SetVisible = K,
        we.SetOpacity = L,
        we.SetDefaultColor = M,
        Le.Opacity = O,
        Le.ColorValue = N),
        De && (ke.IsOnLayer = P,
        ke.PickTopBottom = Q,
        ke.CompareZElevation = R,
        we.MoveToTop = S,
        we.MoveToBottom = T,
        we.MoveToLayer = U,
        we.ZMoveToObject = V,
        we.SetZElevation = W,
        Le.LayerNumber = X,
        Le.LayerName = Y,
        Le.ZIndex = Z,
        Le.ZElevation = $,
        Le.TotalZElevation = _),
        Be && (we.SetEffectEnabled = ne,
        we.SetEffectParam = re),
        xe || (ke.CompareInstanceVar = ie,
        ke.IsBoolInstanceVarSet = se,
        ke.PickInstVarHiLow = oe,
        ke.PickByUID = le,
        we.SetInstanceVar = me,
        we.AddInstanceVar = pe,
        we.SubInstanceVar = he,
        we.SetBoolInstanceVar = fe,
        we.ToggleBoolInstanceVar = Se,
        ke.OnCreated = ce,
        ke.OnDestroyed = ge,
        we.Destroy = ue,
        !we.LoadFromJsonString && (we.LoadFromJsonString = ye),
        !Le.AsJSON && (Le.AsJSON = Ge),
        Le.Count = Te,
        Le.PickedCount = Ie,
        Le.IID = Ce,
        Le.UID = ve,
        Le.ObjectTypeName = be)
    }
}
'use strict',
C3.ScheduledWait = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._eventSheetManager = e,
        this._type = '',
        this._time = -1,
        this._signalTag = '',
        this._isSignalled = !1,
        this._event = null,
        this._actIndex = 0,
        this._solModifiers = [],
        this._sols = new Map,
        this._callingFunctionBlock = null,
        this._asyncId = -1,
        this._functionParameters = null,
        this._shouldRelease = !1
    }
    Release() {
        this._type = '',
        this._time = -1,
        this._signalTag = '',
        this._event = null,
        this._callingFunctionBlock = null,
        this._functionParameters = null,
        this._asyncId = -1,
        C3.clearArray(this._solModifiers);
        for (const e of this._sols.values())
            e.Release();
        this._sols.clear()
    }
    _Init() {
        const e = this._eventSheetManager
          , t = e.GetRuntime().GetAllObjectClasses()
          , a = e.GetCurrentEventStackFrame();
        this._event = a.GetCurrentEvent(),
        this._actIndex = a.GetActionIndex() + 1;
        const n = e.FindFirstFunctionBlockParent(this._event);
        n && (this._callingFunctionBlock = n,
        this._functionParameters = n.CaptureFunctionParameters(),
        n.IsAsync() && (this._asyncId = n.PauseCurrentAsyncFunction()));
        for (const e of t) {
            const t = e.GetCurrentSol();
            t.IsSelectAll() && !this._event.HasSolModifier(e) || (this._solModifiers.push(e),
            this._sols.set(e, C3.New(C3.SolState, t)))
        }
    }
    InitTimer(e) {
        this._type = 'timer',
        this._Init(),
        this._time = this._eventSheetManager.GetRuntime().GetGameTime() + e
    }
    InitSignal(e) {
        this._type = 'signal',
        this._Init(),
        this._signalTag = e.toLowerCase()
    }
    InitPromise(e) {
        this._type = 'promise',
        this._Init(),
        e.then(()=>this.SetSignalled()).catch(e=>{
            console.warn('[C3 runtime] Promise rejected in \'Wait for previous actions to complete\': ', e),
            this.SetSignalled()
        }
        )
    }
    IsTimer() {
        return 'timer' === this._type
    }
    IsSignal() {
        return 'signal' === this._type
    }
    IsPromise() {
        return 'promise' === this._type
    }
    GetSignalTag() {
        return this._signalTag
    }
    IsSignalled() {
        return this._isSignalled
    }
    SetSignalled() {
        this._isSignalled = !0
    }
    _ShouldRun() {
        return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
    }
    _RestoreState(e) {
        e._Restore(this._event, this._actIndex);
        for (const [t,n] of this._sols.entries()) {
            const e = t.GetCurrentSol();
            n._Restore(e)
        }
        const t = this._callingFunctionBlock;
        t && (t.SetFunctionParameters(this._functionParameters),
        t.IsAsync() && t.ResumeAsyncFunction(this._asyncId))
    }
    _Run(e) {
        this._RestoreState(e),
        this._event._ResumeActionsAndSubEvents(e),
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId),
        this._eventSheetManager.ClearSol(this._solModifiers),
        this._shouldRelease = !0
    }
    async _DebugRun(e) {
        this._RestoreState(e);
        for (const t of this._event._DebugResumeActionsAndSubEvents(e))
            await this._eventSheetManager.GetRuntime().DebugBreak(t);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId),
        this._eventSheetManager.ClearSol(this._solModifiers),
        this._shouldRelease = !0
    }
    ShouldRelease() {
        return this._shouldRelease
    }
    RemoveInstances(e) {
        for (const t of this._sols.values())
            t.RemoveInstances(e)
    }
    _SaveToJson() {
        const e = {}
          , t = {
            t: this._time,
            st: this._signalTag,
            s: this._isSignalled,
            ev: this._event.GetSID(),
            sm: this._solModifiers.map(e=>e.GetSID()),
            sols: e
        };
        this._event._HasActionIndex(this._actIndex) && (t.act = this._event.GetActionAt(this._actIndex).GetSID());
        for (const [t,a] of this._sols)
            e[t.GetSID().toString()] = a._SaveToJson();
        return t
    }
    static _CreateFromJson(t, a) {
        const n = t.GetRuntime()
          , r = t.GetEventBlockBySID(a.ev);
        if (!r)
            return null;
        let i = 0;
        if (a.hasOwnProperty('act')) {
            const e = t.GetActionBySID(a.act);
            if (!e)
                return null;
            i = e.GetIndex()
        }
        const l = C3.New(C3.ScheduledWait, t);
        l._time = a.t,
        l._type = -1 === l._time ? 'signal' : 'timer',
        l._signalTag = a.st,
        l._isSignalled = a.s,
        l._event = r,
        l._actIndex = i;
        for (const e of a.sm) {
            const t = n.GetObjectClassBySID(e);
            t && l._solModifiers.push(t)
        }
        for (const [r,i] of Object.entries(a.sols)) {
            const e = parseInt(r, 10)
              , a = n.GetObjectClassBySID(e);
            if (!a)
                continue;
            const _ = C3.New(C3.SolState, null);
            _._LoadFromJson(t, i),
            l._sols.set(a, _)
        }
        return l
    }
}
,
'use strict',
C3.SolState = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._objectClass = null,
        this._isSelectAll = !0,
        this._instances = [],
        e && (this._objectClass = e.GetObjectClass(),
        this._isSelectAll = e.IsSelectAll(),
        C3.shallowAssignArray(this._instances, e._GetOwnInstances()))
    }
    Release() {
        this._objectClass = null,
        C3.clearArray(this._instances)
    }
    _Restore(e) {
        e._SetSelectAll(this._isSelectAll),
        C3.shallowAssignArray(e._GetOwnInstances(), this._instances)
    }
    RemoveInstances(e) {
        C3.arrayRemoveAllInSet(this._instances, e)
    }
    _SaveToJson() {
        return {
            sa: this._isSelectAll,
            insts: this._instances.map(e=>e.GetUID())
        }
    }
    _LoadFromJson(e, t) {
        const n = e.GetRuntime();
        this._isSelectAll = !!t.sa,
        C3.clearArray(this._instances);
        for (const r of t.insts) {
            const e = n.GetInstanceByUID(r);
            e && this._instances.push(e)
        }
    }
}
,
'use strict';
{
    function t(e, t) {
        let a = e.get(t);
        return a || (a = new Map,
        e.set(t, a)),
        a
    }
    C3.SDKPluginBase = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._runtime = e.runtime,
            this._isSingleGlobal = !!e.isSingleGlobal,
            this._isWorldType = !!e.isWorld,
            this._isRotatable = !!e.isRotatable,
            this._mustPredraw = !!e.mustPredraw,
            this._hasEffects = !!e.hasEffects,
            this._singleGlobalObjectClass = null,
            this._boundACEMethodCache = new Map,
            this._boundACEMethodCache_1param = new Map,
            this._boundACEMethodCache_2params = new Map,
            this._boundACEMethodCache_3params = new Map
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        IsSingleGlobal() {
            return this._isSingleGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        IsRotatable() {
            return this._isRotatable
        }
        MustPreDraw() {
            return this._mustPredraw
        }
        HasEffects() {
            return this._hasEffects
        }
        _GetBoundACEMethod(e, t) {
            if (!t)
                throw new Error('missing \'this\' binding');
            let a = this._boundACEMethodCache.get(e);
            return a ? a : (a = e.bind(t),
            this._boundACEMethodCache.set(e, a),
            a)
        }
        _GetBoundACEMethod_1param(a, n, r) {
            if (!n)
                throw new Error('missing \'this\' binding');
            const i = t(this._boundACEMethodCache_1param, a);
            let e = i.get(r);
            return e ? e : (e = a.bind(n, r),
            i.set(r, e),
            e)
        }
        _GetBoundACEMethod_2params(a, n, r, i) {
            if (!n)
                throw new Error('missing \'this\' binding');
            const e = t(this._boundACEMethodCache_2params, a)
              , l = t(e, r);
            let _ = l.get(i);
            return _ ? _ : (_ = a.bind(n, r, i),
            l.set(i, _),
            _)
        }
        _GetBoundACEMethod_3params(a, n, r, l, e) {
            if (!n)
                throw new Error('missing \'this\' binding');
            const _ = t(this._boundACEMethodCache_3params, a)
              , d = t(_, r)
              , u = t(d, l);
            let i = u.get(e);
            return i ? i : (i = a.bind(n, r, l, e),
            u.set(e, i),
            i)
        }
        _SetSingleGlobalObjectClass(e) {
            if (!this.IsSingleGlobal())
                throw new Error('must be single-global plugin');
            this._singleGlobalObjectClass = e
        }
        GetSingleGlobalObjectClass() {
            if (!this.IsSingleGlobal())
                throw new Error('must be single-global plugin');
            return this._singleGlobalObjectClass
        }
        GetSingleGlobalInstance() {
            if (!this.IsSingleGlobal())
                throw new Error('must be single-global plugin');
            return this._singleGlobalObjectClass.GetSingleGlobalInstance()
        }
    }
}
'use strict',
C3.SDKDOMPluginBase = class extends C3.SDKPluginBase {
    constructor(e, t) {
        super(e),
        this._domComponentId = t,
        this._nextElementId = 0,
        this._instMap = new Map
    }
    Release() {
        super.Release()
    }
    _AddElement(e) {
        const t = this._nextElementId++;
        return this._instMap.set(t, e),
        t
    }
    _RemoveElement(e) {
        this._instMap.delete(e)
    }
    AddElementMessageHandler(e, t) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, e=>{
            const a = this._instMap.get(e.elementId);
            t(a, e)
        }
        )
    }
}
,
'use strict',
C3.SDKTypeBase = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._objectClass = e,
        this._runtime = e.GetRuntime(),
        this._plugin = e.GetPlugin()
    }
    Release() {
        this._objectClass = null,
        this._runtime = null,
        this._plugin = null
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetImageInfo() {
        return this._objectClass.GetImageInfo()
    }
    FinishCondition() {}
    LoadTextures() {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances() {}
    LoadTilePolyData() {}
    GetScriptInterfaceClass() {
        return null
    }
}
,
'use strict',
C3.SDKInstanceBase = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._inst = e,
        this._domComponentId = t,
        this._runtime = e.GetRuntime(),
        this._objectClass = this._inst.GetObjectClass(),
        this._sdkType = this._objectClass.GetSdkType(),
        this._tickFunc = null,
        this._tick2Func = null,
        this._isTicking = !1,
        this._isTicking2 = !1,
        this._disposables = null,
        this._wasReleased = !1
    }
    Release() {
        this._wasReleased = !0,
        this._StopTicking(),
        this._StopTicking2(),
        this._tickFunc = null,
        this._tick2Func = null,
        this._disposables && (this._disposables.Release(),
        this._disposables = null),
        this._inst = null,
        this._runtime = null,
        this._objectClass = null,
        this._sdkType = null
    }
    WasReleased() {
        return this._wasReleased
    }
    GetInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetPlugin() {
        return this._sdkType.GetPlugin()
    }
    GetSdkType() {
        return this._sdkType
    }
    GetScriptInterface() {
        return this._inst.GetInterfaceClass()
    }
    Trigger(e) {
        return this._runtime.Trigger(e, this._inst, null)
    }
    DebugTrigger(e) {
        return this._runtime.DebugTrigger(e, this._inst, null)
    }
    TriggerAsync(e) {
        return this._runtime.TriggerAsync(e, this._inst, null)
    }
    FastTrigger(e, t) {
        return this._runtime.FastTrigger(e, this._inst, t)
    }
    DebugFastTrigger(e, t) {
        return this._runtime.DebugFastTrigger(e, this._inst, t)
    }
    ScheduleTriggers(e) {
        return this._runtime.ScheduleTriggers(e)
    }
    AddDOMMessageHandler(e, t) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t)
    }
    AddDOMMessageHandlers(e) {
        for (const [t,a] of e)
            this.AddDOMMessageHandler(t, a)
    }
    PostToDOM(e, t) {
        this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t)
    }
    PostToDOMAsync(e, t) {
        return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t)
    }
    _PostToDOMMaybeSync(e, t) {
        this._runtime.IsInWorker() ? this.PostToDOM(e, t) : window.c3_runtimeInterface._OnMessageFromRuntime({
            type: 'event',
            component: this._domComponentId,
            handler: e,
            data: t,
            responseId: null
        })
    }
    GetCurrentImageInfo() {
        return null
    }
    GetImagePoint() {
        const e = this._inst.GetWorldInfo();
        return [e.GetX(), e.GetY()]
    }
    Tick() {}
    Tick2() {}
    _StartTicking() {
        this._isTicking || (!this._tickFunc && (this._tickFunc = ()=>this.Tick()),
        this._runtime.Dispatcher().addEventListener('tick', this._tickFunc),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime.Dispatcher().removeEventListener('tick', this._tickFunc),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (!this._tick2Func && (this._tick2Func = ()=>this.Tick2()),
        this._runtime.Dispatcher().addEventListener('tick2', this._tick2Func),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime.Dispatcher().removeEventListener('tick2', this._tick2Func),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    GetDebuggerProperties() {
        return []
    }
    SaveToJson() {
        return null
    }
    LoadFromJson() {}
    LoadTilemapData() {}
    TestPointOverlapTile() {}
    GetPropertyValueByIndex() {}
    SetPropertyValueByIndex() {}
    OffsetPropertyValueByIndex(e, t) {
        if (0 !== t) {
            const a = this.GetPropertyValueByIndex(e);
            if ('number' != typeof a)
                throw new Error('expected number');
            this.SetPropertyValueByIndex(e, a + t)
        }
    }
    SetPropertyColorOffsetValueByIndex() {}
    CallAction(e, ...t) {
        e.call(this, ...t)
    }
    CallExpression(e, ...t) {
        return e.call(this, ...t)
    }
    GetScriptInterfaceClass() {
        return null
    }
}
,
'use strict',
C3.SDKWorldInstanceBase = class extends C3.SDKInstanceBase {
    constructor(e, t) {
        super(e, t),
        this._worldInfo = e.GetWorldInfo(),
        this._webglcontextlost_handler = null,
        this._webglcontextrestored_handler = null
    }
    Release() {
        if (this._webglcontextlost_handler) {
            const e = this._runtime.Dispatcher();
            e.removeEventListener('webglcontextlost', this._webglcontextlost_handler),
            e.removeEventListener('webglcontextrestored', this._webglcontextrestored_handler),
            this._webglcontextlost_handler = null,
            this._webglcontextrestored_handler = null
        }
        this._worldInfo = null,
        super.Release()
    }
    HandleWebGLContextLoss() {
        if (!this._webglcontextlost_handler) {
            this._webglcontextlost_handler = ()=>this.OnWebGLContextLost(),
            this._webglcontextrestored_handler = ()=>this.OnWebGLContextRestored();
            const e = this._runtime.Dispatcher();
            e.addEventListener('webglcontextlost', this._webglcontextlost_handler),
            e.addEventListener('webglcontextrestored', this._webglcontextrestored_handler)
        }
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    GetWorldInfo() {
        return this._worldInfo
    }
}
,
'use strict';
{
    const t = C3.New(C3.Rect);
    C3.SDKDOMInstanceBase = class extends C3.SDKWorldInstanceBase {
        constructor(e, t) {
            super(e, t),
            this._elementId = this.GetPlugin()._AddElement(this),
            this._isElementShowing = !0,
            this._autoFontSize = !1,
            this._lastRect = C3.New(C3.Rect, 0, 0, -1, -1);
            const a = this._runtime.GetCanvasManager();
            this._lastWindowWidth = a.GetLastWidth(),
            this._lastWindowHeight = a.GetLastHeight(),
            this._isPendingUpdateState = !1,
            this._StartTicking()
        }
        Release() {
            this.GetPlugin()._RemoveElement(this._elementId),
            this.PostToDOMElement('destroy'),
            this._elementId = -1,
            super.Release()
        }
        PostToDOMElement(e, t) {
            t || (t = {}),
            t.elementId = this._elementId,
            this.PostToDOM(e, t)
        }
        _PostToDOMElementMaybeSync(e, t) {
            t || (t = {}),
            t.elementId = this._elementId,
            this._PostToDOMMaybeSync(e, t)
        }
        PostToDOMElementAsync(e, t) {
            return t || (t = {}),
            t.elementId = this._elementId,
            this.PostToDOMAsync(e, t)
        }
        CreateElement(e) {
            e || (e = {});
            const t = this.GetWorldInfo().IsVisible();
            e.elementId = this._elementId,
            e.isVisible = t,
            Object.assign(e, this.GetElementState()),
            this._isElementShowing = !!e.isVisible,
            this.PostToDOM('create', e),
            this._UpdatePosition(!0)
        }
        SetElementVisible(e) {
            e = !!e,
            this._isElementShowing === e || (this._isElementShowing = e,
            this.PostToDOMElement('set-visible', {
                isVisible: e
            }))
        }
        Tick() {
            this._UpdatePosition(!1)
        }
        _ShouldPreserveElement() {
            const e = this._runtime.GetCanvasManager().GetFullscreenMode();
            return 'Android' === C3.Platform.OS && ('scale-inner' === e || 'scale-outer' === e || 'crop' === e)
        }
        _UpdatePosition(a) {
            var r = Math.round;
            const _ = this.GetWorldInfo()
              , d = _.GetLayer()
              , e = _.GetX()
              , u = _.GetY();
            let[c,g] = d.LayerToCanvasCss(e, u)
              , [f,S] = d.LayerToCanvasCss(e + _.GetWidth(), u + _.GetHeight());
            const y = this._runtime.GetCanvasManager()
              , l = y.GetCssWidth()
              , m = y.GetCssHeight();
            if (!_.IsVisible() || !d.IsVisible())
                return void this.SetElementVisible(!1);
            if (!this._ShouldPreserveElement()) {
                if (0 >= f || 0 >= S || c >= l || g >= m)
                    return void this.SetElementVisible(!1);
                1 > c && (c = 1),
                1 > g && (g = 1),
                f >= l && (f = l - 1),
                S >= m && (S = m - 1)
            }
            t.set(c, g, f, S);
            const n = y.GetLastWidth()
              , G = y.GetLastHeight();
            if (!a && t.equals(this._lastRect) && this._lastWindowWidth === n && this._lastWindowHeight === G)
                return void this.SetElementVisible(!0);
            this._lastRect.copy(t),
            this._lastWindowWidth = n,
            this._lastWindowHeight = G,
            this.SetElementVisible(!0);
            let p = null;
            this._autoFontSize && (p = d.GetDisplayScale() - .2),
            this.PostToDOMElement('update-position', {
                left: r(this._lastRect.getLeft()) + y.GetCanvasClientX(),
                top: r(this._lastRect.getTop()) + y.GetCanvasClientY(),
                width: r(this._lastRect.width()),
                height: r(this._lastRect.height()),
                fontSize: p
            })
        }
        FocusElement() {
            this.PostToDOMElement('focus', {
                focus: !0
            })
        }
        BlurElement() {
            this.PostToDOMElement('focus', {
                focus: !1
            })
        }
        SetElementCSSStyle(e, t) {
            this.PostToDOMElement('set-css-style', {
                prop: C3.CSSToCamelCase(e),
                val: t
            })
        }
        UpdateElementState() {
            this._isPendingUpdateState || (this._isPendingUpdateState = !0,
            Promise.resolve().then(()=>{
                this._isPendingUpdateState = !1,
                this.PostToDOMElement('update-state', this.GetElementState())
            }
            ))
        }
        GetElementState() {}
        GetElementId() {
            return this._elementId
        }
    }
}
'use strict',
C3.SDKBehaviorBase = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e.runtime,
        this._myObjectClasses = C3.New(C3.ArraySet),
        this._myInstances = C3.New(C3.ArraySet),
        this._iBehavior = null;
        const t = e.scriptInterfaceClass;
        if (!t)
            this._iBehavior = new IBehavior(this);
        else if (this._iBehavior = new t(this),
        !(this._iBehavior instanceof IBehavior))
            throw new TypeError('script interface class must derive from IBehavior')
    }
    Release() {
        this._myInstances.Release(),
        this._myObjectClasses.Release(),
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    OnCreate() {}
    _AddObjectClass(e) {
        this._myObjectClasses.Add(e)
    }
    GetObjectClasses() {
        return this._myObjectClasses.GetArray()
    }
    _AddInstance(e) {
        this._myInstances.Add(e)
    }
    _RemoveInstance(e) {
        this._myInstances.Delete(e)
    }
    GetInstances() {
        return this._myInstances.GetArray()
    }
    GetIBehavior() {
        return this._iBehavior
    }
}
,
'use strict',
C3.SDKBehaviorTypeBase = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e.GetRuntime(),
        this._behaviorType = e,
        this._objectClass = e.GetObjectClass(),
        this._behavior = e.GetBehavior(),
        this._behavior._AddObjectClass(this._objectClass)
    }
    Release() {
        this._runtime = null,
        this._behaviorType = null,
        this._objectClass = null,
        this._behavior = null
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehavior() {
        return this._behavior
    }
}
,
'use strict',
C3.SDKBehaviorInstanceBase = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._behInst = e,
        this._domComponentId = t,
        this._inst = e.GetObjectInstance(),
        this._runtime = e.GetRuntime(),
        this._behaviorType = e.GetBehaviorType(),
        this._sdkType = this._behaviorType.GetSdkType(),
        this._isTicking = !1,
        this._isTicking2 = !1,
        this._isPostTicking = !1,
        this._disposables = null
    }
    Release() {
        this._StopTicking(),
        this._StopTicking2(),
        this._StopPostTicking(),
        this._disposables && (this._disposables.Release(),
        this._disposables = null),
        this._behInst = null,
        this._inst = null,
        this._runtime = null,
        this._behaviorType = null,
        this._sdkType = null
    }
    GetBehavior() {
        return this._behaviorType.GetBehavior()
    }
    GetBehaviorInstance() {
        return this._behInst
    }
    GetObjectInstance() {
        return this._inst
    }
    GetObjectClass() {
        return this._inst.GetObjectClass()
    }
    GetWorldInfo() {
        return this._inst.GetWorldInfo()
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetSdkType() {
        return this._sdkType
    }
    Trigger(e) {
        return this._runtime.Trigger(e, this._inst, this._behaviorType)
    }
    DebugTrigger(e) {
        return this._runtime.DebugTrigger(e, this._inst, this._behaviorType)
    }
    TriggerAsync(e) {
        return this._runtime.TriggerAsync(e, this._inst, this._behaviorType)
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking() {
        this._isTicking || (this._runtime._AddBehInstToTick(this),
        this._isTicking = !0)
    }
    _StopTicking() {
        this._isTicking && (this._runtime._RemoveBehInstToTick(this),
        this._isTicking = !1)
    }
    IsTicking() {
        return this._isTicking
    }
    _StartTicking2() {
        this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
        this._isTicking2 = !0)
    }
    _StopTicking2() {
        this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this),
        this._isTicking2 = !1)
    }
    IsTicking2() {
        return this._isTicking2
    }
    _StartPostTicking() {
        this._isPostTicking || (this._runtime._AddBehInstToPostTick(this),
        this._isPostTicking = !0)
    }
    _StopPostTicking() {
        this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this),
        this._isPostTicking = !1)
    }
    IsPostTicking() {
        return this._isPostTicking
    }
    GetDebuggerProperties() {
        return []
    }
    AddDOMMessageHandler(e, t) {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t)
    }
    OnSpriteFrameChanged() {}
    SaveToJson() {
        return null
    }
    LoadFromJson() {}
    GetPropertyValueByIndex() {}
    SetPropertyValueByIndex() {}
    OffsetPropertyValueByIndex(e, t) {
        if (0 !== t) {
            const a = this.GetPropertyValueByIndex(e);
            if ('number' != typeof a)
                throw new Error('expected number');
            this.SetPropertyValueByIndex(e, a + t)
        }
    }
    SetPropertyColorOffsetValueByIndex() {}
    CallAction(e, ...t) {
        e.call(this, ...t)
    }
    CallExpression(e, ...t) {
        return e.call(this, ...t)
    }
    GetScriptInterfaceClass() {
        return null
    }
}
,
'use strict';
{
    function t(t, n) {
        const a = t[0]
          , r = n[0]
          , i = a - r;
        if (0 != i)
            return i;
        const e = t[1]
          , l = n[1];
        return e - l
    }
    let n = null;
    const r = new Set
      , l = []
      , _ = [];
    let e = !1;
    self.IRuntime = class {
        constructor(t, a) {
            n = t,
            Object.defineProperties(this, {
                assets: {
                    value: n.GetAssetManager().GetIAssetManager(),
                    writable: !1
                },
                objects: {
                    value: a,
                    writable: !1
                },
                globalVars: {
                    value: {},
                    writable: !1
                },
                projectName: {
                    value: n.GetProjectName(),
                    writable: !1
                },
                projectVersion: {
                    value: n.GetProjectVersion(),
                    writable: !1
                },
                storage: {
                    value: new IStorage(n),
                    writable: !1
                },
                isInWorker: {
                    value: n.IsInWorker(),
                    writable: !1
                }
            }),
            n.UserScriptDispatcher().addEventListener('keydown', e=>r.has(e.key) ? void e.stopPropagation() : void r.add(e.key)),
            n.UserScriptDispatcher().addEventListener('keyup', e=>r.delete(e.key)),
            n.Dispatcher().addEventListener('window-blur', ()=>r.clear()),
            n.IsInWorker() && (self.alert = t=>(e || (e = !0,
            console.warn('[Construct 3] alert() was called from a Web Worker, because the project \'Use worker\' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable \'Use worker\', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.')),
            this.alert(t)))
        }
        _InitGlobalVars(e) {
            Object.defineProperties(this.globalVars, e)
        }
        addEventListener(e, t) {
            n.UserScriptDispatcher().addEventListener(e, t)
        }
        removeEventListener(e, t) {
            n.UserScriptDispatcher().removeEventListener(e, t)
        }
        callFunction(t, ...a) {
            const r = n.GetEventSheetManager()
              , l = r.GetFunctionBlockByName(t);
            if (!l)
                throw new Error(`cannot find function name '${t}'`);
            if (!l.IsEnabled())
                return l.GetDefaultReturnValue();
            if (a.length < l.GetFunctionParameterCount())
                throw new Error(`not enough function parameters passed for '${t}' (${a.length} passed, ${l.GetFunctionParameterCount()} expected)`);
            const e = l.GetEventBlock();
            let _ = null;
            const d = r.GetCurrentEvent();
            if (d) {
                const e = d.GetSolModifiersIncludingParents();
                0 < e.length && (_ = e,
                r.PushCleanSol(e))
            }
            const u = e.RunAsExpressionFunctionCall(e.GetSolModifiersIncludingParents(), l.GetReturnType(), l.GetDefaultReturnValue(), ...a);
            return _ && r.PopSol(_),
            u
        }
        setReturnValue(e) {
            const t = n.GetEventStack().GetCurrentExpFuncStackFrame();
            if (!t)
                throw new Error('not in a function which returns a value');
            switch (t.GetFunctionReturnType()) {
            case 1:
                'number' == typeof e && t.SetFunctionReturnValue(e);
                break;
            case 2:
                'string' == typeof e && t.SetFunctionReturnValue(e);
                break;
            case 3:
                ('number' == typeof e || 'string' == typeof e) && t.SetFunctionReturnValue(e);
            }
        }
        get dt() {
            return n.GetDt()
        }
        get gameTime() {
            return n.GetGameTime()
        }
        get wallTime() {
            return n.GetWallTime()
        }
        random() {
            return n.Random()
        }
        get layout() {
            return n.GetMainRunningLayout().GetILayout()
        }
        getLayout(e) {
            const t = n.GetLayoutManager();
            let a = null;
            if ('number' == typeof e || 'string' == typeof e)
                a = t.GetLayout(e);
            else
                throw new TypeError('expected string or number');
            if (!a)
                throw new Error('invalid layout');
            return a.GetILayout()
        }
        getAllLayouts() {
            return n.GetLayoutManager().GetAllLayouts().map(e=>e.GetILayout())
        }
        goToLayout(e) {
            const t = n.GetLayoutManager();
            let a = null;
            if ('number' == typeof e || 'string' == typeof e)
                a = t.GetLayout(e);
            else
                throw new TypeError('expected string or number');
            if (!a)
                throw new Error('invalid layout');
            t.IsPendingChangeMainLayout() || t.ChangeMainLayout(a)
        }
        get keyboard() {
            const e = n._GetCommonScriptInterfaces().keyboard;
            if (!e)
                throw new Error('runtime.keyboard used but Keyboard object missing - add it to your project first');
            return e
        }
        get mouse() {
            const e = n._GetCommonScriptInterfaces().mouse;
            if (!e)
                throw new Error('runtime.mouse used but Mouse object missing - add it to your project first');
            return e
        }
        get touch() {
            const e = n._GetCommonScriptInterfaces().touch;
            if (!e)
                throw new Error('runtime.touch used but Touch object missing - add it to your project first');
            return e
        }
        invokeDownload(e, t) {
            n.InvokeDownload(e, t)
        }
        getInstanceByUid(e) {
            const t = n.GetInstanceByUID(e);
            return t ? t.GetInterfaceClass() : null
        }
        sortZOrder(e, r) {
            const d = n.GetCurrentLayout();
            for (const t of e) {
                const e = n._UnwrapScriptInterface(t);
                if (!e || !e.GetWorldInfo())
                    throw new Error('invalid instance');
                const a = e.GetWorldInfo();
                l.push([a.GetLayer().GetIndex(), a.GetZIndex()]),
                _.push(e)
            }
            if (0 === l.length)
                return;
            l.sort(t),
            _.sort((e,t)=>r(e.GetInterfaceClass(), t.GetInterfaceClass()));
            let u = !1;
            for (let t = 0, a = l.length; t < a; ++t) {
                const e = _[t]
                  , a = d.GetLayerByIndex(l[t][0])
                  , n = l[t][1]
                  , r = a._GetInstances();
                r[n] !== e && (r[n] = e,
                e.GetWorldInfo()._SetLayer(a),
                a.SetZIndicesChanged(),
                u = !0)
            }
            u && n.UpdateRender(),
            C3.clearArray(l),
            C3.clearArray(_)
        }
        alert(e) {
            return n.PostComponentMessageToDOMAsync('runtime', 'alert', {
                message: e + (n.IsInWorker() ? ' [via Web Worker]' : '')
            })
        }
    }
}
{
    let t = null;
    self.IAssetManager = class {
        constructor(e) {
            t = e,
            Object.defineProperties(this, {
                isWebMOpusSupported: {
                    value: t.IsAudioFormatSupported('audio/webm; codecs=opus'),
                    writable: !1
                }
            })
        }
        fetchText(e) {
            return t.FetchText(e)
        }
        fetchJson(e) {
            return t.FetchJson(e)
        }
        fetchBlob(e) {
            return t.FetchBlob(e)
        }
        fetchArrayBuffer(e) {
            return t.FetchArrayBuffer(e)
        }
        getProjectFileUrl(e) {
            return t.GetProjectFileUrl(e)
        }
        getMediaFileUrl(e) {
            return C3.IsRelativeURL(e) && (e = e.toLowerCase()),
            t.GetMediaFileUrl(e, t.GetMediaSubfolder())
        }
        get mediaFolder() {
            return t.GetMediaSubfolder()
        }
        async decodeWebMOpus(a, n) {
            if (this.isWebMOpusSupported)
                throw new Error('decodeWebMOpus(): not supported because WebM Opus is supported by the platform');
            const r = await t.GetRuntime()._WasmDecodeWebMOpus(n)
              , i = new Float32Array(r)
              , e = a.createBuffer(1, i.length, 48e3)
              , l = e.getChannelData(0);
            return l.set(i),
            e
        }
        loadScripts(...e) {
            return t.LoadScripts(...e)
        }
        compileWebAssembly(e) {
            return t.CompileWebAssembly(e)
        }
        loadStyleSheet(e) {
            return t.LoadStyleSheet(e)
        }
    }
}
'use strict',
self.IStorage = class {
    constructor(e) {
        this._storage = e._GetProjectStorage()
    }
    getItem(e) {
        return this._storage.getItem(e)
    }
    setItem(e, t) {
        return this._storage.setItem(e, t)
    }
    removeItem(e) {
        return this._storage.removeItem(e)
    }
    clear() {
        return this._storage.clear()
    }
    keys() {
        return this._storage.keys()
    }
}
,
'use strict';
{
    const t = new WeakMap;
    self.IObjectClass = class {
        constructor(e) {
            t.set(this, e),
            Object.defineProperties(this, {
                name: {
                    value: e.GetName(),
                    writable: !1
                }
            }),
            e.GetRuntime()._MapScriptInterface(this, e)
        }
        getAllInstances() {
            return t.get(this).GetInstances().map(e=>e.GetInterfaceClass())
        }
        getFirstInstance() {
            const e = t.get(this).GetInstances();
            return 0 < e.length ? e[0].GetInterfaceClass() : null
        }
        getPickedInstances() {
            return t.get(this).GetCurrentSol().GetInstances().map(e=>e.GetInterfaceClass())
        }
        getFirstPickedInstance() {
            const e = t.get(this).GetCurrentSol().GetInstances();
            return 0 < e.length ? e[0].GetInterfaceClass() : null
        }
        *instances() {
            for (const e of t.get(this).GetInstances())
                yield e.GetInterfaceClass()
        }
        *pickedInstances() {
            for (const e of t.get(this).GetCurrentSol().GetInstances())
                yield e.GetInterfaceClass()
        }
        setInstanceClass(e) {
            const a = t.get(this);
            if (0 < a.GetInstanceCount())
                throw new Error('setInstanceClass() called too late, because instances have already been created - call in runOnStartup');
            t.get(this)._SetUserScriptInstanceClass(e)
        }
        createInstance(a, n, r) {
            if ('number' != typeof a && 'string' != typeof a)
                throw new TypeError('invalid layer parameter');
            const l = t.get(this)
              , e = l.GetRuntime()
              , _ = e.GetMainRunningLayout().GetLayer(a);
            if (!_)
                throw new Error('invalid layer');
            const d = e.CreateInstance(l, _, n, r)
              , u = e.GetEventSheetManager();
            if (u.BlockFlushingInstances(!0),
            d._TriggerOnCreated(),
            d.IsInContainer())
                for (const e of d.siblings())
                    e._TriggerOnCreated();
            return u.BlockFlushingInstances(!1),
            d.GetInterfaceClass()
        }
    }
}
{
    const e = new WeakMap;
    self.ILayout = class {
        constructor(t) {
            e.set(this, t),
            Object.defineProperties(this, {
                name: {
                    value: t.GetName(),
                    writable: !1
                },
                index: {
                    value: t.GetIndex(),
                    writable: !1
                }
            })
        }
        addEventListener(t, a) {
            e.get(this).UserScriptDispatcher().addEventListener(t, a)
        }
        removeEventListener(t, a) {
            e.get(this).UserScriptDispatcher().removeEventListener(t, a)
        }
        get width() {
            return e.get(this).GetWidth()
        }
        set width(t) {
            e.get(this).SetWidth(t)
        }
        get height() {
            return e.get(this).GetHeight()
        }
        set height(t) {
            e.get(this).SetHeight(t)
        }
        scrollTo(t, a) {
            const n = e.get(this);
            n.SetScrollX(t),
            n.SetScrollY(a)
        }
        getLayer(t) {
            const a = e.get(this);
            let n = null;
            if ('number' == typeof t || 'string' == typeof t)
                n = a.GetLayer(t);
            else
                throw new TypeError('expected string or number');
            if (!n)
                throw new Error('invalid layer');
            return n.GetILayer()
        }
        getAllLayers() {
            return e.get(this).GetLayers().map(e=>e.GetILayer())
        }
    }
}
{
    const e = new WeakMap;
    self.ILayer = class {
        constructor(t) {
            e.set(this, t),
            Object.defineProperties(this, {
                name: {
                    value: t.GetName(),
                    writable: !1
                },
                index: {
                    value: t.GetIndex(),
                    writable: !1
                },
                layout: {
                    value: t.GetLayout().GetILayout(),
                    writable: !1
                }
            })
        }
        static _Unwrap(t) {
            return e.get(t)
        }
        get isVisible() {
            return e.get(this).IsVisible()
        }
        set isVisible(t) {
            e.get(this).SetVisible(t)
        }
        get opacity() {
            return e.get(this).GetOpacity()
        }
        set opacity(t) {
            t = C3.clamp(+t, 0, 1),
            isNaN(t) || e.get(this).SetOpacity(t)
        }
        getViewport() {
            return e.get(this).GetViewport().toDOMRect()
        }
    }
}
{
    function e(e) {
        let t = n.get(e);
        return t ? t : (t = C3.New(C3.Event.Dispatcher),
        n.set(e, t),
        t)
    }
    const t = new WeakMap
      , n = new WeakMap;
    let r = null;
    self.IInstance = class {
        constructor() {
            t.set(this, r);
            const e = {
                runtime: {
                    value: r.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                objectType: {
                    value: r.GetObjectClass().GetIObjectClass(),
                    writable: !1
                },
                uid: {
                    value: r.GetUID(),
                    writable: !1
                }
            };
            r._GetInstVarsScriptDescriptor(e),
            r._GetBehaviorsScriptDescriptor(e),
            Object.defineProperties(this, e),
            r.GetRuntime()._MapScriptInterface(this, r)
        }
        static _Init(e) {
            r = e
        }
        static _GetInitInst() {
            return r
        }
        _Release() {
            const e = n.get(this);
            e && (e.Release(),
            n.delete(this)),
            t.delete(this)
        }
        addEventListener(t, a, n) {
            e(this).addEventListener(t, a, n)
        }
        removeEventListener(t, a, n) {
            e(this).removeEventListener(t, a, n)
        }
        dispatchEvent(t) {
            e(this).dispatchEvent(t)
        }
        destroy() {
            const e = t.get(this);
            e.GetRuntime().DestroyInstance(e)
        }
    }
}
{
    const t = new WeakMap
      , n = new Map([['normal', 0], ['additive', 1], ['copy', 3], ['destination-over', 4], ['source-in', 5], ['destination-in', 6], ['source-out', 7], ['destination-out', 8], ['source-atop', 9], ['destination-atop', 10]])
      , e = new Map([...n.entries()].map(e=>[e[1], e[0]]))
      , r = C3.New(C3.Color);
    self.IWorldInstance = class extends IInstance {
        constructor() {
            super();
            const n = IInstance._GetInitInst();
            t.set(this, n);
            const r = []
              , i = n.GetWorldInfo()
              , a = i.GetInstanceEffectList();
            if (a) {
                const e = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let t = 0; t < e; ++t)
                    r.push(new IEffectInstance(i,t))
            }
            Object.defineProperties(this, {
                effects: {
                    value: r,
                    writable: !1
                }
            })
        }
        get layout() {
            return t.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return t.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return t.get(this).GetWorldInfo().GetX()
        }
        set x(e) {
            e = +e;
            const n = t.get(this).GetWorldInfo();
            isNaN(e) || n.GetX() === e || (n.SetX(e),
            n.SetBboxChanged())
        }
        get y() {
            return t.get(this).GetWorldInfo().GetY()
        }
        set y(e) {
            e = +e;
            const n = t.get(this).GetWorldInfo();
            isNaN(e) || n.GetY() === e || (n.SetY(e),
            n.SetBboxChanged())
        }
        get zElevation() {
            return t.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(e) {
            e = +e;
            const n = t.get(this)
              , r = n.GetWorldInfo();
            r.GetZElevation() === e || (r.SetZElevation(e),
            n.GetRuntime().UpdateRender())
        }
        get totalZElevation() {
            return t.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return t.get(this).GetWorldInfo().GetWidth()
        }
        set width(e) {
            e = +e;
            const n = t.get(this).GetWorldInfo();
            isNaN(e) || n.GetWidth() === e || (n.SetWidth(e),
            n.SetBboxChanged())
        }
        get height() {
            return t.get(this).GetWorldInfo().GetHeight()
        }
        set height(e) {
            e = +e;
            const n = t.get(this).GetWorldInfo();
            isNaN(e) || n.GetHeight() === e || (n.SetHeight(e),
            n.SetBboxChanged())
        }
        get angle() {
            return t.get(this).GetWorldInfo().GetAngle()
        }
        set angle(e) {
            e = C3.clampAngle(+e);
            const a = t.get(this).GetWorldInfo();
            isNaN(e) || a.GetAngle() === e || (a.SetAngle(e),
            a.SetBboxChanged())
        }
        get angleDegrees() {
            return C3.toDegrees(this.angle)
        }
        set angleDegrees(e) {
            this.angle = C3.toRadians(e)
        }
        getBoundingBox() {
            return t.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return t.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        get isVisible() {
            return t.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(e) {
            e = !!e;
            const n = t.get(this)
              , r = n.GetWorldInfo();
            r.IsVisible() === e || (r.SetVisible(e),
            n.GetRuntime().UpdateRender())
        }
        get opacity() {
            return t.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(e) {
            e = C3.clamp(+e, 0, 1);
            const n = t.get(this)
              , r = n.GetWorldInfo();
            isNaN(e) || r.GetOpacity() === e || (r.SetOpacity(e),
            n.GetRuntime().UpdateRender())
        }
        set colorRgb(n) {
            if (3 > n.length)
                throw new Error('expected 3 elements');
            r.setRgb(n[0], n[1], n[2]);
            const a = t.get(this)
              , i = a.GetWorldInfo();
            i.GetUnpremultipliedColor().equalsIgnoringAlpha(r) || (i.SetUnpremultipliedColor(r),
            a.GetRuntime().UpdateRender())
        }
        get colorRgb() {
            const e = t.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [e.getR(), e.getG(), e.getB()]
        }
        set blendMode(a) {
            const r = n.get(a);
            if ('number' != typeof r)
                throw new Error('invalid blend mode');
            const i = t.get(this)
              , e = i.GetWorldInfo();
            e.SetBlendMode(r),
            i.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return e.get(t.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            t.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            t.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(e) {
            const a = ILayer._Unwrap(e);
            if (!a)
                throw new Error('invalid layer');
            t.get(this).GetWorldInfo().ZOrderMoveToLayer(a)
        }
        moveAdjacentToInstance(e, a) {
            t.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(t.get(e), a)
        }
        containsPoint(e, a) {
            return t.get(this).GetWorldInfo().ContainsPoint(+e, +a)
        }
        testOverlap(n) {
            const r = t.get(this)
              , e = t.get(n);
            return r.GetRuntime().GetCollisionEngine().TestOverlap(r, e)
        }
        testOverlapSolid() {
            const e = t.get(this)
              , a = e.GetRuntime().GetCollisionEngine().TestOverlapSolid(e);
            return a ? a.GetInterfaceClass() : null
        }
    }
}
{
    const e = new WeakMap;
    self.IDOMInstance = class extends IWorldInstance {
        constructor() {
            super(),
            e.set(this, IInstance._GetInitInst())
        }
        focus() {
            e.get(this).GetSdkInstance().FocusElement()
        }
        blur() {
            e.get(this).GetSdkInstance().BlurElement()
        }
        setCssStyle(t, a) {
            e.get(this).GetSdkInstance().SetElementCSSStyle(t, a)
        }
    }
}
{
    const e = new WeakMap;
    let t = null;
    self.IBehaviorInstance = class {
        constructor() {
            e.set(this, t);
            const a = {
                runtime: {
                    value: t.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                behavior: {
                    value: t.GetBehavior().GetIBehavior(),
                    writable: !1
                }
            };
            Object.defineProperties(this, a)
        }
        static _Init(e) {
            t = e
        }
        static _GetInitInst() {
            return t
        }
        get instance() {
            return e.get(this).GetObjectInstance().GetInterfaceClass()
        }
    }
}
{
    const e = new WeakMap;
    self.IBehavior = class {
        constructor(t) {
            e.set(this, t);
            const a = {
                runtime: {
                    value: t.GetRuntime().GetIRuntime(),
                    writable: !1
                }
            };
            Object.defineProperties(this, a)
        }
        getAllInstances() {
            return e.get(this).GetInstances().map(e=>e.GetInterfaceClass())
        }
    }
}
{
    const t = new WeakMap;
    self.IEffectInstance = class {
        constructor(e, a) {
            t.set(this, e),
            Object.defineProperties(this, {
                index: {
                    value: a,
                    writable: !1
                }
            })
        }
        get name() {
            const e = t.get(this)
              , a = e.GetObjectClass().GetEffectList().GetAllEffectTypes();
            return a[this.index].GetName()
        }
        get isActive() {
            const e = t.get(this)
              , a = e.GetInstanceEffectList();
            return a.IsEffectIndexActive(this.index)
        }
        set isActive(a) {
            a = !!a;
            const n = t.get(this)
              , r = n.GetInstanceEffectList();
            r.IsEffectIndexActive(this.index) === a || (r.SetEffectIndexActive(this.index, a),
            r.UpdateActiveEffects(),
            n.GetRuntime().UpdateRender())
        }
        setParameter(n, r) {
            n = Math.floor(+n);
            const i = t.get(this)
              , l = i.GetInstanceEffectList()
              , e = l.GetEffectParametersForIndex(this.index);
            if (0 > n || n >= e.length)
                throw new RangeError('invalid effect parameter index');
            const _ = e[n];
            if (_ instanceof C3.Color) {
                if (!Array.isArray(r) || 3 > r.length)
                    throw new TypeError('expected array with 3 elements');
                const t = r[0]
                  , a = r[1]
                  , n = r[2];
                if (_.equalsRgb(t, a, n))
                    return;
                _.setRgb(t, a, n)
            } else {
                if ('number' != typeof r)
                    throw new TypeError('expected number');
                if (_ === r)
                    return;
                e[n] = r
            }
            l.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender()
        }
        getParameter(n) {
            n = Math.floor(+n);
            const r = t.get(this)
              , i = r.GetInstanceEffectList()
              , l = i.GetEffectParametersForIndex(this.index);
            if (0 > n || n >= l.length)
                throw new RangeError('invalid effect parameter index');
            const e = l[n];
            return e instanceof C3.Color ? [e.getR(), e.getG(), e.getB()] : e
        }
    }
}
'use strict',
C3.Plugins = {},
C3.Behaviors = {},
C3.PluginManager = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e,
        this._allPlugins = [],
        this._pluginsByCtor = new Map,
        this._systemPlugin = null,
        this._allBehaviors = [],
        this._behaviorsByCtor = new Map,
        this._solidBehavior = null,
        this._jumpthruBehavior = null
    }
    CreatePlugin(e) {
        const t = this._runtime.GetObjectReference(e[0]);
        if (!t)
            throw new Error('missing plugin');
        C3.AddCommonACEs(e, t);
        const a = C3.New(t, {
            runtime: this._runtime,
            isSingleGlobal: e[1],
            isWorld: e[2],
            isRotatable: e[5],
            hasEffects: e[8],
            mustPredraw: e[9]
        });
        a.OnCreate(),
        this._allPlugins.push(a),
        this._pluginsByCtor.set(t, a)
    }
    CreateSystemPlugin() {
        this._systemPlugin = C3.New(C3.Plugins.System, {
            runtime: this._runtime,
            isSingleGlobal: !0
        }),
        this._systemPlugin.OnCreate()
    }
    CreateBehavior(e) {
        const t = this._runtime.GetObjectReference(e[1]);
        if (!t)
            throw new Error('missing behavior');
        const a = C3.New(t, {
            runtime: this._runtime
        });
        a.OnCreate(),
        this._allBehaviors.push(a),
        this._behaviorsByCtor.set(t, a),
        !this._solidBehavior && C3.Behaviors.solid && a instanceof C3.Behaviors.solid ? this._solidBehavior = a : !this._jumpthruBehavior && C3.Behaviors.jumpthru && a instanceof C3.Behaviors.jumpthru && (this._jumpthruBehavior = a)
    }
    GetPluginByConstructorFunction(e) {
        return this._pluginsByCtor.get(e) || null
    }
    HasBehaviorByConstructorFunction(e) {
        return this._behaviorsByCtor.has(e)
    }
    GetBehaviorByConstructorFunction(e) {
        return this._behaviorsByCtor.get(e) || null
    }
    GetSystemPlugin() {
        return this._systemPlugin
    }
    GetSolidBehavior() {
        return this._solidBehavior
    }
    GetJumpthruBehavior() {
        return this._jumpthruBehavior
    }
}
,
'use strict';
{
    const e = new Set;
    C3.ImageInfo = class extends C3.DefendedBase {
        constructor() {
            super(),
            this._url = '',
            this._size = 0,
            this._pixelFormat = 0,
            this._offsetX = 0,
            this._offsetY = 0,
            this._width = 0,
            this._height = 0,
            this._hasMetaData = !1,
            this._imageAsset = null,
            this._textureState = '',
            this._rcTex = C3.New(C3.Rect),
            e.add(this)
        }
        Release() {
            this.ReleaseTexture(),
            this._imageAsset = null,
            e.delete(this)
        }
        static OnWebGLContextLost() {
            for (const t of e)
                t._textureState = '',
                t._rcTex.set(0, 0, 0, 0)
        }
        LoadData(e) {
            this._url = e[0],
            this._size = e[1],
            this._pixelFormat = e[2],
            this._offsetX = e[3],
            this._offsetY = e[4],
            this._width = e[5],
            this._height = e[6],
            this._hasMetaData = !0
        }
        LoadAnimationFrameData(e) {
            this._url = e[0],
            this._size = e[1],
            this._offsetX = e[2],
            this._offsetY = e[3],
            this._width = e[4],
            this._height = e[5],
            this._pixelFormat = e[11],
            this._hasMetaData = !0
        }
        LoadDynamicAsset(e, t) {
            if (this._imageAsset)
                throw new Error('already loaded asset');
            this._url = t;
            const a = {};
            return C3.IsAbsoluteURL(t) && (a.loadPolicy = 'remote'),
            this.LoadAsset(e, a),
            this._imageAsset.Load()
        }
        ReplaceWith(e) {
            if (e === this)
                throw new Error('cannot replace with self');
            this.ReleaseTexture(),
            this._url = e._url,
            this._size = e._size,
            this._pixelFormat = e._pixelFormat,
            this._offsetX = e._offsetX,
            this._offsetY = e._offsetY,
            this._width = e._width,
            this._height = e._height,
            this._hasMetaData = e._hasMetaData,
            this._imageAsset = e._imageAsset,
            this._textureState = e._textureState,
            this._rcTex = e._rcTex
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        GetPixelFormat() {
            return this._pixelFormat
        }
        GetOffsetX() {
            return this._offsetX
        }
        GetOffsetY() {
            return this._offsetY
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetSheetWidth() {
            return this._imageAsset.GetWidth()
        }
        GetSheetHeight() {
            return this._imageAsset.GetHeight()
        }
        LoadAsset(e, t) {
            if (this._imageAsset)
                throw new Error('already got asset');
            t = Object.assign({}, t, {
                url: this.GetURL(),
                size: this.GetSize()
            }),
            this._imageAsset = e.LoadImage(t)
        }
        IsLoaded() {
            return this._imageAsset && this._imageAsset.IsLoaded()
        }
        async LoadStaticTexture(e, t) {
            if (!this._imageAsset)
                throw new Error('no asset');
            if (this._textureState)
                throw new Error('already loaded texture');
            this._textureState = 'loading';
            const a = await this._imageAsset.LoadStaticTexture(e, t);
            return a ? (this._textureState = 'loaded',
            this._hasMetaData || (this._width = a.GetWidth(),
            this._height = a.GetHeight(),
            this._hasMetaData = !0),
            this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + this._width, this._offsetY + this._height),
            this._rcTex.divide(a.GetWidth(), a.GetHeight()),
            a) : (this._textureState = '',
            null)
        }
        ReleaseTexture() {
            this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(),
            this._textureState = '',
            this._rcTex.set(0, 0, 0, 0))
        }
        GetTexture() {
            return this._imageAsset ? this._imageAsset.GetTexture() : null
        }
        GetTexRect() {
            return this._rcTex
        }
        async ExtractImageToCanvas() {
            const e = await this._imageAsset.LoadToDrawable()
              , t = C3.CreateCanvas(this._width, this._height)
              , a = t.getContext('2d');
            return a.drawImage(e, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height),
            t
        }
    }
}
'use strict',
C3.AnimationInfo = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._name = e[0],
        this._speed = e[1],
        this._isLooping = !!e[2],
        this._repeatCount = e[3],
        this._repeatTo = e[4],
        this._isPingPong = !!e[5],
        this._sid = e[6],
        this._frames = e[7].map(e=>C3.New(C3.AnimationFrameInfo, e))
    }
    Release() {
        for (const e of this._frames)
            e.Release();
        C3.clearArray(this._frames)
    }
    LoadAllAssets(e) {
        for (const t of this._frames)
            t.GetImageInfo().LoadAsset(e)
    }
    LoadAllTextures(e, t) {
        return Promise.all(this._frames.map(a=>a.GetImageInfo().LoadStaticTexture(e, t)))
    }
    ReleaseAllTextures() {
        for (const e of this._frames)
            e.GetImageInfo().ReleaseTexture()
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetFrameCount() {
        return this._frames.length
    }
    GetFrames() {
        return this._frames
    }
    GetFrameAt(e) {
        if (e = Math.floor(e),
        0 > e || e >= this._frames.length)
            throw new RangeError('invalid frame');
        return this._frames[e]
    }
    GetSpeed() {
        return this._speed
    }
    IsLooping() {
        return this._isLooping
    }
    GetRepeatCount() {
        return this._repeatCount
    }
    GetRepeatTo() {
        return this._repeatTo
    }
    IsPingPong() {
        return this._isPingPong
    }
}
,
'use strict',
C3.AnimationFrameInfo = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._imageInfo = C3.New(C3.ImageInfo),
        this._imageInfo.LoadAnimationFrameData(e),
        this._duration = e[6],
        this._origin = C3.New(C3.Vector2, e[7], e[8]),
        this._imagePoints = e[9].map(e=>C3.New(C3.ImagePoint, this, e)),
        this._imagePointsByName = new Map;
        for (const t of this._imagePoints)
            this._imagePointsByName.set(t.GetName().toLowerCase(), t);
        this._collisionPoly = null;
        const t = e[10];
        6 <= t.length && (this._collisionPoly = C3.New(C3.CollisionPoly, t))
    }
    Release() {
        this._collisionPoly && (this._collisionPoly.Release(),
        this._collisionPoly = null),
        this._imageInfo.Release(),
        this._imageInfo = null
    }
    GetImageInfo() {
        return this._imageInfo
    }
    GetDuration() {
        return this._duration
    }
    GetOriginX() {
        return this._origin.getX()
    }
    GetOriginY() {
        return this._origin.getY()
    }
    GetCollisionPoly() {
        return this._collisionPoly
    }
    GetImagePointByName(e) {
        return this._imagePointsByName.get(e.toLowerCase()) || null
    }
    GetImagePointByIndex(e) {
        return e = Math.floor(e),
        0 > e || e >= this._imagePoints.length ? null : this._imagePoints[e]
    }
    GetImagePointCount() {
        return this._imagePoints.length
    }
}
,
'use strict',
C3.ImagePoint = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._afi = e,
        this._name = t[0],
        this._pos = C3.New(C3.Vector2, t[1], t[2])
    }
    Release() {}
    GetName() {
        return this._name
    }
    GetX() {
        return this._pos.getX()
    }
    GetY() {
        return this._pos.getY()
    }
    GetVec2() {
        return this._pos
    }
}
,
'use strict',
C3.ObjectClass = class extends C3.DefendedBase {
    constructor(t, a, n) {
        super();
        const r = t.GetObjectReference(n[1]);
        if (this._runtime = t,
        this._plugin = t.GetPluginManager().GetPluginByConstructorFunction(r),
        this._sdkType = null,
        this._instSdkCtor = r.Instance,
        this._index = a,
        this._sid = n[11],
        this._name = n[0],
        this._jsPropName = this._runtime.GetJsPropName(n[14]),
        this._isGlobal = !!n[9],
        this._isFamily = !!n[2],
        this._isOnLoaderLayout = !!n[10],
        this._instVars = n[3].map(e=>({
            sid: e[0],
            type: e[1],
            name: e[2],
            jsPropName: t.GetJsPropName(e[3])
        })),
        this._behaviorsCount = n[4],
        this._effectsCount = n[5],
        this._isWorldType = this._plugin.IsWorldType(),
        this._effectList = null,
        this._collisionGrid = C3.New(C3.SparseGrid, t.GetOriginalViewportWidth(), t.GetOriginalViewportHeight()),
        this._anyCollisionCellChanged = !0,
        this._anyInstanceParallaxed = !1,
        this._familyMembers = null,
        this._familyMembersSet = null,
        this._familyIndex = -1,
        this._families = null,
        this._familiesSet = null,
        this._familyInstVarMap = null,
        this._familyBehaviorMap = null,
        this._familyEffectMap = null,
        this._isInContainer = !1,
        this._container = null,
        this._behaviorTypes = n[8].map(e=>C3.BehaviorType.Create(this, e)),
        this._behaviorTypesIncludingInherited = [],
        this._behaviorsByName = new Map,
        this._behaviorNameToIndex = new Map,
        this._usedBehaviorCtors = new Set,
        this._solStack = C3.New(C3.SolStack, this),
        this._defaultInstanceData = null,
        this._defaultLayerIndex = 0,
        this._isContained = !1,
        this._container = null,
        this._imageInfo = null,
        this._animations = null,
        this._animationsByName = null,
        this._animationsBySid = null,
        this._textureRefCount = 0,
        this._savedData = new Map,
        this._unsavedData = new Map,
        this._instances = [],
        this._iidsStale = !0,
        this._plugin.HasEffects() && (this._effectList = C3.New(C3.EffectList, this, n[12])),
        n[6] && (this._imageInfo = C3.New(C3.ImageInfo),
        this._imageInfo.LoadData(n[6])),
        n[7]) {
            this._animations = n[7].map(e=>C3.New(C3.AnimationInfo, e)),
            this._animationsByName = new Map,
            this._animationsBySid = new Map;
            for (const e of this._animations)
                this._animationsByName.set(e.GetName().toLowerCase(), e),
                this._animationsBySid.set(e.GetSID(), e)
        }
        this._isFamily ? (this._familyMembers = [],
        this._familyMembersSet = new Set,
        this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [],
        this._familiesSet = new Set,
        this._familyInstVarMap = [],
        this._familyBehaviorMap = [],
        this._familyEffectMap = []),
        this._sdkType = C3.New(r.Type, this),
        this._iObjectClass = null,
        this._instanceUserScriptClass = null;
        const i = this._sdkType.GetScriptInterfaceClass();
        if (!i)
            this._iObjectClass = new IObjectClass(this);
        else if (this._iObjectClass = new i(this),
        !(this._iObjectClass instanceof IObjectClass))
            throw new TypeError('script interface class must derive from IObjectClass');
        n[13] && n[13].length && this._sdkType.LoadTilePolyData(n[13]),
        (!this._runtime.UsesLoaderLayout() || this._isFamily || this._isOnLoaderLayout || !this._isWorldType) && this.OnCreate(),
        this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this),
        this._CreateSingleGlobalInstance(n))
    }
    static Create(e, t, a) {
        return C3.New(C3.ObjectClass, e, t, a)
    }
    Release() {
        if (this._imageInfo && (this._imageInfo.Release(),
        this._imageInfo = null),
        this._animations) {
            for (const e of this._animations)
                e.Release();
            C3.clearArray(this._animations),
            this._animationsByName.clear(),
            this._animationsBySid.clear()
        }
        this._solStack.Release(),
        this._solStack = null,
        this._savedData.clear(),
        this._unsavedData.clear(),
        this._container = null,
        this._runtime = null
    }
    _LoadFamily(e) {
        for (let t = 1, a = e.length; t < a; ++t) {
            const a = this._runtime.GetObjectClassByIndex(e[t]);
            this._familyMembers.push(a),
            this._familyMembersSet.add(a),
            a._families.push(this),
            a._familiesSet.add(this)
        }
    }
    _SetContainer(e) {
        this._isInContainer = !0,
        this._container = e
    }
    IsInContainer() {
        return this._isInContainer
    }
    GetContainer() {
        return this._container
    }
    _OnAfterCreate() {
        let e = 0;
        if (!this._isFamily)
            for (const t of this._families)
                for (const a of t.GetBehaviorTypes()) {
                    const t = a.GetName().toLowerCase();
                    this._behaviorsByName.set(t, a),
                    this._behaviorNameToIndex.set(t, e),
                    this._behaviorTypesIncludingInherited.push(a),
                    ++e
                }
        for (const t of this.GetBehaviorTypes()) {
            const a = t.GetName().toLowerCase();
            this._behaviorsByName.set(a, t),
            this._behaviorNameToIndex.set(a, e),
            this._behaviorTypesIncludingInherited.push(t),
            ++e
        }
        for (const e of this._behaviorTypesIncludingInherited)
            this._usedBehaviorCtors.add(e.GetBehavior().constructor);
        if (!this._isFamily && this._families.length) {
            const t = this._runtime.GetFamilyCount();
            C3.extendArray(this._familyInstVarMap, t, 0),
            C3.extendArray(this._familyBehaviorMap, t, 0),
            C3.extendArray(this._familyEffectMap, t, 0);
            const n = [];
            let r = 0
              , i = 0
              , l = 0;
            for (const e of this._families) {
                const t = e.GetFamilyIndex();
                this._familyInstVarMap[t] = r,
                r += e.GetInstanceVariablesCount(),
                this._familyBehaviorMap[t] = i,
                i += e.GetBehaviorTypesCount(),
                this._familyEffectMap[t] = l,
                l += e.GetEffectTypesCount();
                const _ = e.GetEffectList();
                if (_ && this._effectList)
                    for (const e of _.GetAllEffectTypes())
                        n.push(e.Clone(this._effectList))
            }
            this._effectList && this._effectList.PrependEffectTypes(n)
        }
    }
    _CreateSingleGlobalInstance(e) {
        const t = this._runtime._GetNewUID()
          , a = C3.New(C3.Instance, {
            runtime: this._runtime,
            objectType: this,
            uid: t
        });
        a._CreateSdkInstance(e[15], []),
        this._runtime._MapInstanceByUID(t, a),
        this._instances.push(a)
    }
    GetSdkType() {
        return this._sdkType
    }
    IsOnLoaderLayout() {
        return this._isOnLoaderLayout
    }
    OnCreate() {
        this._isFamily || this._sdkType.OnCreate()
    }
    HasLoadedTextures() {
        return 0 < this._textureRefCount
    }
    LoadTextures(e) {
        return this._isFamily ? Promise.resolve() : (this._textureRefCount++,
        1 === this._textureRefCount ? this._sdkType.LoadTextures(e) || Promise.resolve() : Promise.resolve())
    }
    ReleaseTextures() {
        if (!this._isFamily) {
            if (this._textureRefCount--,
            0 > this._textureRefCount)
                throw new Error('released textures too many times');
            0 === this._textureRefCount && this._sdkType.ReleaseTextures()
        }
    }
    OnDynamicTextureLoadComplete() {
        if (this._isFamily)
            throw new Error('not applicable to family');
        this._sdkType.OnDynamicTextureLoadComplete()
    }
    PreloadTexturesWithInstances(e) {
        return this._isFamily ? Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(e)
    }
    GetRuntime() {
        return this._runtime
    }
    GetPlugin() {
        return this._plugin
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetJsPropName() {
        return this._jsPropName
    }
    GetIndex() {
        return this._index
    }
    GetSID() {
        return this._sid
    }
    IsFamily() {
        return this._isFamily
    }
    IsGlobal() {
        return this._isGlobal
    }
    IsWorldType() {
        return this._isWorldType
    }
    GetFamilyIndex() {
        return this._familyIndex
    }
    GetBehaviorTypes() {
        return this._behaviorTypes
    }
    GetBehaviorTypesCount() {
        return this._behaviorsCount
    }
    UsesBehaviorByCtor(e) {
        return e && this._usedBehaviorCtors.has(e)
    }
    GetInstanceVariablesCount() {
        return this._instVars.length
    }
    GetInstanceVariableSIDs() {
        return this._instVars.map(e=>e.sid)
    }
    GetInstanceVariableIndexBySID(e) {
        return this._instVars.findIndex(t=>t.sid === e)
    }
    GetInstanceVariableIndexByName(e) {
        return this._instVars.findIndex(t=>t.name === e)
    }
    _GetAllInstanceVariableNames() {
        return this._instVars.map(e=>e.name)
    }
    _GetAllInstanceVariableJsPropNames() {
        return this._instVars.map(e=>e.jsPropName)
    }
    GetInstanceVariableType(e) {
        if (e = Math.floor(e),
        0 > e || e >= this._instVars.length)
            throw new RangeError('invalid instance variable index');
        return this._instVars[e].type
    }
    GetInstanceVariableName(e) {
        if (e = Math.floor(e),
        0 > e || e >= this._instVars.length)
            throw new RangeError('invalid instance variable index');
        return this._instVars[e].name
    }
    GetEffectTypesCount() {
        return this._effectsCount
    }
    GetBehaviorTypesIncludingInherited() {
        return this._behaviorTypesIncludingInherited
    }
    GetBehaviorTypeByName(e) {
        return this._behaviorsByName.get(e.toLowerCase()) || null
    }
    GetBehaviorIndexByName(e) {
        const t = this._behaviorNameToIndex.get(e.toLowerCase());
        return 'undefined' == typeof t ? -1 : t
    }
    GetEffectList() {
        return this._effectList
    }
    HasEffects() {
        return this._plugin.HasEffects()
    }
    UsesEffects() {
        return this._effectList && this._effectList.HasAnyEffectType()
    }
    GetSolStack() {
        return this._solStack
    }
    GetCurrentSol() {
        return this._solStack.GetCurrentSol()
    }
    GetImageInfo() {
        return this._imageInfo
    }
    SetDefaultInstanceData(e) {
        this._defaultInstanceData = e
    }
    GetDefaultInstanceData() {
        return this._defaultInstanceData
    }
    _SetDefaultLayerIndex(e) {
        this._defaultLayerIndex = e
    }
    GetDefaultLayerIndex() {
        return this._defaultLayerIndex
    }
    GetAnimations() {
        return this._animations
    }
    GetAnimationCount() {
        return this._animations.length
    }
    GetFamilies() {
        return this._families
    }
    BelongsToFamily(e) {
        return this._familiesSet.has(e)
    }
    GetFamilyMembers() {
        return this._familyMembers
    }
    FamilyHasMember(e) {
        return this._familyMembersSet.has(e)
    }
    GetFamilyBehaviorOffset(e) {
        return this._familyBehaviorMap[e]
    }
    GetFamilyInstanceVariableOffset(e) {
        return this._familyInstVarMap[e]
    }
    GetAnimationByName(e) {
        if (!this._animations)
            throw new Error('no animations');
        return this._animationsByName.get(e.toLowerCase()) || null
    }
    GetAnimationBySID(e) {
        if (!this._animations)
            throw new Error('no animations');
        return this._animationsBySid.get(e) || null
    }
    GetFirstAnimationFrame() {
        if (!this._animations)
            throw new Error('no animations');
        return this._animations[0].GetFrameAt(0)
    }
    GetDefaultInstanceSize() {
        if (this._animations) {
            const e = this.GetFirstAnimationFrame().GetImageInfo();
            return [e.GetWidth(), e.GetHeight()]
        }
        return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
    }
    GetSingleGlobalInstance() {
        if (!this._plugin.IsSingleGlobal())
            throw new Error('not a single-global plugin');
        return this._instances[0]
    }
    GetInstances() {
        return this._instances
    }
    *instances() {
        yield*this._instances
    }
    *instancesIncludingPendingCreate() {
        yield*this._instances;
        for (const e of this._runtime._GetInstancesPendingCreate())
            e.GetObjectClass() === this && (yield e)
    }
    GetInstanceCount() {
        return this._instances.length
    }
    _AddInstance(e) {
        this._instances.push(e)
    }
    _SetIIDsStale() {
        this._iidsStale = !0
    }
    _UpdateIIDs() {
        if (this._iidsStale && !this._isFamily) {
            const e = this._instances;
            let t = 0;
            for (let a = e.length; t < a; ++t)
                e[t]._SetIID(t);
            const n = this._runtime._GetInstancesPendingCreate();
            for (const e of n)
                e.GetObjectClass() === this && e._SetIID(t++);
            this._iidsStale = !1
        }
    }
    GetInstanceByIID(e) {
        const t = this._instances;
        if (e < t.length)
            return t[e];
        e -= t.length;
        const n = this._runtime._GetInstancesPendingCreate();
        for (const t of n)
            if (t.GetObjectClass() === this) {
                if (0 === e)
                    return t;
                --e
            }
        return null
    }
    GetFirstPicked(e) {
        if (e && e.IsInContainer() && e.GetObjectClass() !== this)
            for (const t of e.siblings())
                if (t.GetObjectClass() === this)
                    return t;
        const t = this.GetCurrentSol().GetInstances();
        return t.length ? t[0] : null
    }
    GetPairedInstance(e) {
        const t = this.GetCurrentSol().GetInstances();
        return t.length ? t[e.GetIID() % t.length] : null
    }
    FinishCondition(e) {
        this._sdkType.FinishCondition(e)
    }
    ApplySolToContainer() {
        if (this._isInContainer && !this._isFamily) {
            this._UpdateIIDs();
            const t = this.GetCurrentSol()
              , n = t._GetOwnInstances()
              , a = t.IsSelectAll()
              , r = this._runtime.GetCurrentEventStackFrame()
              , i = r && r.GetCurrentEvent() && r.GetCurrentEvent().IsOrBlock();
            for (const e of this._container.objectTypes()) {
                if (e === this)
                    continue;
                e._UpdateIIDs();
                const r = e.GetCurrentSol();
                if (r._SetSelectAll(a),
                !a) {
                    const l = r._GetOwnInstances();
                    C3.clearArray(l);
                    for (const t of n)
                        l.push(e.GetInstanceByIID(t.GetIID()));
                    if (i) {
                        const n = t._GetOwnElseInstances()
                          , i = r._GetOwnElseInstances();
                        C3.clearArray(i);
                        for (const t of n)
                            i.push(e.GetInstanceByIID(t.GetIID()))
                    }
                }
            }
        }
    }
    _TruncateContainerSols(e, t) {
        for (const a of this.GetContainer().objectTypes()) {
            const n = a.GetCurrentSol();
            e ? C3.truncateArray(n._GetOwnElseInstances(), t) : C3.truncateArray(n._GetOwnInstances(), t)
        }
    }
    _GetCollisionCellGrid() {
        return this._collisionGrid
    }
    _SetAnyCollisionCellChanged(e) {
        this._anyCollisionCellChanged = !!e
    }
    _SetAnyInstanceParallaxed(e) {
        this._anyInstanceParallaxed = !!e
    }
    IsAnyInstanceParallaxed() {
        return this._anyInstanceParallaxed
    }
    _UpdateAllCollisionCells() {
        if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const e of this._instances)
                e.GetWorldInfo()._UpdateCollisionCell();
            for (const e of this._runtime._GetInstancesPendingCreate())
                e.GetObjectClass() === this && e.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = !1
        }
    }
    GetSavedDataMap() {
        return this._savedData || (this._savedData = new Map),
        this._savedData
    }
    GetUnsavedDataMap() {
        return this._unsavedData || (this._unsavedData = new Map),
        this._unsavedData
    }
    HasSolidBehavior() {
        return this.UsesBehaviorByCtor(C3.Behaviors.solid)
    }
    HasNoSaveBehavior() {
        return this.UsesBehaviorByCtor(C3.Behaviors.NoSave)
    }
    HasPersistBehavior() {
        return this.UsesBehaviorByCtor(C3.Behaviors.Persist)
    }
    _SaveToJson() {
        const e = {
            instances: this._instances.map(e=>e.SaveToJson())
        };
        return this._savedData && this._savedData.size && (e.ex = C3.ToSuperJSON(this._savedData)),
        e
    }
    _LoadFromJson(e) {
        this._savedData && (this._savedData.clear(),
        this._savedData = null);
        const t = e.ex;
        t && (this._savedData = C3.FromSuperJSON(t));
        const a = this._instances
          , n = e.instances;
        for (let t = 0, r = Math.min(a.length, n.length); t < r; ++t)
            a[t].LoadFromJson(n[t]);
        for (let t = n.length, r = a.length; t < r; ++t)
            this._runtime.DestroyInstance(a[t]);
        for (let t = a.length, r = n.length; t < r; ++t) {
            const r = n[t];
            let a = null;
            if (this.IsWorldType() && (a = this._runtime.GetMainRunningLayout().GetLayerBySID(r.w.l),
            !a))
                continue;
            const i = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, a, !1, 0, 0, !0);
            i.LoadFromJson(r)
        }
        this._SetIIDsStale()
    }
    GetIObjectClass() {
        return this._iObjectClass
    }
    _GetUserScriptInstanceClass() {
        return this._instanceUserScriptClass
    }
    _SetUserScriptInstanceClass(e) {
        this._instanceUserScriptClass = e
    }
}
,
'use strict',
C3.Container = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._runtime = e,
        this._objectTypes = t;
        for (const a of this._objectTypes)
            a._SetContainer(this)
    }
    Release() {
        this._runtime = null
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectTypes() {
        return this._objectTypes
    }
    objectTypes() {
        return this._objectTypes
    }
    HasAnyWorldType() {
        return this._objectTypes.some(e=>e.IsWorldType())
    }
}
,
'use strict';
{
    const t = [];
    let a = 0;
    const n = new WeakMap
      , e = new WeakMap;
    C3.Instance = class extends C3.DefendedBase {
        constructor(n) {
            super(),
            this._runtime = n.runtime,
            this._objectType = n.objectType,
            this._worldInfo = null,
            this._sdkInst = null,
            this._iScriptInterface = null,
            this._iid = 0,
            this._uid = n.uid,
            this._puid = a++,
            this._flags = 0,
            this._instVarValues = t,
            this._behaviorInstances = t;
            const r = this._objectType.GetBehaviorTypesIncludingInherited();
            0 < r.length && (this._behaviorInstances = r.map((e,t)=>C3.New(C3.BehaviorInstance, {
                runtime: this._runtime,
                behaviorType: e,
                instance: this,
                index: t
            }))),
            this._siblings = this._objectType.IsInContainer() ? [] : null,
            this._timeScale = -1,
            this._dispatcher = null;
            const i = this.GetPlugin();
            if (i.MustPreDraw() && (this._flags |= 4),
            i.IsWorldType())
                if (this._worldInfo = C3.New(C3.WorldInfo, this, n.layer),
                n.worldData)
                    this._worldInfo.Init(n.worldData);
                else {
                    this._worldInfo.InitNoData();
                    const [e,t] = this._objectType.GetDefaultInstanceSize();
                    this._worldInfo.SetSize(e, t),
                    this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
                }
            n.instVarData ? this._LoadInstanceVariableData(n.instVarData) : this._LoadDefaultInstanceVariables()
        }
        Release() {
            if (this._iScriptInterface && (this._iScriptInterface._Release(),
            this._iScriptInterface = null),
            0 < this._behaviorInstances.length) {
                for (const e of this._behaviorInstances)
                    e.Release();
                C3.clearArray(this._behaviorInstances)
            }
            this._sdkInst.Release(),
            this._sdkInst = null;
            const t = n.get(this);
            t && (t.clear(),
            n.delete(this));
            const a = e.get(this);
            a && (a.clear(),
            e.delete(this)),
            this._siblings && C3.clearArray(this._siblings),
            this._dispatcher && (this._dispatcher.Release(),
            this._dispatcher = null),
            this._runtime = null,
            this._objectType = null,
            0 < this._instVarValues.length && C3.clearArray(this._instVarValues),
            this._worldInfo && (this._worldInfo.Release(),
            this._worldInfo = null)
        }
        _LoadInstanceVariableData(e) {
            0 < e.length && (this._instVarValues = [],
            C3.shallowAssignArray(this._instVarValues, e))
        }
        _LoadDefaultInstanceVariables() {
            const e = this._objectType.GetInstanceVariablesCount();
            if (0 !== e) {
                this._instVarValues = [];
                const t = [0, 0, ''];
                for (let a = 0; a < e; ++a)
                    this._instVarValues.push(t[this._objectType.GetInstanceVariableType(a)])
            }
        }
        _CreateSdkInstance(e, t) {
            if (this._sdkInst)
                throw new Error('already got sdk instance');
            for (let n = 0, a = this._behaviorInstances.length; n < a; ++n) {
                const e = this._behaviorInstances[n];
                e._CreateSdkInstance(t ? t[n] : null)
            }
            if (this._sdkInst = C3.New(this._objectType.GetInstanceSdkCtor(), this, e),
            !(this._sdkInst instanceof C3.SDKInstanceBase))
                throw new Error('sdk type must derive from SDKInstanceBase');
            for (let a = 0, n = this._behaviorInstances.length; a < n; ++a)
                this._behaviorInstances[a].PostCreate();
            this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetWorldInfo() {
            return this._worldInfo
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(e) {
            e = +e,
            (0 > e || !isFinite(e)) && (e = 0),
            this._timeScale = e
        }
        RestoreTimeScale() {
            this._timeScale = -1
        }
        Dispatcher() {
            return this._dispatcher || (this._dispatcher = C3.New(C3.Event.Dispatcher)),
            this._dispatcher
        }
        Draw(e) {
            this._sdkInst.Draw(e)
        }
        OnCreate(e) {
            this._sdkInst.OnCreate(e)
        }
        _SetHasTilemap() {
            this._flags |= 2
        }
        HasTilemap() {
            return 0 != (2 & this._flags)
        }
        _MarkDestroyed() {
            this._flags |= 1
        }
        IsDestroyed() {
            return 0 != (1 & this._flags)
        }
        MustPreDraw() {
            return 0 != (4 & this._flags)
        }
        _IsSolidEnabled() {
            return 0 != (8 & this._flags)
        }
        _SetSolidEnabled(e) {
            e ? this._flags |= 8 : this._flags &= -9
        }
        _IsJumpthruEnabled() {
            return 0 != (16 & this._flags)
        }
        _SetJumpthruEnabled(e) {
            e ? this._flags |= 16 : this._flags &= -17
        }
        SetFlag(e, t) {
            e <<= 16,
            t ? this._flags |= e : this._flags &= ~e
        }
        GetFlag(e) {
            return 0 != (this._flags & e << 16)
        }
        GetCurrentImageInfo() {
            return this._sdkInst.GetCurrentImageInfo()
        }
        GetImagePoint(e) {
            return this._sdkInst.GetImagePoint(e)
        }
        GetObjectClass() {
            return this._objectType
        }
        BelongsToObjectClass(e) {
            return e.IsFamily() ? e.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === e
        }
        IsInContainer() {
            return null !== this._siblings
        }
        _AddSibling(e) {
            this._siblings.push(e)
        }
        GetSiblings() {
            return this._siblings
        }
        siblings() {
            return this._siblings
        }
        SetSiblingsSinglePicked() {
            for (const e of this.siblings())
                e.GetObjectClass().GetCurrentSol().SetSinglePicked(e)
        }
        _PushSiblingsToSolInstances() {
            for (const e of this.siblings())
                e.GetObjectClass().GetCurrentSol()._PushInstance(e)
        }
        _SetSiblingsToSolInstancesIndex(e) {
            for (const t of this.siblings())
                t.GetObjectClass().GetCurrentSol()._GetOwnInstances()[e] = t
        }
        _PushSiblingsToSolElseInstances() {
            for (const e of this.siblings())
                e.GetObjectClass().GetCurrentSol()._PushElseInstance(e)
        }
        _SetSiblingsToSolElseInstancesIndex(e) {
            for (const t of this.siblings())
                t.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[e] = t
        }
        GetPlugin() {
            return this._objectType.GetPlugin()
        }
        _SetIID(e) {
            this._iid = e
        }
        GetIID() {
            return this._objectType._UpdateIIDs(),
            this._iid
        }
        GetUID() {
            return this._uid
        }
        GetPUID() {
            return this._puid
        }
        GetBehaviorInstances() {
            return this._behaviorInstances
        }
        GetBehaviorInstanceFromCtor(e) {
            if (!e)
                return null;
            for (const t of this._behaviorInstances)
                if (t.GetBehavior()instanceof e)
                    return t;
            return null
        }
        GetBehaviorSdkInstanceFromCtor(e) {
            if (!e)
                return null;
            const t = this.GetBehaviorInstanceFromCtor(e);
            return t ? t.GetSdkInstance() : null
        }
        GetBehaviorIndexBySID(e) {
            const t = this._behaviorInstances;
            for (let a = 0, n = t.length; a < n; ++a)
                if (t[a].GetBehaviorType().GetSID() === e)
                    return a;
            return -1
        }
        GetAllInstanceVariableValues() {
            return this._instVarValues
        }
        _GetAllInstanceVariableNames() {
            return this._objectType._GetAllInstanceVariableNames()
        }
        GetInstanceVariableCount() {
            return this._instVarValues.length
        }
        GetInstanceVariableValue(e) {
            e |= 0;
            const t = this._instVarValues;
            if (0 > e || e >= t.length)
                throw new RangeError('invalid instance variable');
            return t[e]
        }
        _GetInstanceVariableValueUnchecked(e) {
            return this._instVarValues[e]
        }
        SetInstanceVariableValue(e, t) {
            e |= 0;
            const n = this._instVarValues;
            if (0 > e || e >= n.length)
                throw new RangeError('invalid instance variable');
            const r = n[e];
            if ('number' == typeof r)
                n[e] = 'number' == typeof t ? t : parseFloat(t);
            else if ('boolean' == typeof r)
                n[e] = 'boolean' == typeof t ? t : !!t;
            else if ('string' == typeof r)
                n[e] = 'string' == typeof t ? t : t.toString();
            else
                throw new Error('unknown instance variable type')
        }
        SetInstanceVariableOffset(e, t) {
            if (0 !== t) {
                e |= 0;
                const a = this._instVarValues;
                if (0 > e || e >= a.length)
                    throw new RangeError('invalid instance variable');
                const n = a[e];
                if ('number' == typeof n)
                    a[e] += 'number' == typeof t ? t : parseFloat(t);
                else if ('boolean' == typeof n)
                    throw new Error('can not set offset of boolean variable');
                else if ('string' == typeof n)
                    throw new Error('can not set offset of string variable');
                else
                    throw new Error('unknown instance variable type')
            }
        }
        GetSavedDataMap() {
            let e = n.get(this);
            return e ? e : (e = new Map,
            n.set(this, e),
            e)
        }
        GetUnsavedDataMap() {
            let t = e.get(this);
            return t ? t : (t = new Map,
            e.set(this, t),
            t)
        }
        _TriggerOnCreated() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
        }
        _TriggerOnDestroyed() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson(e='full') {
            const t = {};
            if ('full' === e ? t.uid = this.GetUID() : t.c3 = !0,
            'visual-state' !== e) {
                const e = n.get(this);
                if (e && e.size && (t.ex = C3.ToSuperJSON(e)),
                -1 !== this.GetTimeScale() && (t.mts = this.GetTimeScale()),
                0 < this._objectType.GetInstanceVariablesCount()) {
                    const e = {}
                      , a = this._objectType.GetInstanceVariableSIDs();
                    for (let t = 0, n = this._instVarValues.length; t < n; ++t)
                        e[a[t].toString()] = this._instVarValues[t];
                    t.ivs = e
                }
                if (this._behaviorInstances.length) {
                    const e = {};
                    for (const t of this._behaviorInstances) {
                        const a = t.SaveToJson();
                        a && (e[t.GetBehaviorType().GetSID().toString()] = a)
                    }
                    t.behs = e
                }
            }
            this._worldInfo && (t.w = this._worldInfo._SaveToJson());
            const a = this._sdkInst.SaveToJson();
            return a && (t.data = a),
            t
        }
        LoadFromJson(t, e='full') {
            if ('full' === e)
                this._uid = t.uid;
            else if (!t.c3)
                return;
            if ('visual-state' !== e) {
                let a = n.get(this);
                a && (a.clear(),
                n.delete(this));
                const r = t.ex;
                r && (a = C3.FromSuperJSON(r),
                n.set(this, a)),
                this._timeScale = t.hasOwnProperty('mts') ? t.mts : -1;
                const i = t.ivs;
                if (i)
                    for (const [t,a] of Object.entries(i)) {
                        const n = parseInt(t, 10)
                          , r = this._objectType.GetInstanceVariableIndexBySID(n);
                        if (0 > r || r >= this._instVarValues.length)
                            continue;
                        let i = a;
                        null === i && (i = NaN),
                        this._instVarValues[r] = i
                    }
            }
            if (this.GetPlugin().IsWorldType()) {
                const a = t.w
                  , n = a.l;
                if (this._worldInfo.GetLayer().GetSID() !== n) {
                    const t = this._worldInfo.GetLayer()
                      , a = t.GetLayout().GetLayerBySID(n);
                    a ? (this._worldInfo._SetLayer(a),
                    t._RemoveInstance(this, !0),
                    a._AddInstance(this, !0),
                    a.SetZIndicesChanged(),
                    this._worldInfo.SetBboxChanged()) : 'full' === e && this._runtime.DestroyInstance(this)
                }
                this._worldInfo._LoadFromJson(a)
            }
            if ('visual-state' !== e) {
                const e = t.behs;
                if (e)
                    for (const [t,a] of Object.entries(e)) {
                        const e = parseInt(t, 10)
                          , n = this.GetBehaviorIndexBySID(e);
                        0 > n || n >= this._behaviorInstances.length || this._behaviorInstances[n].LoadFromJson(a)
                    }
            }
            const a = t.data;
            a && this._sdkInst.LoadFromJson(a)
        }
        GetInterfaceClass() {
            return this._iScriptInterface || this._InitUserScriptInterface()
        }
        _InitUserScriptInterface() {
            const e = this._worldInfo ? IWorldInstance : IInstance
              , t = this._sdkInst.GetScriptInterfaceClass()
              , a = this._objectType._GetUserScriptInstanceClass();
            if (IInstance._Init(this),
            this._iScriptInterface = new (a || t || e),
            IInstance._Init(null),
            t && !(this._iScriptInterface instanceof e))
                throw new TypeError(`script interface class '${t.name}' does not extend the right base class '${e.name}'`);
            if (a) {
                const n = t || e;
                if (!(this._iScriptInterface instanceof n))
                    throw new TypeError(`setInstanceClass(): class '${a.name}' does not extend the right base class '${n.name}'`)
            }
            return this._iScriptInterface
        }
        _GetInstVarsScriptDescriptor(e) {
            if (0 !== this._instVarValues.length) {
                const t = {}
                  , n = this._objectType._GetAllInstanceVariableJsPropNames();
                for (let e = 0, a = n.length; e < a; ++e)
                    t[n[e]] = {
                        configurable: !1,
                        enumerable: !0,
                        get: C3.Instance.prototype._GetInstanceVariableValueUnchecked.bind(this, e),
                        set: C3.Instance.prototype.SetInstanceVariableValue.bind(this, e)
                    };
                const a = Object.create(Object.prototype, t);
                e.instVars = {
                    value: a,
                    writable: !1
                }
            }
        }
        _GetBehaviorsScriptDescriptor(e) {
            const t = this._behaviorInstances;
            if (0 !== t.length) {
                const n = {};
                for (const e of t)
                    n[e.GetBehaviorType().GetJsPropName()] = {
                        value: e.GetScriptInterface(),
                        writable: !1
                    };
                const a = Object.create(Object.prototype, n);
                e.behaviors = {
                    value: a,
                    writable: !1
                }
            }
        }
    }
}
{
    const t = C3.New(C3.Rect)
      , n = C3.New(C3.Rect)
      , a = C3.New(C3.Event, 'bboxchange', !1)
      , r = C3.New(C3.Color, 0, 0, 0, 0)
      , l = C3.New(C3.Color, 1, 1, 1, 1)
      , _ = C3.New(C3.Rect, 0, 0, -1, -1)
      , e = C3.New(C3.Rect, 0, 0, -1, -1);
    let d = !0;
    const u = 1;
    C3.WorldInfo = class extends C3.DefendedBase {
        constructor(t, a) {
            super(),
            this._inst = t,
            this._objectClass = t.GetObjectClass(),
            this._runtime = t.GetRuntime(),
            this._layer = a,
            this._zIndex = -1,
            this._flags = 27,
            this._x = NaN,
            this._y = NaN,
            this._zElevation = NaN,
            this._w = NaN,
            this._h = NaN,
            this._a = NaN,
            this._sinA = NaN,
            this._cosA = NaN,
            this._ox = NaN,
            this._oy = NaN,
            this._boundingBox = C3.New(C3.Rect),
            this._boundingQuad = C3.New(C3.Quad),
            this._collisionCells = e,
            this._renderCells = _,
            this._sourceCollisionPoly = null,
            this._transformedPolyInfo = null,
            this._solidFilterTags = null,
            this._color = l,
            this._colorPremultiplied = l,
            this._blendMode = -1,
            this._stateGroup = null,
            this._instanceEffectList = null,
            this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C3.New(C3.InstanceEffectList, this._inst, this)),
            d = !1,
            this.SetBlendMode(0),
            d = !0
        }
        Release() {
            this._stateGroup && (this._runtime.GetWebGLRenderer().ReleaseStateGroup(this._stateGroup),
            this._stateGroup = null),
            this._sourceCollisionPoly = null,
            this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(),
            this._transformedPolyInfo = null),
            this._solidFilterTags && (this._solidFilterTags.clear(),
            this._solidFilterTags = null),
            this._inst = null,
            this._objectClass = null,
            this._runtime = null,
            this._layer = null
        }
        Init(e) {
            d = !1,
            this.SetXY(e[0], e[1]),
            this.SetZElevation(e[2]),
            this.SetSize(e[3], e[4]),
            this.SetAngle(e[6]),
            r.setFromJSON(e[7]),
            this._SetColor(r),
            this.SetOriginX(e[8]),
            this.SetOriginY(e[9]),
            this.SetBlendMode(e[10]),
            this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(e[12]),
            d = !0,
            this._UpdateWebGLStateGroup()
        }
        InitNoData() {
            this._x = 0,
            this._y = 0,
            this._zElevation = 0,
            this._w = 0,
            this._h = 0,
            this._a = 0,
            this._sinA = 0,
            this._cosA = 1,
            this._ox = 0,
            this._oy = 0,
            this._UpdateWebGLStateGroup()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetInstance() {
            return this._inst
        }
        SetX(e) {
            this._x = +e
        }
        OffsetX(e) {
            this._x += +e
        }
        GetX() {
            return this._x
        }
        SetY(e) {
            this._y = +e
        }
        OffsetY(e) {
            this._y += +e
        }
        GetY() {
            return this._y
        }
        SetXY(e, t) {
            this._x = +e,
            this._y = +t
        }
        OffsetXY(e, t) {
            this._x += +e,
            this._y += +t
        }
        EqualsXY(e, t) {
            return this._x === e && this._y === t
        }
        SetZElevation(e) {
            if (e = +e,
            this._zElevation !== e) {
                this._zElevation = e,
                this._UpdateWebGLStateGroup();
                const t = this.GetLayer();
                0 !== this._zElevation && t._SetAnyInstanceZElevated(),
                t.SetZIndicesChanged()
            }
        }
        OffsetZElevation(e) {
            this.SetZElevation(this.GetZElevation() + e)
        }
        GetZElevation() {
            return this._zElevation
        }
        GetTotalZElevation() {
            return this.GetLayer().GetZElevation() + this.GetZElevation()
        }
        SetWidth(e) {
            this._w = +e
        }
        OffsetWidth(e) {
            this._w += +e
        }
        GetWidth() {
            return this._w
        }
        SetHeight(e) {
            this._h = +e
        }
        OffsetHeight(e) {
            this._h += +e
        }
        GetHeight() {
            return this._h
        }
        SetSize(e, t) {
            this._w = +e,
            this._h = +t
        }
        SetAngle(e) {
            e = C3.clampAngle(+e),
            this._a === e || (this._a = e,
            this._sinA = Math.sin(e),
            this._cosA = Math.cos(e))
        }
        OffsetAngle(e) {
            e = +e,
            0 === e || (this._a = C3.clampAngle(this._a + e),
            this._sinA = Math.sin(this._a),
            this._cosA = Math.cos(this._a))
        }
        GetAngle() {
            return this._a
        }
        GetSinAngle() {
            return this._sinA
        }
        GetCosAngle() {
            return this._cosA
        }
        SetOriginX(e) {
            this._ox = +e
        }
        OffsetOriginX(e) {
            this._ox += +e
        }
        GetOriginX() {
            return this._ox
        }
        SetOriginY(e) {
            this._oy = +e
        }
        OffsetOriginY(e) {
            this._oy += +e
        }
        GetOriginY() {
            return this._oy
        }
        _SetColor(e) {
            this._color.equals(e) || (this._color === l ? (this._color = C3.New(C3.Color, e),
            this._colorPremultiplied = C3.New(C3.Color, e),
            this._colorPremultiplied.premultiply()) : e.equalsRgba(1, 1, 1, 1) ? (this._color = l,
            this._colorPremultiplied = l) : (this._color.set(e),
            this._colorPremultiplied.set(e),
            this._colorPremultiplied.premultiply()),
            this._UpdateWebGLStateGroup())
        }
        SetOpacity(e) {
            e = C3.clamp(+e, 0, 1),
            this._color.a === e || (r.copyRgb(this._color),
            r.a = e,
            this._SetColor(r))
        }
        OffsetOpacity(e) {
            this.SetOpacity(this.GetOpacity() + e)
        }
        GetOpacity() {
            return this._color.a
        }
        SetUnpremultipliedColor(e) {
            this._color.equalsIgnoringAlpha(e) || (r.copyRgb(e),
            r.a = this._color.a,
            this._SetColor(r))
        }
        SetUnpremultipliedColorRGB(t, a, n) {
            r.setRgb(t, a, n),
            this.SetUnpremultipliedColor(r)
        }
        OffsetUnpremultipliedColorRGB(t, a, n) {
            0 === t && 0 === a && 0 === n || (r.copyRgb(this._color),
            r.r += t,
            r.g += a,
            r.b += n,
            this.SetUnpremultipliedColor(r))
        }
        GetUnpremultipliedColor() {
            return this._color
        }
        GetPremultipliedColor() {
            return this._colorPremultiplied
        }
        _UpdateWebGLStateGroup() {
            if (d) {
                const e = this._runtime.GetWebGLRenderer();
                this._stateGroup && e.ReleaseStateGroup(this._stateGroup),
                this._stateGroup = e.AcquireStateGroup(e.GetTextureFillShaderProgram() || '<default>', this.GetSrcBlend(), this.GetDestBlend(), this._colorPremultiplied, this._zElevation)
            }
        }
        GetWebGLStateGroup() {
            return this._stateGroup
        }
        HasDefaultColor() {
            return this._color === l
        }
        SetBlendMode(e) {
            this._blendMode === e || (this._blendMode = e,
            this._UpdateWebGLStateGroup())
        }
        GetBlendMode() {
            return this._blendMode
        }
        GetSrcBlend() {
            return this._runtime.GetWebGLRenderer().GetSrcBlendByIndex(this._blendMode)
        }
        GetDestBlend() {
            return this._runtime.GetWebGLRenderer().GetDestBlendByIndex(this._blendMode)
        }
        _SetLayer(e) {
            this._layer = e,
            0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
        }
        GetLayer() {
            return this._layer
        }
        GetLayout() {
            return this.GetLayer().GetLayout()
        }
        _SetZIndex(e) {
            this._zIndex = 0 | e
        }
        GetZIndex() {
            return this._layer._UpdateZIndices(),
            this._zIndex
        }
        _GetLastCachedZIndex() {
            return this._zIndex
        }
        _SetFlag(e, t) {
            t ? this._flags |= e : this._flags &= ~e
        }
        IsVisible() {
            return 0 != (this._flags & u)
        }
        SetVisible(e) {
            this._SetFlag(u, e)
        }
        IsCollisionEnabled() {
            return 0 != (8 & this._flags)
        }
        SetCollisionEnabled(e) {
            e = !!e,
            this.IsCollisionEnabled() === e || (this._SetFlag(8, e),
            e ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
        }
        SetSolidCollisionFilter(e, t) {
            if (this._SetFlag(32, e),
            this._solidFilterTags && this._solidFilterTags.clear(),
            !t.trim())
                return void (this._solidFilterTags = null);
            this._solidFilterTags || (this._solidFilterTags = new Set);
            for (const a of t.split(' '))
                a && this._solidFilterTags.add(a.toLowerCase())
        }
        IsSolidCollisionAllowed(e) {
            const t = 0 != (32 & this._flags)
              , a = this._solidFilterTags;
            if (!e || !a)
                return !t;
            for (const n of a)
                if (e.has(n))
                    return t;
            return !t
        }
        SetBboxChanged() {
            this._flags |= 18,
            this._objectClass._SetAnyCollisionCellChanged(!0),
            this._runtime.UpdateRender(),
            this._layer.UsesRenderCells() && (this._CalculateBbox(),
            this._UpdateRenderCell()),
            0 != (4 & this._flags) && this._inst.Dispatcher().dispatchEvent(a)
        }
        _CalculateBbox() {
            const t = this._boundingBox
              , a = this._boundingQuad
              , n = this._x
              , r = this._y
              , i = this._w
              , e = this._h;
            t.setWH(n - this._ox * i, r - this._oy * e, i, e),
            0 === this._a ? a.setFromRect(t) : (t.offset(-n, -r),
            a.setFromRotatedRectPrecalc(t, this._sinA, this._cosA),
            a.offset(n, r),
            a.getBoundingBox(t)),
            t.normalize(),
            this._flags &= -3
        }
        _UpdateBbox() {
            0 != (2 & this._flags) && this._CalculateBbox()
        }
        GetBoundingBox() {
            return this._UpdateBbox(),
            this._boundingBox
        }
        GetBoundingQuad() {
            return this._UpdateBbox(),
            this._boundingQuad
        }
        OverwriteBoundingBox(e) {
            this._boundingBox.copy(e),
            this._boundingQuad.setFromRect(this._boundingBox),
            this._flags &= -3,
            this._UpdateCollisionCell(),
            this._UpdateRenderCell()
        }
        SetBboxChangeEventEnabled(e) {
            this._SetFlag(4, e)
        }
        IsBboxChangeEventEnabled() {
            return 0 != (4 & this._flags)
        }
        IsInViewport(e) {
            return 0 === this._zElevation ? e.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
        }
        _IsInViewport_ZElevated() {
            const e = this.GetLayer()
              , t = this.GetTotalZElevation();
            return !(t >= e.GetCameraZ()) && (e.GetViewportForZ(t, n),
            n.intersectsRect(this.GetBoundingBox()))
        }
        SetSourceCollisionPoly(e) {
            this._sourceCollisionPoly = e;
            const t = this._transformedPolyInfo;
            t && (t.width = -1,
            t.height = -1,
            t.angle = 0)
        }
        GetSourceCollisionPoly() {
            return this._sourceCollisionPoly
        }
        HasOwnCollisionPoly() {
            return !!this._sourceCollisionPoly
        }
        GetTransformedCollisionPoly() {
            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
        }
        GetCustomTransformedCollisionPoly(t, n, r) {
            let i = 0
              , l = 1;
            return 0 !== r && (i = Math.sin(r),
            l = Math.cos(r)),
            this._GetCustomTransformedCollisionPolyPrecalc(t, n, r, i, l)
        }
        _GetCustomTransformedCollisionPolyPrecalc(t, n, r, i, a) {
            let e = this._transformedPolyInfo;
            return (null === e && (e = {
                poly: C3.New(C3.CollisionPoly),
                width: -1,
                height: -1,
                angle: 0
            },
            this._transformedPolyInfo = e),
            e.width === t && e.height === n && e.angle === r) ? e.poly : (this._sourceCollisionPoly ? (e.poly.copy(this._sourceCollisionPoly),
            e.poly.transformPrecalc(t, n, i, a)) : e.poly.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY()),
            e.width = t,
            e.height = n,
            e.angle = r,
            e.poly)
        }
        HasTilemap() {
            return this._inst.HasTilemap()
        }
        ContainsPoint(e, t) {
            return !!this.GetBoundingBox().containsPoint(e, t) && !!this.GetBoundingQuad().containsPoint(e, t) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(e, t) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(e - this.GetX(), t - this.GetY()))
        }
        _IsCollisionCellChanged() {
            return 0 != (16 & this._flags)
        }
        _UpdateCollisionCell() {
            if (this._IsCollisionCellChanged() && this.IsCollisionEnabled()) {
                const a = this.GetBoundingBox()
                  , n = this._objectClass._GetCollisionCellGrid()
                  , r = this._collisionCells;
                if (t.set(n.XToCell(a.getLeft()), n.YToCell(a.getTop()), n.XToCell(a.getRight()), n.YToCell(a.getBottom())),
                !r.equals(t)) {
                    const a = this._inst;
                    r === e ? (n.Update(a, null, t),
                    this._collisionCells = C3.New(C3.Rect, t)) : (n.Update(a, r, t),
                    r.copy(t)),
                    this._flags &= -17
                }
            }
        }
        _RemoveFromCollisionCells() {
            const t = this._collisionCells;
            t === e || (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null),
            this._collisionCells = e)
        }
        _UpdateRenderCell() {
            const a = this.GetLayer();
            if (a.UsesRenderCells()) {
                const n = a.GetRenderGrid()
                  , r = this.GetBoundingBox()
                  , i = this._renderCells;
                if (t.set(n.XToCell(r.getLeft()), n.YToCell(r.getTop()), n.XToCell(r.getRight()), n.YToCell(r.getBottom())),
                !i.equals(t)) {
                    const e = this._inst;
                    i === _ ? (n.Update(e, null, t),
                    this._renderCells = C3.New(C3.Rect, t)) : (n.Update(e, i, t),
                    i.copy(t)),
                    a.SetRenderListStale()
                }
            }
        }
        _RemoveFromRenderCells() {
            const e = this._renderCells;
            e === _ || (this.GetLayer().GetRenderGrid().Update(this._inst, e, null),
            this._renderCells = _)
        }
        GetRenderCellRange() {
            return this._renderCells
        }
        ZOrderMoveToTop() {
            const e = this._inst
              , t = this._layer
              , a = t._GetInstances();
            a.length && a[a.length - 1] === e || (t._RemoveInstance(e, !1),
            t._AddInstance(e, !1),
            this._runtime.UpdateRender())
        }
        ZOrderMoveToBottom() {
            const e = this._inst
              , t = this._layer
              , a = t._GetInstances();
            a.length && a[0] === e || (t._RemoveInstance(e, !1),
            t._PrependInstance(e, !1),
            this._runtime.UpdateRender())
        }
        ZOrderMoveToLayer(e) {
            const t = this._inst
              , a = this._layer;
            if (a.GetLayout() !== e.GetLayout())
                throw new Error('layer from different layout');
            e === a || (a._RemoveInstance(t, !0),
            this._SetLayer(e),
            e._AddInstance(t, !0),
            this._runtime.UpdateRender())
        }
        ZOrderMoveAdjacentToInstance(t, a) {
            const n = this._inst
              , r = this._layer;
            if (t.GetUID() !== n.GetUID()) {
                const i = t.GetWorldInfo();
                if (!i)
                    throw new Error('expected world instance');
                const e = i.GetLayer();
                r.GetIndex() !== e.GetIndex() && (r._RemoveInstance(n, !0),
                this._SetLayer(e),
                e._AddInstance(n, !0)),
                e.MoveInstanceAdjacent(n, t, !!a),
                this._runtime.UpdateRender()
            }
        }
        GetInstanceEffectList() {
            return this._instanceEffectList
        }
        _SetHasAnyActiveEffect(e) {
            this._SetFlag(64, e)
        }
        HasAnyActiveEffect() {
            return 0 != (64 & this._flags)
        }
        _SaveToJson() {
            const e = {
                x: this.GetX(),
                y: this.GetY(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                l: this.GetLayer().GetSID(),
                zi: this.GetZIndex()
            };
            0 !== this.GetZElevation() && (e.ze = this.GetZElevation()),
            0 !== this.GetAngle() && (e.a = this.GetAngle()),
            this.HasDefaultColor() || (e.c = this._color.toJSON()),
            .5 !== this.GetOriginX() && (e.oX = this.GetOriginX()),
            .5 !== this.GetOriginY() && (e.oY = this.GetOriginY()),
            0 !== this.GetBlendMode() && (e.bm = this.GetBlendMode()),
            this.IsVisible() || (e.v = this.IsVisible()),
            this.IsCollisionEnabled() || (e.ce = this.IsCollisionEnabled()),
            this.IsBboxChangeEventEnabled() && (e.be = this.IsBboxChangeEventEnabled()),
            this._instanceEffectList && (e.fx = this._instanceEffectList._SaveToJson());
            const t = 0 != (32 & this._flags);
            return t && (e.sfi = t),
            this._solidFilterTags && (e.sft = [...this._solidFilterTags].join(' ')),
            e
        }
        _LoadFromJson(e) {
            d = !1,
            this.SetX(e.x),
            this.SetY(e.y),
            this.SetWidth(e.w),
            this.SetHeight(e.h),
            this._SetZIndex(e.zi),
            this.SetZElevation(e.hasOwnProperty('ze') ? e.ze : 0),
            this.SetAngle(e.hasOwnProperty('a') ? e.a : 0),
            e.hasOwnProperty('c') ? r.setFromJSON(e.c) : e.hasOwnProperty('o') ? (r.copyRgb(this._color),
            r.a = e.o) : r.setRgba(1, 1, 1, 1),
            this._SetColor(r),
            this.SetOriginX(e.hasOwnProperty('oX') ? e.oX : .5),
            this.SetOriginY(e.hasOwnProperty('oY') ? e.oY : .5),
            this.SetBlendMode(e.hasOwnProperty('bm') ? e.bm : 0),
            this.SetVisible(!e.hasOwnProperty('v') || e.v),
            this.SetCollisionEnabled(!e.hasOwnProperty('ce') || e.ce),
            this.SetBboxChangeEventEnabled(!!e.hasOwnProperty('be') && e.be),
            this.SetSolidCollisionFilter(!!e.hasOwnProperty('sfi') && e.sfi, e.hasOwnProperty('sft') ? e.sft : ''),
            this._instanceEffectList && e.hasOwnProperty('fx') && this._instanceEffectList._LoadFromJson(e.fx),
            this.SetBboxChanged(),
            d = !0,
            this._UpdateWebGLStateGroup()
        }
    }
}
'use strict',
C3.BehaviorType = class extends C3.DefendedBase {
    constructor(t, a) {
        super();
        const n = t.GetRuntime()
          , r = n.GetPluginManager()
          , i = n.GetObjectReference(a[1]);
        r.HasBehaviorByConstructorFunction(i) || r.CreateBehavior(a),
        this._runtime = n,
        this._objectClass = t,
        this._behavior = r.GetBehaviorByConstructorFunction(i),
        this._sdkType = null,
        this._instSdkCtor = i.Instance,
        this._sid = a[2],
        this._name = a[0],
        this._jsPropName = this._runtime.GetJsPropName(a[3]),
        this._sdkType = C3.New(i.Type, this),
        this.OnCreate()
    }
    static Create(e, t) {
        return C3.New(C3.BehaviorType, e, t)
    }
    Release() {
        this._runtime = null,
        this._behavior = null,
        this._sdkType.Release(),
        this._sdkType = null,
        this._instSdkCtor = null
    }
    GetSdkType() {
        return this._sdkType
    }
    OnCreate() {
        this._sdkType.OnCreate()
    }
    GetRuntime() {
        return this._runtime
    }
    GetObjectClass() {
        return this._objectClass
    }
    GetBehavior() {
        return this._behavior
    }
    GetInstanceSdkCtor() {
        return this._instSdkCtor
    }
    GetName() {
        return this._name
    }
    GetSID() {
        return this._sid
    }
    GetJsPropName() {
        return this._jsPropName
    }
}
,
'use strict',
C3.BehaviorInstance = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._runtime = e.runtime,
        this._behaviorType = e.behaviorType,
        this._behavior = this._behaviorType.GetBehavior(),
        this._inst = e.instance,
        this._index = e.index,
        this._sdkInst = null,
        this._iScriptInterface = null,
        this._behavior._AddInstance(this._inst)
    }
    Release() {
        this._behavior._RemoveInstance(this._inst),
        this._sdkInst.Release(),
        this._sdkInst = null,
        this._iScriptInterface = null,
        this._runtime = null,
        this._behaviorType = null,
        this._behavior = null,
        this._inst = null
    }
    _CreateSdkInstance(e) {
        if (this._sdkInst)
            throw new Error('already got sdk instance');
        this._sdkInst = C3.New(this._behaviorType.GetInstanceSdkCtor(), this, e),
        this._InitScriptInterface()
    }
    GetSdkInstance() {
        return this._sdkInst
    }
    GetObjectInstance() {
        return this._inst
    }
    GetRuntime() {
        return this._runtime
    }
    GetBehaviorType() {
        return this._behaviorType
    }
    GetBehavior() {
        return this._behavior
    }
    _GetIndex() {
        return this._index
    }
    PostCreate() {
        this._sdkInst.PostCreate()
    }
    OnSpriteFrameChanged(e, t) {
        this._sdkInst.OnSpriteFrameChanged(e, t)
    }
    _GetDebuggerProperties() {
        return this._sdkInst.GetDebuggerProperties()
    }
    SaveToJson() {
        return this._sdkInst.SaveToJson()
    }
    LoadFromJson(e) {
        return this._sdkInst.LoadFromJson(e)
    }
    static SortByTickSequence(t, n) {
        const a = t.GetObjectInstance()
          , r = n.GetObjectInstance()
          , i = a.GetObjectClass().GetIndex()
          , e = r.GetObjectClass().GetIndex();
        if (i !== e)
            return i - e;
        const l = a.GetPUID()
          , _ = r.GetPUID();
        return l === _ ? t.GetBehaviorInstance()._GetIndex() - n.GetBehaviorInstance()._GetIndex() : l - _
    }
    _InitScriptInterface() {
        const e = IBehaviorInstance
          , t = this._sdkInst.GetScriptInterfaceClass();
        if (IBehaviorInstance._Init(this),
        this._iScriptInterface = new (t || e),
        IBehaviorInstance._Init(null),
        t && !(this._iScriptInterface instanceof e))
            throw new TypeError(`script interface class '${t.name}' does not extend the right base class '${e.name}'`)
    }
    GetScriptInterface() {
        return this._iScriptInterface
    }
}
,
'use strict',
C3.EffectList = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._owner = e,
        this._allEffectTypes = [],
        this._activeEffectTypes = [],
        this._effectTypesByName = new Map,
        this._effectParams = [],
        this._preservesOpaqueness = !0;
        for (const n of t) {
            const e = C3.New(C3.EffectType, this, n, this._allEffectTypes.length);
            this._allEffectTypes.push(e),
            this._effectTypesByName.set(e.GetName().toLowerCase(), e),
            3 <= n.length && this._effectParams.push(this._LoadSingleEffectParameters(n[2]))
        }
        this.GetRuntime()._AddEffectList(this)
    }
    Release() {
        C3.clearArray(this._allEffectTypes),
        C3.clearArray(this._activeEffectTypes),
        this._effectTypesByName.clear(),
        C3.clearArray(this._effectParams),
        this._owner = null
    }
    PrependEffectTypes(e) {
        if (e.length) {
            this._allEffectTypes = e.concat(this._allEffectTypes);
            for (const t of e)
                this._effectTypesByName.set(t.GetName().toLowerCase(), t);
            for (let e = 0, t = this._allEffectTypes.length; e < t; ++e)
                this._allEffectTypes[e]._SetIndex(e)
        }
    }
    _LoadSingleEffectParameters(e) {
        const t = e.slice(0);
        for (let n = 0, a = t.length; n < a; ++n) {
            const r = t[n];
            if (Array.isArray(r)) {
                const a = C3.New(C3.Color);
                a.setFromJSON(r),
                t[n] = a
            }
        }
        return t
    }
    GetOwner() {
        return this._owner
    }
    GetRuntime() {
        return this._owner.GetRuntime()
    }
    UpdateActiveEffects() {
        C3.clearArray(this._activeEffectTypes);
        let e = !0;
        for (const t of this._allEffectTypes)
            t.IsActive() && (this._activeEffectTypes.push(t),
            t.GetShaderProgram().PreservesOpaqueness() || (e = !1));
        this._preservesOpaqueness = e
    }
    GetAllEffectTypes() {
        return this._allEffectTypes
    }
    HasAnyEffectType() {
        return 0 < this._allEffectTypes.length
    }
    GetEffectTypeByName(e) {
        return this._effectTypesByName.get(e.toLowerCase()) || null
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    HasAnyActiveEffect() {
        return 0 < this._activeEffectTypes.length
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    GetEffectParametersForIndex(e) {
        return this._effectParams[e]
    }
    static SaveFxParamToJson(e) {
        return e && e instanceof C3.Color ? {
            t: 'color',
            v: e.toJSON()
        } : e
    }
    static LoadFxParamFromJson(e) {
        if ('object' == typeof e) {
            const t = e.t;
            if ('color' === t) {
                const t = C3.New(C3.Color);
                return t.setFromJSON(e.v),
                t
            }
            throw new Error('invalid effect parameter type')
        } else
            return e
    }
    static SaveFxParamsToJson(e) {
        return e.map(C3.EffectList.SaveFxParamToJson)
    }
    static LoadFxParamsFromJson(e) {
        return e.map(C3.EffectList.LoadFxParamFromJson)
    }
    SaveToJson() {
        return this._allEffectTypes.map(e=>({
            name: e.GetName(),
            active: e.IsActive(),
            params: C3.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()])
        }))
    }
    LoadFromJson(e) {
        for (const t of e) {
            const e = this.GetEffectTypeByName(t.name);
            e && (e.SetActive(t.active),
            this._effectParams[e.GetIndex()] = C3.EffectList.LoadFxParamsFromJson(t.params))
        }
        this.UpdateActiveEffects()
    }
}
,
'use strict',
C3.EffectType = class extends C3.DefendedBase {
    constructor(e, t, a) {
        super(),
        this._effectList = e,
        this._id = t[0],
        this._name = t[1],
        this._index = a,
        this._shaderProgram = null,
        this._isActive = !0
    }
    Release() {
        this._effectList = null,
        this._shaderProgram = null
    }
    Clone(e) {
        const t = C3.New(C3.EffectType, e, [this._id, this._name], -1);
        return t._shaderProgram = this._shaderProgram,
        t._isActive = this._isActive,
        t
    }
    _InitRenderer(e) {
        const t = e.GetShaderProgramByName(this._id);
        if (!t)
            throw new Error('failed to find shader program \'' + this._id + '\'');
        this._shaderProgram = t
    }
    GetEffectList() {
        return this._effectList
    }
    GetName() {
        return this._name
    }
    _SetIndex(e) {
        this._index = e
    }
    GetIndex() {
        return this._index
    }
    GetOwner() {
        return this._effectList.GetOwner()
    }
    GetRuntime() {
        return this._effectList.GetRuntime()
    }
    SetActive(e) {
        this._isActive = !!e
    }
    IsActive() {
        return this._isActive
    }
    GetShaderProgram() {
        return this._shaderProgram
    }
    GetDefaultParameterValues() {
        const e = [];
        for (let t = 0, a = this._shaderProgram.GetParameterCount(); t < a; ++t) {
            const a = this._shaderProgram.GetParameterType(t);
            if ('float' === a || 'percent' === a)
                e.push(0);
            else if ('color' === a)
                e.push(C3.New(C3.Color, 1, 1, 1, 1));
            else
                throw new TypeError('unknown effect parameter type')
        }
        return e
    }
}
,
'use strict',
C3.InstanceEffectList = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._inst = e,
        this._wi = t,
        this._effectList = e.GetObjectClass().GetEffectList(),
        this._activeEffectFlags = [],
        this._activeEffectTypes = [],
        this._preservesOpaqueness = !0,
        this._effectParams = [];
        for (const a of this._effectList.GetAllEffectTypes())
            this._activeEffectFlags.push(!0);
        this.UpdateActiveEffects()
    }
    Release() {
        C3.clearArray(this._activeEffectFlags),
        C3.clearArray(this._activeEffectTypes),
        C3.clearArray(this._effectParams),
        this._inst = null,
        this._effectList = null
    }
    _LoadEffectParameters(e) {
        for (const t of e)
            this._effectParams.push(this._LoadSingleEffectParameters(t))
    }
    _LoadSingleEffectParameters(e) {
        const t = e.slice(0);
        for (let n = 0, a = t.length; n < a; ++n) {
            const r = t[n];
            if (Array.isArray(r)) {
                const a = C3.New(C3.Color);
                a.setFromJSON(r),
                t[n] = a
            }
        }
        return t
    }
    LoadDefaultEffectParameters() {
        for (const e of this._effectList.GetAllEffectTypes())
            this._effectParams.push(e.GetDefaultParameterValues())
    }
    GetOwner() {
        return this._owner
    }
    GetEffectList() {
        return this._effectList
    }
    UpdateActiveEffects() {
        C3.clearArray(this._activeEffectTypes);
        const t = this._effectList.GetAllEffectTypes()
          , a = this._activeEffectTypes
          , n = this._activeEffectFlags;
        let r = !0;
        for (let i = 0, e = t.length; i < e; ++i)
            if (n[i]) {
                const e = t[i];
                a.push(e),
                e.GetShaderProgram().PreservesOpaqueness() || (r = !1)
            }
        this._preservesOpaqueness = r,
        this._wi._SetHasAnyActiveEffect(!!a.length)
    }
    GetActiveEffectTypes() {
        return this._activeEffectTypes
    }
    GetEffectParametersForIndex(e) {
        return this._effectParams[e]
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    HasAnyActiveBackgroundBlendingEffect() {
        return this._activeEffectTypes.some(e=>e.GetShaderProgram().UsesDest())
    }
    IsEffectIndexActive(e) {
        return this._activeEffectFlags[e]
    }
    SetEffectIndexActive(e, t) {
        this._activeEffectFlags[e] = !!t
    }
    _SaveToJson() {
        return this._effectList.GetAllEffectTypes().map(e=>({
            name: e.GetName(),
            active: this._activeEffectFlags[e.GetIndex()],
            params: C3.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()])
        }))
    }
    _LoadFromJson(e) {
        for (const t of e) {
            const e = this._effectList.GetEffectTypeByName(t.name);
            e && (this._activeEffectFlags[e.GetIndex()] = t.active,
            this._effectParams[e.GetIndex()] = C3.EffectList.LoadFxParamsFromJson(t.params))
        }
        this.UpdateActiveEffects()
    }
}
,
'use strict';
{
    const t = []
      , r = []
      , a = []
      , l = C3.New(C3.CollisionPoly)
      , n = C3.New(C3.CollisionPoly)
      , _ = C3.New(C3.Quad)
      , u = C3.New(C3.Rect)
      , g = C3.New(C3.Rect);
    C3.CollisionEngine = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._runtime = e,
            this._registeredCollisions = [],
            this._collisionCheckCount = 0,
            this._collisionCheckSec = 0,
            this._polyCheckCount = 0,
            this._polyCheckSec = 0
        }
        Release() {
            this._runtime = null
        }
        _Update1sStats() {
            this._collisionCheckSec = this._collisionCheckCount,
            this._collisionCheckCount = 0,
            this._polyCheckSec = this._polyCheckCount,
            this._polyCheckCount = 0
        }
        Get1secCollisionChecks() {
            return this._collisionCheckSec
        }
        Get1secPolyChecks() {
            return this._polyCheckSec
        }
        RegisterCollision(e, t) {
            const a = e.GetWorldInfo()
              , n = t.GetWorldInfo();
            a && n && a.IsCollisionEnabled() && n.IsCollisionEnabled() && this._registeredCollisions.push([e, t])
        }
        AddRegisteredCollisionCandidates(t, n, r) {
            for (const [e,i] of this._registeredCollisions) {
                let a = null;
                if (t === e)
                    a = i;
                else if (t === i)
                    a = e;
                else
                    continue;
                a.BelongsToObjectClass(n) && !r.includes(a) && r.push(a)
            }
        }
        CheckRegisteredCollision(t, e) {
            if (!this._registeredCollisions.length)
                return !1;
            for (const [a,n] of this._registeredCollisions)
                if (t === a && e === n || t === n && e === a)
                    return !0;
            return !1
        }
        ClearRegisteredCollisions() {
            C3.clearArray(this._registeredCollisions)
        }
        TestOverlap(t, a) {
            if (!t || !a || t === a)
                return !1;
            const n = t.GetWorldInfo()
              , e = a.GetWorldInfo();
            if (!n.IsCollisionEnabled() || !e.IsCollisionEnabled())
                return !1;
            this._collisionCheckCount++;
            const r = n.GetLayer()
              , l = e.GetLayer()
              , _ = r !== l && !r._IsCollisionCompatibleWith(l);
            return _ ? this._TestOverlap_DifferentLayers(n, e) : this._TestOverlap_SameLayers(n, e)
        }
        _TestOverlap_SameLayers(e, t) {
            if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox()))
                return !1;
            if (this._polyCheckCount++,
            !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad()))
                return !1;
            if (e.HasTilemap() && t.HasTilemap())
                return !1;
            if (e.HasTilemap())
                return this.TestTilemapOverlap(e, t);
            if (t.HasTilemap())
                return this.TestTilemapOverlap(t, e);
            if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly())
                return !0;
            const a = e.GetTransformedCollisionPoly()
              , n = t.GetTransformedCollisionPoly();
            return a.intersectsPoly(n, t.GetX() - e.GetX(), t.GetY() - e.GetY())
        }
        _TestOverlap_DifferentLayers(t, r) {
            const a = t.GetLayer()
              , _ = r.GetLayer();
            l.copy(t.GetTransformedCollisionPoly()),
            n.copy(r.GetTransformedCollisionPoly());
            const u = l.pointsArr();
            for (let n = 0, i = u.length; n < i; n += 2) {
                const r = n + 1
                  , l = u[n]
                  , e = u[r]
                  , [_,d] = a.LayerToCanvasCss(l + t.GetX(), e + t.GetY());
                u[n] = _,
                u[r] = d
            }
            const m = n.pointsArr();
            for (let n = 0, e = m.length; n < e; n += 2) {
                const t = n + 1
                  , a = m[n]
                  , l = m[t]
                  , [e,d] = _.LayerToCanvasCss(a + r.GetX(), l + r.GetY());
                m[n] = e,
                m[t] = d
            }
            return l.setBboxChanged(),
            n.setBboxChanged(),
            this._polyCheckCount++,
            l.intersectsPoly(n, 0, 0)
        }
        TestTilemapOverlap(t, d) {
            const e = d.GetBoundingBox()
              , u = t.GetX()
              , p = t.GetY()
              , a = t.GetInstance().GetSdkInstance()
              , h = d.GetX()
              , i = d.GetY()
              , g = d.HasOwnCollisionPoly()
              , f = d.GetBoundingQuad()
              , m = r;
            a.GetCollisionRectCandidates(e, m);
            for (let n = 0, a = m.length; n < a; ++n) {
                const t = m[n]
                  , a = t.GetRect();
                if (this._collisionCheckCount++,
                e.intersectsRectOffset(a, u, p) && (_.setFromRect(a),
                _.offset(u, p),
                _.intersectsQuad(f)))
                    if (g) {
                        const e = d.GetTransformedCollisionPoly()
                          , n = t.GetPoly();
                        if (n) {
                            if (this._polyCheckCount++,
                            n.intersectsPoly(e, h - (u + a.getLeft()), i - (p + a.getTop())))
                                return C3.clearArray(m),
                                !0;
                        } else if (l.setFromQuad(_, 0, 0),
                        l.intersectsPoly(e, h, i))
                            return C3.clearArray(m),
                            !0
                    } else {
                        const e = t.GetPoly();
                        if (!e)
                            return C3.clearArray(m),
                            !0;
                        if (l.setFromQuad(f, 0, 0),
                        e.intersectsPoly(l, -(u + a.getLeft()), -(p + a.getTop())))
                            return C3.clearArray(m),
                            !0
                    }
            }
            return C3.clearArray(m),
            !1
        }
        TestAndSelectCanvasPointOverlap(t, n, r, l) {
            const _ = t.GetCurrentSol()
              , e = this._runtime.GetCurrentEvent();
            if (!e)
                throw new Error('cannot call outside event');
            const d = e.IsOrBlock();
            if (_.IsSelectAll()) {
                l || (_._SetSelectAll(!1),
                C3.clearArray(_._GetOwnInstances()));
                for (const e of t.GetInstances()) {
                    const t = e.GetWorldInfo()
                      , a = t.GetLayer()
                      , [u,i] = a.CanvasCssToLayer(n, r, t.GetTotalZElevation());
                    if (t.ContainsPoint(u, i)) {
                        if (l)
                            return !1;
                        _._PushInstance(e)
                    } else
                        d && _._PushElseInstance(e)
                }
            } else {
                const e = d ? _._GetOwnElseInstances() : _._GetOwnInstances();
                let t = 0;
                for (let a = 0, u = e.length; a < u; ++a) {
                    const u = e[a]
                      , i = u.GetWorldInfo()
                      , c = i.GetLayer()
                      , [g,p] = c.CanvasCssToLayer(n, r, i.GetTotalZElevation());
                    if (i.ContainsPoint(g, p)) {
                        if (l)
                            return !1;
                        d ? _._PushInstance(u) : e[t++] = u
                    } else
                        d && (e[t++] = u)
                }
                l || (e.length = t)
            }
            return t.ApplySolToContainer(),
            !!l || _.HasAnyInstances()
        }
        GetCollisionCandidates(t, n, r, i) {
            const l = !!t && (1 !== t.GetParallaxX() || 1 !== t.GetParallaxY());
            if (n.IsFamily())
                for (const e of n.GetFamilyMembers())
                    l || e.IsAnyInstanceParallaxed() ? C3.appendArray(i, e.GetInstances()) : (e._UpdateAllCollisionCells(),
                    e._GetCollisionCellGrid().QueryRange(r, i));
            else
                l || n.IsAnyInstanceParallaxed() ? C3.appendArray(i, n.GetInstances()) : (n._UpdateAllCollisionCells(),
                n._GetCollisionCellGrid().QueryRange(r, i))
        }
        GetObjectClassesCollisionCandidates(t, a, n, r) {
            for (const i of a)
                this.GetCollisionCandidates(t, i, n, r)
        }
        GetSolidCollisionCandidates(e, t, a) {
            const n = this._runtime.GetSolidBehavior();
            n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, a)
        }
        GetJumpthruCollisionCandidates(e, t, a) {
            const n = this._runtime.GetJumpthruBehavior();
            n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, a)
        }
        IsSolidCollisionAllowed(e, t) {
            return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get('solidTags')))
        }
        TestOverlapSolid(e) {
            const a = e.GetWorldInfo();
            this.GetSolidCollisionCandidates(a.GetLayer(), a.GetBoundingBox(), t);
            for (const a of t)
                if (this.IsSolidCollisionAllowed(a, e) && this.TestOverlap(e, a))
                    return C3.clearArray(t),
                    a;
            return C3.clearArray(t),
            null
        }
        TestRectOverlapSolid(e, a) {
            this.GetSolidCollisionCandidates(null, e, t);
            for (const n of t)
                if (this.IsSolidCollisionAllowed(n, a) && this.TestRectOverlap(e, n))
                    return C3.clearArray(t),
                    n;
            return C3.clearArray(t),
            null
        }
        TestOverlapJumpthru(n, r) {
            let i = null;
            r && (i = a,
            C3.clearArray(i));
            const l = n.GetWorldInfo();
            this.GetJumpthruCollisionCandidates(l.GetLayer(), l.GetBoundingBox(), t);
            for (const e of t)
                if (e._IsJumpthruEnabled() && this.TestOverlap(n, e))
                    if (r)
                        i.push(e);
                    else
                        return C3.clearArray(t),
                        e;
            return C3.clearArray(t),
            i
        }
        PushOut(t, a, n, r, i) {
            r = r || 50;
            const e = t.GetWorldInfo()
              , l = e.GetX()
              , _ = e.GetY();
            for (let d = 0; d < r; ++d)
                if (e.SetXY(l + a * d, _ + n * d),
                e.SetBboxChanged(),
                !this.TestOverlap(t, i))
                    return !0;
            return e.SetXY(l, _),
            e.SetBboxChanged(),
            !1
        }
        PushOutSolid(t, a, n, r, i, e) {
            r = r || 50;
            const _ = t.GetWorldInfo()
              , u = _.GetX()
              , c = _.GetY();
            let g = null
              , p = null;
            for (let l = 0; l < r; ++l)
                if (_.SetXY(u + a * l, c + n * l),
                _.SetBboxChanged(),
                !this.TestOverlap(t, g))
                    if (g = this.TestOverlapSolid(t),
                    g)
                        p = g;
                    else if (i && (g = e ? this.TestOverlap(t, e) ? e : null : this.TestOverlapJumpthru(t),
                    g && (p = g)),
                    !g)
                        return p && this.PushInFractional(t, a, n, p, 16, !0),
                        !0;
            return _.SetXY(u, c),
            _.SetBboxChanged(),
            !1
        }
        PushOutSolidAxis(t, a, n, r) {
            r = r || 50;
            const l = t.GetWorldInfo()
              , e = l.GetX()
              , _ = l.GetY();
            let u = null
              , c = null;
            for (let g = 0; g < r; ++g)
                for (let r = 0; 2 > r; ++r) {
                    const d = 2 * r - 1;
                    if (l.SetXY(e + a * g * d, _ + n * g * d),
                    l.SetBboxChanged(),
                    !this.TestOverlap(t, u))
                        if (u = this.TestOverlapSolid(t),
                        u)
                            c = u;
                        else
                            return c && this.PushInFractional(t, a * d, n * d, c, 16, !0),
                            !0
                }
            return l.SetXY(e, _),
            l.SetBboxChanged(),
            !1
        }
        PushInFractional(t, a, n, r, _, d) {
            let u = 2
              , c = !1
              , m = !1;
            const p = t.GetWorldInfo();
            let f = p.GetX()
              , S = p.GetY();
            for (; u <= _; ) {
                const i = 1 / u;
                u *= 2,
                p.OffsetXY(a * i * (c ? 1 : -1), n * i * (c ? 1 : -1)),
                p.SetBboxChanged(),
                this.TestOverlap(t, r) || d && this.TestOverlapSolid(t) ? (c = !0,
                m = !0) : (c = !1,
                m = !1,
                f = p.GetX(),
                S = p.GetY())
            }
            m && (p.SetXY(f, S),
            p.SetBboxChanged())
        }
        PushOutSolidNearest(t, a=100) {
            var n = Math.floor;
            let r = 0;
            const l = t.GetWorldInfo()
              , e = l.GetX()
              , _ = l.GetY();
            let u = 0
              , c = this.TestOverlapSolid(t);
            if (!c)
                return !0;
            for (; r <= a; ) {
                let a = 0
                  , i = 0;
                if (0 == u ? (a = 0,
                i = -1,
                r++) : 1 == u ? (a = 1,
                i = -1) : 2 == u ? (a = 1,
                i = 0) : 3 == u ? (a = 1,
                i = 1) : 4 == u ? (a = 0,
                i = 1) : 5 == u ? (a = -1,
                i = 1) : 6 == u ? (a = -1,
                i = 0) : 7 == u ? (a = -1,
                i = -1) : void 0,
                u = (u + 1) % 8,
                l.SetXY(n(e + a * r), n(_ + i * r)),
                l.SetBboxChanged(),
                !this.TestOverlap(t, c) && (c = this.TestOverlapSolid(t),
                !c))
                    return !0
            }
            return l.SetXY(e, _),
            l.SetBboxChanged(),
            !1
        }
        CalculateBounceAngle(_, a, S, c) {
            var d = Math.sin
              , e = Math.cos
              , f = Math.PI;
            const G = _.GetWorldInfo()
              , g = G.GetX()
              , h = G.GetY()
              , b = Math.max(10, C3.distanceTo(a, S, g, h))
              , l = C3.angleTo(a, S, g, h)
              , m = c || this.TestOverlapSolid(_);
            if (!m)
                return C3.clampAngle(l + f);
            let n = m
              , T = 0
              , I = 0;
            const C = C3.toRadians(5);
            let r;
            for (r = 1; 36 > r; ++r) {
                const t = l - r * C;
                if (G.SetXY(a + e(t) * b, S + d(t) * b),
                G.SetBboxChanged(),
                !this.TestOverlap(_, n) && (n = c ? null : this.TestOverlapSolid(_),
                !n)) {
                    T = t;
                    break
                }
            }
            for (36 === r && (T = C3.clampAngle(l + f)),
            n = m,
            r = 1; 36 > r; ++r) {
                const t = l + r * C;
                if (G.SetXY(a + e(t) * b, S + d(t) * b),
                G.SetBboxChanged(),
                !this.TestOverlap(_, n) && (n = c ? null : this.TestOverlapSolid(_),
                !n)) {
                    I = t;
                    break
                }
            }
            if (36 === r && (I = C3.clampAngle(l + f)),
            G.SetXY(g, h),
            G.SetBboxChanged(),
            I === T)
                return I;
            const P = C3.angleDiff(I, T) / 2;
            let i = C3.angleClockwise(I, T) ? C3.clampAngle(T + P + f) : C3.clampAngle(I + P);
            const t = e(l)
              , u = d(l)
              , v = e(i)
              , A = d(i)
              , x = t * v + u * A;
            return C3.angleTo(0, 0, t - 2 * x * v, u - 2 * x * A)
        }
        TestSegmentOverlap(t, a, n, r, l) {
            var e = Math.min
              , _ = Math.max;
            if (!l)
                return !1;
            const d = l.GetWorldInfo();
            if (!d.IsCollisionEnabled())
                return !1;
            if (this._collisionCheckCount++,
            u.set(e(t, n), e(a, r), _(t, n), _(a, r)),
            !d.GetBoundingBox().intersectsRect(u))
                return !1;
            if (l.HasTilemap())
                return this._TestSegmentOverlapTilemap(t, a, n, r, l, d);
            if (this._polyCheckCount++,
            !d.GetBoundingQuad().intersectsSegment(t, a, n, r))
                return !1;
            if (!d.HasOwnCollisionPoly())
                return !0;
            const i = d.GetTransformedCollisionPoly();
            return i.intersectsSegment(d.GetX(), d.GetY(), t, a, n, r)
        }
        _TestSegmentOverlapTilemap(t, a, d, e, p, c) {
            const i = c.GetX()
              , f = c.GetY()
              , l = p.GetSdkInstance()
              , m = r;
            g.set(t, a, d, e),
            g.normalize(),
            l.GetCollisionRectCandidates(g, m);
            for (let n = 0, r = m.length; n < r; ++n) {
                const r = m[n]
                  , l = r.GetRect();
                if (this._collisionCheckCount++,
                u.intersectsRectOffset(l, i, f) && (_.setFromRect(l),
                _.offset(i, f),
                _.intersectsSegment(t, a, d, e))) {
                    const n = r.GetPoly();
                    if (!n)
                        return C3.clearArray(m),
                        !0;
                    if (this._polyCheckCount++,
                    n.intersectsSegment(i + l.getLeft(), f + l.getTop(), t, a, d, e))
                        return C3.clearArray(m),
                        !0
                }
            }
            return C3.clearArray(m),
            !1
        }
        TestRectOverlap(t, a) {
            if (!a)
                return !1;
            const n = a.GetWorldInfo();
            if (!n.IsCollisionEnabled())
                return !1;
            if (this._collisionCheckCount++,
            !n.GetBoundingBox().intersectsRect(t))
                return !1;
            if (a.HasTilemap())
                return this._TestRectOverlapTilemap(t, a, n);
            if (this._polyCheckCount++,
            _.setFromRect(t),
            !n.GetBoundingQuad().intersectsQuad(_))
                return !1;
            if (!n.HasOwnCollisionPoly())
                return !0;
            const r = l;
            r.setFromRect(t, n.GetX(), n.GetY());
            const e = n.GetTransformedCollisionPoly();
            return r.intersectsPoly(e, 0, 0)
        }
        _TestRectOverlapTilemap(t, a, n) {
            const i = n.GetX()
              , _ = n.GetY()
              , e = a.GetSdkInstance()
              , d = r;
            e.GetCollisionRectCandidates(t, d);
            for (let r = 0, e = d.length; r < e; ++r) {
                const a = d[r]
                  , e = a.GetRect();
                if (this._collisionCheckCount++,
                t.intersectsRectOffset(e, i, _)) {
                    const n = a.GetPoly();
                    if (!n)
                        return C3.clearArray(d),
                        !0;
                    if (this._polyCheckCount++,
                    l.setFromRect(t, 0, 0),
                    n.intersectsPoly(l, -(i + e.getLeft()), -(_ + e.getTop())))
                        return C3.clearArray(d),
                        !0
                }
            }
            return C3.clearArray(d),
            !1
        }
        TestRayIntersectsInstance(e, t) {
            if (e) {
                const a = e.GetWorldInfo();
                if (a.IsCollisionEnabled())
                    return this._collisionCheckCount++,
                    a.GetBoundingBox().intersectsRect(t.rect) ? e.HasTilemap() ? void this._TestRayIntersectsTilemap(e, a, t) : void (this._polyCheckCount++,
                    a.HasOwnCollisionPoly() ? t.TestInstancePoly(e, a.GetX(), a.GetY(), a.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, a.GetBoundingQuad())) : void 0
            }
        }
        _TestRayIntersectsTilemap(t, a, n) {
            const e = a.GetX()
              , l = a.GetY()
              , _ = r;
            t.GetSdkInstance().GetCollisionRectCandidates(n.rect, _);
            for (let r = 0, i = _.length; r < i; r++) {
                const d = _[r]
                  , i = d.GetRect();
                if (this._collisionCheckCount++,
                n.rect.intersectsRectOffset(i, e, l)) {
                    const r = d.GetPoly();
                    this._polyCheckCount++,
                    r ? n.TestInstancePoly(t, e + i.getLeft(), l + i.getTop(), r) : n.TestInstanceRect(t, a.GetX(), a.GetY(), i)
                }
            }
            C3.clearArray(_)
        }
    }
}
'use strict',
C3.SparseGrid = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._cellWidth = e,
        this._cellHeight = t,
        this._cells = C3.New(C3.PairMap)
    }
    Release() {
        this._cells.Release(),
        this._cells = null
    }
    GetCell(e, t, a) {
        let n = this._cells.Get(e, t);
        return n ? n : a ? (n = C3.New(C3.GridCell, this, e, t),
        this._cells.Set(e, t, n),
        n) : null
    }
    XToCell(e) {
        const t = Math.floor(e / this._cellWidth);
        return isFinite(t) ? t : 0
    }
    YToCell(e) {
        const t = Math.floor(e / this._cellHeight);
        return isFinite(t) ? t : 0
    }
    Update(t, a, n) {
        if (a)
            for (let r = a.getLeft(), i = a.getRight(); r <= i; ++r)
                for (let i = a.getTop(), e = a.getBottom(); i <= e; ++i) {
                    if (n && n.containsPoint(r, i))
                        continue;
                    const e = this.GetCell(r, i, !1);
                    e && (e.Remove(t),
                    e.IsEmpty() && this._cells.Delete(r, i))
                }
        if (n)
            for (let r = n.getLeft(), i = n.getRight(); r <= i; ++r)
                for (let i = n.getTop(), e = n.getBottom(); i <= e; ++i)
                    a && a.containsPoint(r, i) || this.GetCell(r, i, !0).Insert(t)
    }
    QueryRange(t, n) {
        let r = this.XToCell(t.getLeft());
        const i = this.YToCell(t.getTop())
          , a = this.XToCell(t.getRight())
          , e = this.YToCell(t.getBottom());
        if (isFinite(a) && isFinite(e))
            for (; r <= a; ++r)
                for (let t = i; t <= e; ++t) {
                    const e = this.GetCell(r, t, !1);
                    e && e.Dump(n)
                }
    }
}
,
'use strict',
C3.GridCell = class extends C3.DefendedBase {
    constructor(e, t, a) {
        super(),
        this._grid = e,
        this._x = t,
        this._y = a,
        this._instances = C3.New(C3.ArraySet)
    }
    Release() {
        this._instances.Release(),
        this._instances = null,
        this._grid = null
    }
    IsEmpty() {
        return this._instances.IsEmpty()
    }
    Insert(e) {
        this._instances.Add(e)
    }
    Remove(e) {
        this._instances.Delete(e)
    }
    Dump(e) {
        C3.appendArray(e, this._instances.GetArray())
    }
}
,
'use strict';
{
    const t = 1e-6;
    C3.Ray = class {
        constructor() {
            this.x1 = 0,
            this.y1 = 0,
            this.x2 = 0,
            this.y2 = 0,
            this.dx = 0,
            this.dy = 0,
            this.rect = new C3.Rect,
            this.hitFraction = 2,
            this.hitUid = null,
            this.hitNormal = 0,
            this.hitNormalDx = 0,
            this.hitNormalDy = 0,
            this.hitX = 0,
            this.hitY = 0,
            this.distance = 0,
            this.normalX = 1,
            this.normalY = 0,
            this.reflectionX = 1,
            this.reflectionY = 0
        }
        DidCollide() {
            return this.hitFraction < 1 + t
        }
        Set(e, t, a, n) {
            return this.x1 = e,
            this.y1 = t,
            this.x2 = a,
            this.y2 = n,
            this.dx = a - e,
            this.dy = n - t,
            this.rect.set(e, t, a, n),
            this.rect.normalize(),
            this.hitFraction = 2,
            this.hitUid = null,
            this.hitNormal = 0,
            this.hitNormalDx = 0,
            this.hitNormalDy = 0,
            this.hitX = 0,
            this.hitY = 0,
            this.distance = 0,
            this.normalX = 1,
            this.normalY = 0,
            this.reflectionX = 1,
            this.reflectionY = 0,
            this
        }
        Complete() {
            var a = Math.PI;
            if (!1 !== this.DidCollide()) {
                const n = this.dx * this.hitFraction
                  , r = this.dy * this.hitFraction
                  , i = Math.sqrt(n * n + r * r)
                  , e = n / i
                  , l = r / i;
                this.distance = i - t,
                this.hitX = this.x1 + e * this.distance,
                this.hitY = this.y1 + l * this.distance,
                this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + a / 2,
                this.normalX = Math.cos(this.hitNormal),
                this.normalY = Math.sin(this.hitNormal);
                const _ = e * this.normalX + l * this.normalY;
                (this.reflectionX = e - 2 * this.normalX * _,
                this.reflectionY = l - 2 * this.normalY * _,
                0 < _) && (this.hitNormal = C3.clampAngle(this.hitNormal + a),
                this.normalX = -this.normalX,
                this.normalY = -this.normalY)
            }
        }
        TestInstanceSegment(t, a, n, r, i) {
            const e = C3.rayIntersect(this.x1, this.y1, this.x2, this.y2, a, n, r, i);
            0 <= e && e < this.hitFraction && (this.hitFraction = e,
            this.hitUid = t.GetUID(),
            this.hitNormalDx = a - r,
            this.hitNormalDy = n - i)
        }
        TestInstanceRect(t, a, n, r) {
            const i = a + r.getLeft()
              , e = a + r.getRight()
              , l = n + r.getTop()
              , _ = n + r.getBottom();
            this.TestInstanceSegment(t, i, l, e, l),
            this.TestInstanceSegment(t, e, l, e, _),
            this.TestInstanceSegment(t, e, _, i, _),
            this.TestInstanceSegment(t, i, _, i, l)
        }
        TestInstanceQuad(t, a) {
            const n = a.getTlx()
              , r = a.getTly()
              , l = a.getTrx()
              , e = a.getTry()
              , _ = a.getBrx()
              , d = a.getBry()
              , u = a.getBlx()
              , i = a.getBly();
            this.TestInstanceSegment(t, n, r, l, e),
            this.TestInstanceSegment(t, l, e, _, d),
            this.TestInstanceSegment(t, _, d, u, i),
            this.TestInstanceSegment(t, u, i, n, r)
        }
        TestInstancePoly(t, a, n, r) {
            const l = r.pointsArr();
            for (let e = 0, _ = l.length; e < _; e += 2) {
                const r = (e + 2) % _
                  , d = l[e] + a
                  , u = l[e + 1] + n
                  , i = l[r] + a
                  , c = l[r + 1] + n;
                this.TestInstanceSegment(t, d, u, i, c)
            }
        }
    }
}
{
    const e = new Set(['off', 'crop', 'scale-inner', 'scale-outer', 'letterbox-scale', 'letterbox-integer-scale'])
      , t = new Set(['high', 'low'])
      , n = C3.New(C3.Quad)
      , _ = C3.New(C3.Rect);
    C3.CanvasManager = class extends C3.DefendedBase {
        constructor(e) {
            super(),
            this._runtime = e,
            this._canvas = null,
            this._webglRenderer = null,
            this._gpuPreference = 'high-performance',
            this._windowInnerWidth = 0,
            this._windowInnerHeight = 0,
            this._canvasCssWidth = 0,
            this._canvasCssHeight = 0,
            this._canvasDeviceWidth = 0,
            this._canvasDeviceHeight = 0,
            this._canvasCssOffsetX = 0,
            this._canvasCssOffsetY = 0,
            this._drawWidth = 0,
            this._drawHeight = 0,
            this._fullscreenMode = 'letterbox-scale',
            this._documentFullscreenMode = 'letterbox-scale',
            this._deviceTransformOffX = 0,
            this._deviceTransformOffY = 0,
            this._wantFullscreenScalingQuality = 'high',
            this._fullscreenScalingQuality = this._wantFullscreenScalingQuality,
            this._isDocumentFullscreen = !1,
            this._availableAdditionalRenderTargets = [],
            this._usedAdditionalRenderTargets = new Set,
            this._shaderData = null,
            this._gpuFrameTimingsBuffer = null,
            this._gpuTimeStartFrame = 0,
            this._gpuTimeEndFrame = 0,
            this._gpuCurUtilisation = NaN,
            this._gpuLastUtilisation = 0,
            this._layersGpuProfile = new Map,
            this._snapshotFormat = '',
            this._snapshotQuality = 1,
            this._snapshotUrl = '',
            this._snapshotPromise = null,
            this._snapshotResolve = null,
            this._loaderStartTime = 0,
            this._rafId = -1,
            this._loadingProgress = 0,
            this._loadingprogress_handler = e=>this._loadingProgress = e.progress,
            this._webglPercentText = null,
            this._loadingLogoAsset = null,
            this._splashTextures = {
                logo: null,
                powered: null,
                website: null
            },
            this._splashFrameNumber = 0,
            this._splashFadeInFinishTime = 0,
            this._splashFadeOutStartTime = 0,
            this._splashState = 'fade-in',
            this._splashDoneResolve = null,
            this._splashDonePromise = new Promise(e=>this._splashDoneResolve = e)
        }
        _SetGPUPowerPreference(e) {
            this._gpuPreference = e
        }
        async CreateCanvas(e) {
            this._canvas = e.canvas,
            this._canvas.addEventListener('webglcontextlost', e=>this._OnWebGLContextLost(e)),
            this._canvas.addEventListener('webglcontextrestored', e=>this._OnWebGLContextRestored(e));
            const t = {
                powerPreference: this._gpuPreference,
                enableGpuProfiling: !0
            };
            'Android' === C3.Platform.OS && 'Chromium' === C3.Platform.BrowserEngine && 75 > C3.Platform.BrowserVersionNumber && (console.warn('[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this.'),
            t.maxWebGLVersion = 1),
            'standard' === this._runtime.GetCompositingMode() ? t.alpha = !0 : (t.alpha = !1,
            t.lowLatency = !0),
            this._webglRenderer = C3.New(C3.Gfx.WebGLRenderer, this._canvas, t),
            await this._webglRenderer.InitState(),
            this._webglRenderer.SupportsGPUProfiling() || (this._gpuLastUtilisation = NaN),
            this._runtime.AddDOMComponentMessageHandler('runtime', 'window-resize', e=>this._OnWindowResize(e)),
            this._runtime.AddDOMComponentMessageHandler('runtime', 'fullscreenchange', e=>this._OnFullscreenChange(e)),
            this._runtime.AddDOMComponentMessageHandler('runtime', 'fullscreenerror', e=>this._OnFullscreenError(e)),
            this._isDocumentFullscreen = !!e.isFullscreen,
            this.SetSize(e.windowInnerWidth, e.windowInnerHeight, !0),
            this._shaderData = self.C3_Shaders,
            await this._LoadShaderPrograms();
            let n = !1;
            for (const t of this._runtime._GetAllEffectLists()) {
                for (const e of t.GetAllEffectTypes())
                    e._InitRenderer(this._webglRenderer),
                    e.GetShaderProgram().UsesDest() && (n = !0);
                t.UpdateActiveEffects()
            }
            this._runtime._SetUsesAnyBackgroundBlending(n),
            this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C3.New(C3.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
        }
        async _LoadShaderPrograms() {
            if (this._shaderData) {
                const e = [];
                for (const [t,a] of Object.entries(this._shaderData)) {
                    const n = C3.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource(this._webglRenderer.Is3D());
                    e.push(this._webglRenderer.CreateShaderProgram(a, n, t))
                }
                await Promise.all(e),
                this._webglRenderer.ResetLastProgram(),
                this._webglRenderer.SetTextureFillMode()
            }
        }
        Release() {
            this._runtime = null,
            this._webglRenderer = null,
            this._canvas = null
        }
        _OnWindowResize(e) {
            const t = e.devicePixelRatio;
            this._runtime.IsInWorker() && (self.devicePixelRatio = t),
            this._runtime._SetDevicePixelRatio(t),
            this.SetSize(e.innerWidth, e.innerHeight),
            this._runtime.UpdateRender()
        }
        _OnFullscreenChange(e) {
            this._isDocumentFullscreen = !!e.isFullscreen,
            this.SetSize(e.innerWidth, e.innerHeight, !0),
            this._runtime.UpdateRender()
        }
        _OnFullscreenError(e) {
            this._isDocumentFullscreen = !!e.isFullscreen,
            this.SetSize(e.innerWidth, e.innerHeight, !0),
            this._runtime.UpdateRender()
        }
        SetSize(e, t, n=!1) {
            var r = Math.floor;
            if (e = r(e),
            t = r(t),
            0 >= e || 0 >= t)
                throw new Error('invalid size');
            if (this._windowInnerWidth !== e || this._windowInnerHeight !== t || n) {
                this._windowInnerWidth = e,
                this._windowInnerHeight = t;
                const a = this.GetCurrentFullscreenMode();
                'letterbox-scale' === a ? this._CalculateLetterboxScale(e, t) : 'letterbox-integer-scale' === a ? this._CalculateLetterboxIntegerScale(e, t) : 'off' === a ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t),
                this._UpdateFullscreenScalingQuality(a),
                this._canvas.width = this._canvasDeviceWidth,
                this._canvas.height = this._canvasDeviceHeight,
                this._runtime.PostComponentMessageToDOM('canvas', 'update-size', {
                    marginLeft: this._canvasCssOffsetX,
                    marginTop: this._canvasCssOffsetY,
                    styleWidth: this._canvasCssWidth,
                    styleHeight: this._canvasCssHeight
                }),
                this._webglRenderer.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0)
            }
        }
        _CalculateLetterboxScale(t, a) {
            var n = Math.round
              , r = Math.floor;
            const i = this._runtime.GetDevicePixelRatio()
              , e = this._runtime.GetOriginalViewportWidth()
              , l = this._runtime.GetOriginalViewportHeight()
              , _ = e / l;
            t / a > _ ? (this._canvasCssWidth = n(a * _),
            this._canvasCssHeight = a,
            this._canvasCssOffsetX = r((t - this._canvasCssWidth) / 2),
            this._canvasCssOffsetY = 0) : (this._canvasCssWidth = t,
            this._canvasCssHeight = n(t / _),
            this._canvasCssOffsetX = 0,
            this._canvasCssOffsetY = r((a - this._canvasCssHeight) / 2)),
            this._canvasDeviceWidth = n(this._canvasCssWidth * i),
            this._canvasDeviceHeight = n(this._canvasCssHeight * i),
            this._runtime.SetViewportSize(e, l)
        }
        _CalculateLetterboxIntegerScale(t, n) {
            var r = Math.max
              , l = Math.round
              , _ = Math.floor;
            const e = this._runtime.GetDevicePixelRatio();
            1 !== e && (t += 1,
            n += 1);
            const d = this._runtime.GetOriginalViewportWidth()
              , u = this._runtime.GetOriginalViewportHeight()
              , c = d / u
              , i = t / n;
            let g;
            if (i > c) {
                const t = n * c;
                g = t * e / d
            } else {
                const a = t / c;
                g = a * e / u
            }
            1 < g ? g = _(g) : 1 > g && (g = 1 / Math.ceil(1 / g)),
            this._canvasDeviceWidth = l(d * g),
            this._canvasDeviceHeight = l(u * g),
            this._canvasCssWidth = this._canvasDeviceWidth / e,
            this._canvasCssHeight = this._canvasDeviceHeight / e,
            this._canvasCssOffsetX = r(_((t - this._canvasCssWidth) / 2), 0),
            this._canvasCssOffsetY = r(_((n - this._canvasCssHeight) / 2), 0),
            this._runtime.SetViewportSize(d, u)
        }
        _CalculateFullsizeCanvas(t, a) {
            var n = Math.round;
            const r = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = t,
            this._canvasCssHeight = a,
            this._canvasDeviceWidth = n(this._canvasCssWidth * r),
            this._canvasDeviceHeight = n(this._canvasCssHeight * r),
            this._canvasCssOffsetX = 0,
            this._canvasCssOffsetY = 0;
            const i = this.GetDisplayScale();
            this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i)
        }
        _CalculateFixedSizeCanvas(t, a) {
            var n = Math.round
              , r = Math.floor;
            const i = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = this._runtime.GetViewportWidth(),
            this._canvasCssHeight = this._runtime.GetViewportHeight(),
            this._canvasDeviceWidth = n(this._canvasCssWidth * i),
            this._canvasDeviceHeight = n(this._canvasCssHeight * i),
            this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = r((t - this._canvasCssWidth) / 2),
            this._canvasCssOffsetY = r((a - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0,
            this._canvasCssOffsetY = 0),
            this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
        }
        _UpdateFullscreenScalingQuality(e) {
            if ('high' === this._wantFullscreenScalingQuality)
                this._drawWidth = this._canvasDeviceWidth,
                this._drawHeight = this._canvasDeviceHeight,
                this._fullscreenScalingQuality = 'high';
            else {
                let t, n;
                if ('off' === this.GetCurrentFullscreenMode() ? (t = this._runtime.GetViewportWidth(),
                n = this._runtime.GetViewportHeight()) : (t = this._runtime.GetOriginalViewportWidth(),
                n = this._runtime.GetOriginalViewportHeight()),
                this._canvasDeviceWidth < t && this._canvasDeviceHeight < n)
                    this._drawWidth = this._canvasDeviceWidth,
                    this._drawHeight = this._canvasDeviceHeight,
                    this._fullscreenScalingQuality = 'high';
                else if (this._drawWidth = t,
                this._drawHeight = n,
                this._fullscreenScalingQuality = 'low',
                'scale-inner' === e) {
                    const e = t / n
                      , a = this._windowInnerWidth / this._windowInnerHeight;
                    a < e ? this._drawWidth = this._drawHeight * a : a > e && (this._drawHeight = this._drawWidth / a)
                } else if ('scale-outer' === e) {
                    const e = t / n
                      , a = this._windowInnerWidth / this._windowInnerHeight;
                    a > e ? this._drawWidth = this._drawHeight * a : a < e && (this._drawHeight = this._drawWidth / a)
                }
            }
        }
        IsDocumentFullscreen() {
            return this._isDocumentFullscreen
        }
        SetFullscreenMode(t) {
            if (!e.has(t))
                throw new Error('invalid fullscreen mode');
            this._fullscreenMode = t
        }
        GetFullscreenMode() {
            return this._fullscreenMode
        }
        SetDocumentFullscreenMode(t) {
            if (!e.has(t))
                throw new Error('invalid fullscreen mode');
            this._documentFullscreenMode = t
        }
        GetDocumentFullscreenMode() {
            return this._documentFullscreenMode
        }
        GetCurrentFullscreenMode() {
            return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
        }
        SetFullscreenScalingQuality(e) {
            if (!t.has(e))
                throw new Error('invalid fullscreen scaling quality');
            this._wantFullscreenScalingQuality = e
        }
        GetSetFullscreenScalingQuality() {
            return this._wantFullscreenScalingQuality
        }
        GetCurrentFullscreenScalingQuality() {
            return this._fullscreenScalingQuality
        }
        static _FullscreenModeNumberToString(e) {
            switch (e) {
            case 0:
                return 'off';
            case 1:
                return 'crop';
            case 2:
                return 'scale-inner';
            case 3:
                return 'scale-outer';
            case 4:
                return 'letterbox-scale';
            case 5:
                return 'letterbox-integer-scale';
            default:
                throw new Error('invalid fullscreen mode');
            }
        }
        GetLastWidth() {
            return this._windowInnerWidth
        }
        GetLastHeight() {
            return this._windowInnerHeight
        }
        GetDrawWidth() {
            return this._drawWidth
        }
        GetDrawHeight() {
            return this._drawHeight
        }
        IsWebGLContextLost() {
            return this._webglRenderer.IsContextLost()
        }
        _OnWebGLContextLost(e) {
            console.log('[Construct 3] WebGL context lost'),
            e.preventDefault(),
            this._availableAdditionalRenderTargets = [],
            this._usedAdditionalRenderTargets.clear(),
            this._webglRenderer.OnContextLost(),
            this._runtime._OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this._webglRenderer.OnContextRestored(),
            await this._LoadShaderPrograms();
            for (const e of this._runtime._GetAllEffectLists())
                for (const t of e.GetAllEffectTypes())
                    t._InitRenderer(this._webglRenderer);
            await this._runtime._OnWebGLContextRestored(),
            console.log('[Construct 3] WebGL context restored')
        }
        GetWebGLRenderer() {
            return this._webglRenderer
        }
        GetRenderScale() {
            return 'low' === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
        }
        GetDisplayScale() {
            const t = this.GetCurrentFullscreenMode();
            if ('off' === t || 'crop' === t)
                return 1;
            const a = this._runtime.GetOriginalViewportWidth()
              , n = this._runtime.GetOriginalViewportHeight()
              , r = a / n
              , i = this._canvasDeviceWidth / this._canvasDeviceHeight;
            return 'scale-inner' !== t && i > r || 'scale-inner' === t && i < r ? this._canvasCssHeight / n : this._canvasCssWidth / a
        }
        SetDeviceTransformOffset(e, t) {
            this._deviceTransformOffX = e,
            this._deviceTransformOffY = t
        }
        SetDeviceTransform(t, a, n) {
            const r = (a || this._drawWidth) / 2 + this._deviceTransformOffX
              , i = (n || this._drawHeight) / 2 + this._deviceTransformOffY;
            t.SetCameraXYZ(r, i, 100 * this._runtime.GetDevicePixelRatio()),
            t.SetLookXYZ(r, i, 0),
            t.ResetModelView(),
            t.UpdateModelView()
        }
        SetCssTransform(e) {
            const t = this._canvasCssWidth / 2
              , a = this._canvasCssHeight / 2;
            e.SetCameraXYZ(t, a, 100),
            e.SetLookXYZ(t, a, 0),
            e.ResetModelView(),
            e.UpdateModelView()
        }
        GetDeviceWidth() {
            return this._canvasDeviceWidth
        }
        GetDeviceHeight() {
            return this._canvasDeviceHeight
        }
        GetCssWidth() {
            return this._canvasCssWidth
        }
        GetCssHeight() {
            return this._canvasCssHeight
        }
        GetCanvasClientX() {
            return this._canvasCssOffsetX
        }
        GetCanvasClientY() {
            return this._canvasCssOffsetY
        }
        GetAdditionalRenderTarget(e) {
            const t = this._availableAdditionalRenderTargets
              , a = t.findIndex(t=>t.IsCompatibleWithOptions(e));
            let n;
            return -1 === a ? n = this._webglRenderer.CreateRenderTarget(e) : (n = t[a],
            t.splice(a, 1)),
            this._usedAdditionalRenderTargets.add(n),
            n
        }
        ReleaseAdditionalRenderTarget(e) {
            if (!this._usedAdditionalRenderTargets.has(e))
                throw new Error('render target not in use');
            this._usedAdditionalRenderTargets.delete(e),
            this._availableAdditionalRenderTargets.push(e)
        }
        *activeLayersGpuProfiles() {
            for (const e of this._runtime.GetLayoutManager().runningLayouts())
                for (const t of e.GetLayers()) {
                    const e = this._layersGpuProfile.get(t);
                    e && (yield e)
                }
        }
        GetLayerTimingsBuffer(e) {
            if (!this._webglRenderer.SupportsGPUProfiling())
                return null;
            let t = this._layersGpuProfile.get(e);
            return t || (t = {
                name: e.GetName(),
                timingsBuffer: C3.New(C3.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
                curUtilisation: 0,
                lastUtilisation: 0
            },
            this._layersGpuProfile.set(e, t)),
            t.timingsBuffer
        }
        _Update1sFrameRange() {
            if (this._webglRenderer.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
                this._gpuTimeEndFrame = this._webglRenderer.GetFrameNumber(),
                this._gpuCurUtilisation = NaN;
                for (const e of this.activeLayersGpuProfiles())
                    e.curUtilisation = NaN
            }
        }
        _UpdateTick() {
            var e = Math.min;
            if (this._webglRenderer.SupportsGPUProfiling() && isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
            !isNaN(this._gpuCurUtilisation))) {
                if (this._runtime.IsDebug())
                    for (const e of this.activeLayersGpuProfiles())
                        if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
                        isNaN(e.curUtilisation))
                            return;
                if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
                this._gpuLastUtilisation = e(this._gpuCurUtilisation, 1),
                this._runtime.IsDebug()) {
                    for (const t of this.activeLayersGpuProfiles())
                        t.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
                        t.lastUtilisation = e(t.curUtilisation, 1);
                    C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
                }
                this._gpuTimeStartFrame = this._gpuTimeEndFrame,
                this._gpuTimeEndFrame = 0
            }
        }
        GetGPUFrameTimingsBuffer() {
            return this._gpuFrameTimingsBuffer
        }
        GetGPUUtilisation() {
            return this._gpuLastUtilisation
        }
        SnapshotCanvas(e, t) {
            return (this._snapshotFormat = e,
            this._snapshotQuality = t,
            this._snapshotPromise) ? this._snapshotPromise : (this._snapshotPromise = new Promise(e=>{
                this._snapshotResolve = e
            }
            ),
            this._snapshotPromise)
        }
        _MaybeTakeSnapshot() {
            this._snapshotFormat && (C3.CanvasToBlob(this._canvas, this._snapshotFormat, this._snapshotQuality).then(e=>{
                this._snapshotUrl = URL.createObjectURL(e),
                this._snapshotPromise = null,
                this._snapshotResolve(this._snapshotUrl)
            }
            ),
            this._snapshotFormat = '',
            this._snapshotQuality = 1)
        }
        GetCanvasSnapshotUrl() {
            return this._snapshotUrl
        }
        InitLoadingScreen(e) {
            if (2 === e)
                this._webglPercentText = C3.New(C3.Gfx.WebGLText, this._webglRenderer),
                this._webglPercentText.SetIsAsync(!1),
                this._webglPercentText.SetFontName('Arial'),
                this._webglPercentText.SetFontSize(16),
                this._webglPercentText.SetHorizontalAlignment('center'),
                this._webglPercentText.SetVerticalAlignment('center'),
                this._webglPercentText.SetSize(300, 200);
            else if (0 === e) {
                const e = this._runtime.GetAssetManager();
                let t;
                if (this._runtime.IsPreview()) {
                    if (!e._HasLocalUrlBlob('loading-logo.png'))
                        return;
                    t = e.GetLocalUrlAsBlobUrl('loading-logo.png')
                } else
                    t = e.GetIconsSubfolder() + 'loading-logo.png';
                this._loadingLogoAsset = e.LoadImage({
                    url: t
                }),
                this._loadingLogoAsset.LoadStaticTexture(this._webglRenderer).catch(()=>console.warn(`[C3 runtime] Failed to load 'loading-logo.png' for loading screen. Check the project has an icon with that name.`))
            } else
                4 == e && (this._LoadSvgSplashImage('splash-images/splash-logo.svg').then(e=>{
                    'done' === this._splashState ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.logo = e
                }
                ).catch(e=>console.warn('Failed to load splash image: ', e)),
                this._LoadBitmapSplashImage('splash-images/splash-poweredby-512.png').then(e=>{
                    'done' === this._splashState ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.powered = e
                }
                ).catch(e=>console.warn('Failed to load splash image: ', e)),
                this._LoadBitmapSplashImage('splash-images/splash-website-512.png').then(e=>{
                    'done' === this._splashState ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.website = e
                }
                ).catch(e=>console.warn('Failed to load splash image: ', e)))
        }
        async _LoadSvgSplashImage(e) {
            e = new URL(e,this._runtime.GetBaseURL()).toString();
            const t = await C3.FetchBlob(e)
              , n = await this._runtime.RasterSvgImage(t, 2048, 2048);
            return await this._webglRenderer.CreateStaticTextureAsync(n, {
                mipMapQuality: 'high'
            })
        }
        async _LoadBitmapSplashImage(e) {
            e = new URL(e,this._runtime.GetBaseURL()).toString();
            const t = await C3.FetchBlob(e);
            return await this._webglRenderer.CreateStaticTextureAsync(t, {
                mipMapQuality: 'high'
            })
        }
        StartLoadingScreen() {
            this._loaderStartTime = Date.now(),
            this._runtime.Dispatcher().addEventListener('loadingprogress', this._loadingprogress_handler),
            this._rafId = requestAnimationFrame(()=>this._DrawLoadingScreen())
        }
        async EndLoadingScreen() {
            this._loadingProgress = 1,
            4 === this._runtime.GetLoaderStyle() && (await this._splashDonePromise),
            this._splashDoneResolve = null,
            this._splashDonePromise = null,
            -1 !== this._rafId && (cancelAnimationFrame(this._rafId),
            this._rafId = -1),
            this._runtime.Dispatcher().removeEventListener('loadingprogress', this._loadingprogress_handler),
            this._loadingprogress_handler = null,
            this._webglPercentText && (this._webglPercentText.Release(),
            this._webglPercentText = null),
            this._loadingLogoAsset && (this._loadingLogoAsset.Release(),
            this._loadingLogoAsset = null),
            this._webglRenderer.Start(),
            this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo),
            this._splashTextures.logo = null),
            this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered),
            this._splashTextures.powered = null),
            this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website),
            this._splashTextures.website = null),
            this._webglRenderer.ClearRgba(0, 0, 0, 0),
            this._webglRenderer.Finish(),
            this._splashState = 'done',
            this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber()
        }
        _DrawLoadingScreen() {
            if (-1 !== this._rafId) {
                const e = this._webglRenderer;
                e.Start(),
                this._rafId = -1;
                const t = this._runtime.GetAssetManager().HasHadErrorLoading()
                  , a = this._runtime.GetLoaderStyle();
                if (3 !== a && (this.SetCssTransform(e),
                e.ClearRgba(0, 0, 0, 0),
                e.ResetColor(),
                e.SetTextureFillMode(),
                e.SetTexture(null)),
                0 === a)
                    this._DrawProgressBarAndLogoLoadingScreen(t);
                else if (1 === a)
                    this._DrawProgressBarLoadingScreen(t, 120, 0);
                else if (2 === a)
                    this._DrawPercentTextLoadingScreen(t);
                else if (3 === a)
                    C3.noop();
                else if (4 === a)
                    this._DrawSplashLoadingScreen(t);
                else
                    throw new Error('invalid loader style');
                e.Finish(),
                this._rafId = requestAnimationFrame(()=>this._DrawLoadingScreen())
            }
        }
        _DrawPercentTextLoadingScreen(e) {
            e ? this._webglPercentText.SetColorRgb(1, 0, 0) : this._webglPercentText.SetColorRgb(.6, .6, .6),
            this._webglPercentText.SetText(Math.round(100 * this._loadingProgress) + '%');
            const t = this._canvasCssWidth / 2
              , a = this._canvasCssHeight / 2;
            n.setRect(t - 150, a - 100, t + 150, a + 100),
            this._webglRenderer.SetTexture(this._webglPercentText.GetTexture()),
            this._webglRenderer.Quad3(n, this._webglPercentText.GetTexRect())
        }
        _DrawProgressBarLoadingScreen(t, a, n) {
            const r = this._webglRenderer;
            r.SetColorFillMode(),
            t ? r.SetColorRgba(1, 0, 0, 1) : r.SetColorRgba(.118, .565, 1, 1);
            const e = this._canvasCssWidth / 2
              , i = this._canvasCssHeight / 2
              , l = a / 2;
            _.setWH(e - l, i - 4 + n, Math.floor(a * this._loadingProgress), 8),
            r.Rect(_),
            _.setWH(e - l, i - 4 + n, a, 8),
            _.offset(-.5, -.5),
            _.inflate(.5, .5),
            r.SetColorRgba(0, 0, 0, 1),
            r.LineRect2(_),
            _.inflate(1, 1),
            r.SetColorRgba(1, 1, 1, 1),
            r.LineRect2(_)
        }
        _DrawProgressBarAndLogoLoadingScreen(t) {
            if (!this._loadingLogoAsset)
                return void this._DrawProgressBarLoadingScreen(t, 120, 0);
            const a = this._loadingLogoAsset.GetTexture();
            if (!a)
                return void this._DrawProgressBarLoadingScreen(t, 120, 0);
            const r = a.GetWidth()
              , l = a.GetHeight()
              , e = this._canvasCssWidth / 2
              , _ = this._canvasCssHeight / 2
              , d = r / 2
              , u = l / 2;
            n.setRect(e - d, _ - u, e + d, _ + u),
            this._webglRenderer.SetTexture(a),
            this._webglRenderer.Quad(n),
            this._DrawProgressBarLoadingScreen(t, r, u + 16)
        }
        _DrawSplashLoadingScreen(t) {
            var d = Math.min
              , u = Math.max
              , e = Math.ceil;
            const c = this._webglRenderer
              , g = this._splashTextures.logo
              , i = this._splashTextures.powered
              , f = this._splashTextures.website
              , S = Date.now();
            0 === this._splashFrameNumber && (this._loaderStartTime = S);
            const l = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()
              , m = l ? 0 : 200
              , n = l ? 0 : 3e3;
            let y = 1;
            'fade-in' === this._splashState ? y = d((S - this._loaderStartTime) / 300, 1) : 'fade-out' === this._splashState && (y = u(1 - (S - this._splashFadeOutStartTime) / 300, 0)),
            c.SetColorFillMode(),
            c.SetColorRgba(.231 * y, .251 * y, .271 * y, y),
            _.set(0, 0, this._canvasCssWidth, this._canvasCssHeight),
            c.Rect(_);
            const G = e(this._canvasCssWidth)
              , a = e(this._canvasCssHeight);
            let b, T;
            256 < this._canvasCssHeight ? (c.SetColorRgba(.302 * y, .334 * y, .365 * y, y),
            b = G,
            T = u(.005 * a, 2),
            _.setWH(0, .8 * a - T / 2, b, T),
            c.Rect(_),
            t ? c.SetColorRgba(y, 0, 0, y) : c.SetColorRgba(.161 * y, .953 * y, .816 * y, y),
            b = G * this._loadingProgress,
            _.setWH(.5 * G - b / 2, .8 * a - T / 2, b, T),
            c.Rect(_),
            c.SetColorRgba(y, y, y, y),
            c.SetTextureFillMode(),
            i && (b = 1.5 * C3.clamp(.22 * a, 105, .6 * G),
            T = b / 8,
            _.setWH(.5 * G - b / 2, .2 * a - T / 2, b, T),
            c.SetTexture(i),
            c.Rect(_)),
            g && (b = d(.395 * a, .95 * G),
            T = b,
            _.setWH(.5 * G - b / 2, .485 * a - T / 2, b, T),
            c.SetTexture(g),
            c.Rect(_)),
            f && (b = 1.5 * C3.clamp(.22 * a, 105, .6 * G),
            T = b / 8,
            _.setWH(.5 * G - b / 2, .868 * a - T / 2, b, T),
            c.SetTexture(f),
            c.Rect(_))) : (c.SetColorRgba(.302 * y, .334 * y, .365 * y, y),
            b = G,
            T = u(.005 * a, 2),
            _.setWH(0, .85 * a - T / 2, b, T),
            c.Rect(_),
            t ? c.SetColorRgba(y, 0, 0, y) : c.SetColorRgba(.161 * y, .953 * y, .816 * y, y),
            b = G * this._loadingProgress,
            _.setWH(.5 * G - b / 2, .85 * a - T / 2, b, T),
            c.Rect(_),
            c.SetColorRgba(y, y, y, y),
            c.SetTextureFillMode(),
            g && (b = .55 * a,
            T = b,
            _.setWH(.5 * G - b / 2, .45 * a - T / 2, b, T),
            c.SetTexture(g),
            c.Rect(_))),
            this._splashFrameNumber++,
            'fade-in' === this._splashState && 300 <= S - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = 'wait',
            this._splashFadeInFinishTime = S),
            'wait' === this._splashState && S - this._splashFadeInFinishTime >= n && 1 <= this._loadingProgress && (this._splashState = 'fade-out',
            this._splashFadeOutStartTime = S),
            ('fade-out' === this._splashState && S - this._splashFadeOutStartTime >= 300 + m || l && 1 <= this._loadingProgress && 500 > S - this._loaderStartTime) && this._splashDoneResolve()
        }
    }
}
{
    const l = {
        messagePort: null,
        baseUrl: '',
        headless: !1,
        hasDom: !0,
        isInWorker: !1,
        useAudio: !0,
        projectData: '',
        exportType: ''
    };
    let _ = !0;
    C3.Runtime = class extends C3.DefendedBase {
        constructor(e) {
            e = Object.assign({}, l, e),
            super(),
            this._messagePort = e.messagePort,
            this._baseUrl = e.baseUrl,
            this._isHeadless = !!e.headless,
            this._hasDom = !!e.hasDom,
            this._isInWorker = !!e.isInWorker,
            _ = e.ife,
            this._useAudio = !!e.useAudio,
            this._exportType = e.exportType,
            this._isiOSCordova = !!e.isiOSCordova,
            this._isiOSWebView = !!e.isiOSWebView,
            this._isFBInstantAvailable = !!e.isFBInstantAvailable,
            this._opusWasmScriptUrl = e.opusWasmScriptUrl,
            this._opusWasmBinaryUrl = e.opusWasmBinaryUrl,
            this._dataJsonFilename = 'data.json',
            this._isDebug = !!('preview' === this._exportType && e.isDebug),
            this._breakpointsEnabled = this._isDebug,
            this._isDebugging = this._isDebug,
            this._debuggingDisabled = 0;
            const a = e.previewImageBlobs
              , t = e.previewProjectFileBlobs;
            t && Object.assign(a, t);
            const d = e.projectData;
            d && (a[this._dataJsonFilename] = d),
            this._additionalLoadPromises = [],
            this._projectName = '',
            this._projectVersion = '',
            this._projectUniqueId = '',
            this._appId = '',
            this._originalViewportWidth = 0,
            this._originalViewportHeight = 0,
            this._devicePixelRatio = self.devicePixelRatio,
            this._parallaxXorigin = 0,
            this._parallaxYorigin = 0,
            this._viewportWidth = 0,
            this._viewportHeight = 0,
            this._loaderStyle = 0,
            this._usesLoaderLayout = !1,
            this._isLoading = !0,
            this._usesAnyBackgroundBlending = !1;
            const i = 'html5' === this._exportType || 'scirra-arcade' === this._exportType || 'instant-games' === this._exportType;
            this._assetManager = C3.New(C3.AssetManager, this, {
                defaultLoadPolicy: i ? 'remote' : 'local',
                localUrlBlobs: a,
                isCordova: 'cordova' === this._exportType,
                isiOSCordova: this._isiOSCordova,
                supportedAudioFormats: e.supportedAudioFormats
            }),
            this._layoutManager = C3.New(C3.LayoutManager, this),
            this._eventSheetManager = C3.New(C3.EventSheetManager, this),
            this._pluginManager = C3.New(C3.PluginManager, this),
            this._collisionEngine = C3.New(C3.CollisionEngine, this),
            this._timelineManager = C3.New(C3.TimelineManager, this),
            this._transitionManager = C3.New(C3.TransitionManager, this),
            this._allObjectClasses = [],
            this._objectClassesByName = new Map,
            this._objectClassesBySid = new Map,
            this._familyCount = 0,
            this._allContainers = [],
            this._allEffectLists = [],
            this._currentLayoutStack = [],
            this._instancesPendingCreate = [],
            this._instancesPendingDestroy = new Map,
            this._hasPendingInstances = !1,
            this._isFlushingPendingInstances = !1,
            this._objectCount = 0,
            this._nextUid = 0,
            this._instancesByUid = new Map,
            this._instancesToReleaseAtEndOfTick = new Set,
            this._instancesToReleaseAffectedObjectClasses = new Set,
            this._objectReferenceTable = [],
            this._jsPropNameTable = [],
            this._canvasManager = null,
            this._framerateMode = 'vsync',
            this._compositingMode = 'standard',
            this._sampling = 'trilinear',
            this._isPixelRoundingEnabled = !1,
            this._needRender = !0,
            this._pauseOnBlur = !1,
            this._isPausedOnBlur = !1,
            this._tickCallbacks = {
                normal: t=>{
                    this._rafId = -1,
                    this._ruafId = -1,
                    this.Tick(t)
                }
                ,
                tickOnly: t=>{
                    this._ruafId = -1,
                    this.Tick(t, !1, 'skip-render')
                }
                ,
                renderOnly: ()=>{
                    this._rafId = -1,
                    this.Render()
                }
            },
            this._rafId = -1,
            this._ruafId = -1,
            this._tickCount = 0,
            this._tickCountNoSave = 0,
            this._execCount = 0,
            this._hasStarted = !1,
            this._isInTick = !1,
            this._hasStartedTicking = !1,
            this._isLayoutFirstTick = !0,
            this._suspendCount = 0,
            this._scheduleTriggersThrottle = new C3.PromiseThrottle(1),
            this._randomNumberCallback = ()=>Math.random(),
            this._startTime = 0,
            this._lastTickTime = 0,
            this._dt1 = 0,
            this._dt = 0,
            this._timeScale = 1,
            this._minimumFramerate = 30,
            this._gameTime = C3.New(C3.KahanSum),
            this._wallTime = C3.New(C3.KahanSum),
            this._fpsFrameCount = -1,
            this._fpsLastTime = 0,
            this._fps = 0,
            this._mainThreadTimeCounter = 0,
            this._mainThreadTime = 0,
            this._isLoadingState = !1,
            this._saveToSlotName = '',
            this._loadFromSlotName = '',
            this._loadFromJson = null,
            this._lastSaveJson = '',
            this._triggerOnCreateAfterLoad = [],
            this._projectStorage = null,
            this._savegamesStorage = null,
            this._dispatcher = C3.New(C3.Event.Dispatcher),
            this._domEventHandlers = new Map,
            this._pendingResponsePromises = new Map,
            this._nextDomResponseId = 0,
            this._didRequestDeviceOrientationEvent = !1,
            this._didRequestDeviceMotionEvent = !1,
            this._isReadyToHandleEvents = !1,
            this._waitingToHandleEvents = [],
            this._eventObjects = {
                pretick: C3.New(C3.Event, 'pretick', !1),
                tick: C3.New(C3.Event, 'tick', !1),
                tick2: C3.New(C3.Event, 'tick2', !1),
                instancedestroy: C3.New(C3.Event, 'instancedestroy', !1),
                beforelayoutchange: C3.New(C3.Event, 'beforelayoutchange', !1),
                layoutchange: C3.New(C3.Event, 'layoutchange', !1)
            },
            this._eventObjects.instancedestroy.instance = null,
            this._userScriptDispatcher = C3.New(C3.Event.Dispatcher),
            this._userScriptEventObjects = null,
            this._behInstsToTick = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence),
            this._behInstsToPostTick = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence),
            this._behInstsToTick2 = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence),
            this._jobScheduler = C3.New(C3.JobSchedulerRuntime, this, e.jobScheduler),
            e.canvas && (this._canvasManager = C3.New(C3.CanvasManager, this)),
            this._messagePort.onmessage = e=>this._OnMessageFromDOM(e.data),
            this.AddDOMComponentMessageHandler('runtime', 'visibilitychange', e=>this._OnVisibilityChange(e)),
            this.AddDOMComponentMessageHandler('runtime', 'opus-decode', e=>this._WasmDecodeWebMOpus(e.arrayBuffer)),
            this.AddDOMComponentMessageHandler('runtime', 'get-remote-preview-status-info', ()=>this._GetRemotePreviewStatusInfo()),
            this.AddDOMComponentMessageHandler('runtime', 'js-invoke-function', e=>this._InvokeFunctionFromJS(e)),
            this.AddDOMComponentMessageHandler('runtime', 'go-to-last-error-script', self.goToLastErrorScript),
            this._dispatcher.addEventListener('window-blur', e=>this._OnWindowBlur(e)),
            this._dispatcher.addEventListener('window-focus', ()=>this._OnWindowFocus()),
            this._timelineManager.AddRuntimeListeners(),
            this._iRuntime = null,
            this._interfaceMap = new WeakMap,
            this._commonScriptInterfaces = {
                keyboard: null,
                mouse: null,
                touch: null
            }
        }
        static Create(t) {
            return C3.New(C3.Runtime, t)
        }
        Release() {
            C3.clearArray(this._allObjectClasses),
            this._objectClassesByName.clear(),
            this._objectClassesBySid.clear(),
            this._layoutManager.Release(),
            this._layoutManager = null,
            this._eventSheetManager.Release(),
            this._eventSheetManager = null,
            this._pluginManager.Release(),
            this._pluginManager = null,
            this._assetManager.Release(),
            this._assetManager = null,
            this._collisionEngine.Release(),
            this._collisionEngine = null,
            this._timelineManager.Release(),
            this._timelineManager = null,
            this._transitionManager.Release(),
            this._transitionManager = null,
            this._canvasManager && (this._canvasManager.Release(),
            this._canvasManager = null),
            this._dispatcher.Release(),
            this._dispatcher = null,
            this._tickEvent = null
        }
        ['_OnMessageFromDOM'](t) {
            const e = t.type;
            if ('event' === e)
                this._OnEventFromDOM(t);
            else if ('result' === e)
                this._OnResultFromDOM(t);
            else
                throw new Error(`unknown message '${e}'`)
        }
        _OnEventFromDOM(u) {
            if (!this._isReadyToHandleEvents)
                return void this._waitingToHandleEvents.push(u);
            const c = u.component
              , g = u.handler
              , m = u.data
              , e = u.dispatchOpts
              , t = !!(e && e.dispatchRuntimeEvent)
              , a = !!(e && e.dispatchUserScriptEvent)
              , n = u.responseId;
            if ('runtime' === c) {
                if (t) {
                    const t = new C3.Event(g);
                    t.data = m,
                    this._dispatcher.dispatchEventAndWaitAsyncSequential(t)
                }
                if (a) {
                    const t = new C3.Event(g,!0);
                    for (const [e,a] of Object.entries(m))
                        t[e] = a;
                    this.DispatchUserScriptEvent(t)
                }
            }
            const r = this._domEventHandlers.get(c);
            if (!r)
                return void (t || a || console.warn(`[Runtime] No DOM event handlers for component '${c}'`));
            const i = r.get(g);
            if (!i)
                return void (t || a || console.warn(`[Runtime] No DOM handler '${g}' for component '${c}'`));
            let _ = null;
            try {
                _ = i(m)
            } catch (e) {
                return console.error(`Exception in '${c}' handler '${g}':`, e),
                void (null !== n && this._PostResultToDOM(n, !1, '' + e))
            }
            null !== n && (_ && _.then ? _.then(t=>this._PostResultToDOM(n, !0, t)).catch(e=>{
                console.error(`Rejection from '${c}' handler '${g}':`, e),
                this._PostResultToDOM(n, !1, '' + e)
            }
            ) : this._PostResultToDOM(n, !0, _))
        }
        _PostResultToDOM(t, e, a) {
            this._messagePort.postMessage({
                type: 'result',
                responseId: t,
                isOk: e,
                result: a
            })
        }
        _OnResultFromDOM(r) {
            const e = r.responseId
              , a = r.isOk
              , n = r.result
              , t = this._pendingResponsePromises.get(e);
            a ? t.resolve(n) : t.reject(n),
            this._pendingResponsePromises.delete(e)
        }
        AddDOMComponentMessageHandler(r, e, a) {
            let n = this._domEventHandlers.get(r);
            if (n || (n = new Map,
            this._domEventHandlers.set(r, n)),
            n.has(e))
                throw new Error(`[Runtime] Component '${r}' already has handler '${e}'`);
            n.set(e, a)
        }
        PostComponentMessageToDOM(t, e, a) {
            this._messagePort.postMessage({
                type: 'event',
                component: t,
                handler: e,
                data: a,
                responseId: null
            })
        }
        PostComponentMessageToDOMAsync(r, e, a) {
            const n = this._nextDomResponseId++
              , t = new Promise((t,e)=>{
                this._pendingResponsePromises.set(n, {
                    resolve: t,
                    reject: e
                })
            }
            );
            return this._messagePort.postMessage({
                type: 'event',
                component: r,
                handler: e,
                data: a,
                responseId: n
            }),
            t
        }
        PostToDebugger(t) {
            if (!this.IsDebug())
                throw new Error('not in debug mode');
            this.PostComponentMessageToDOM('runtime', 'post-to-debugger', t)
        }
        async Init(t) {
            this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            const [e] = await Promise.all([this._assetManager.FetchJson(this._dataJsonFilename), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init() ]);
            this._LoadDataJson(e),
            await this._InitialiseCanvas(t),
            this.IsPreview() || console.info('Made with Construct 3, the game and app creator :: https://www.construct.net');
            const a = this.GetWebGLRenderer();
            a ? (console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? 'worker' : 'DOM'}, rendering with WebGL ${a.GetWebGLVersionNumber()} [${a.GetUnmaskedRenderer()}] (${a.IsDesynchronized() ? 'desynchronized' : 'standard'} compositing)`),
            a.HasMajorPerformanceCaveat() && console.warn('[C3 runtime] WebGL indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.')) : console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? 'worker' : 'DOM'}, headless`),
            this._isReadyToHandleEvents = !0;
            for (const e of this._waitingToHandleEvents)
                this._OnEventFromDOM(e);
            C3.clearArray(this._waitingToHandleEvents),
            this._canvasManager && this._canvasManager.StartLoadingScreen();
            for (const e of t.runOnStartupFunctions)
                this._additionalLoadPromises.push(this._RunOnStartupFunction(e));

            if (await Promise.all([this._assetManager.WaitForAllToLoad() , ...this._additionalLoadPromises]),
                C3.clearArray(this._additionalLoadPromises),
                !this._assetManager.HasHadErrorLoading()) {
                return this._canvasManager && (await this._canvasManager.EndLoadingScreen()),
                await this._dispatcher.dispatchEventAndWaitAsync(new C3.Event('beforeruntimestart')),
                await this.Start(),
                this._messagePort.postMessage({
                    type: 'runtime-ready'
                }),
                this
			}
        }
        async _RunOnStartupFunction(t) {
            try {
                await t(this._iRuntime)
            } catch (t) {
                console.error('[C3 runtime] Error in runOnStartup function: ', t)
            }
        }
        _LoadDataJson(r) {
            const e = r.project;
            this._projectName = e[0],
            this._projectVersion = e[16],
            this._projectUniqueId = e[31],
            this._appId = e[38],
            this._isPixelRoundingEnabled = !!e[9],
            this._originalViewportWidth = this._viewportWidth = e[10],
            this._originalViewportHeight = this._viewportHeight = e[11],
            this._parallaxXorigin = this._originalViewportWidth / 2,
            this._parallaxYorigin = this._originalViewportHeight / 2,
            this._compositingMode = e[36],
            this._framerateMode = e[37],
            'low-latency' === this._compositingMode && this.IsAndroidWebView() && 77 >= C3.Platform.BrowserVersionNumber && (console.warn('[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing.'),
            this._compositingMode = 'standard'),
            this._sampling = e[14],
            this._usesLoaderLayout = !!e[18],
            this._loaderStyle = e[19],
            this._nextUid = e[21],
            this._pauseOnBlur = e[22],
            this._assetManager._SetAudioFiles(e[7], e[25]),
            this._assetManager._SetMediaSubfolder(e[8]),
            this._assetManager._SetFontsSubfolder(e[32]),
            this._assetManager._SetIconsSubfolder(e[28]),
            this._assetManager._SetWebFonts(e[29]),
            this._canvasManager && (this._canvasManager.SetFullscreenMode(C3.CanvasManager._FullscreenModeNumberToString(e[12])),
            this._canvasManager.SetFullscreenScalingQuality(e[23] ? 'high' : 'low'),
            this._canvasManager._SetGPUPowerPreference(e[34])),
            this._pluginManager.CreateSystemPlugin(),
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            for (const t of e[2])
                this._pluginManager.CreatePlugin(t);
            this._objectReferenceTable = self.C3_GetObjectRefTable(),
            this._LoadJsPropNameTable();
            for (const t of e[3]) {
                const a = C3.ObjectClass.Create(this, this._allObjectClasses.length, t);
                this._allObjectClasses.push(a),
                this._objectClassesByName.set(a.GetName().toLowerCase(), a),
                this._objectClassesBySid.set(a.GetSID(), a)
            }
            for (const t of e[4]) {
                const a = this._allObjectClasses[t[0]];
                a._LoadFamily(t)
            }
            for (const t of e[27]) {
                const a = t.map(t=>this._allObjectClasses[t]);
                this._allContainers.push(C3.New(C3.Container, this, a))
            }
            for (const e of this._allObjectClasses)
                e._OnAfterCreate();
            for (const t of e[5])
                this._layoutManager.Create(t);
            const a = e[1];
            if (a) {
                const t = this._layoutManager.GetLayoutByName(a);
                t && this._layoutManager.SetFirstLayout(t)
            }
            for (const t of e[33])
                this._timelineManager.Create(t);
            for (const t of e[35])
                this._transitionManager.Create(t);
            this._InitScriptInterfaces();
            for (const t of e[6])
                this._eventSheetManager.Create(t);
            this._eventSheetManager._PostInit(),
            this._InitGlobalVariableScriptInterface(),
            C3.clearArray(this._objectReferenceTable),
            this.FlushPendingInstances();
            let n = 'any';
            const i = e[20];
            1 === i ? n = 'portrait' : 2 === i && (n = 'landscape'),
            this.PostComponentMessageToDOM('runtime', 'set-target-orientation', {
                targetOrientation: n
            })
        }
        GetLoaderStyle() {
            return this._loaderStyle
        }
        IsFBInstantAvailable() {
            return this._isFBInstantAvailable
        }
        IsLoading() {
            return this._isLoading
        }
        AddLoadPromise(t) {
            this._additionalLoadPromises.push(t)
        }
        _GetNextFamilyIndex() {
            return this._familyCount++
        }
        GetFamilyCount() {
            return this._familyCount
        }
        _AddEffectList(t) {
            this._allEffectLists.push(t)
        }
        _GetAllEffectLists() {
            return this._allEffectLists
        }
        async _InitialiseCanvas(t) {
            this._canvasManager && (
                await this._canvasManager.CreateCanvas(t),
                this._canvasManager.InitLoadingScreen(this._loaderStyle)
            )
        }
        async _MaybeLoadOpusDecoder() {
            if (this._assetManager.IsAudioFormatSupported('audio/webm; codecs=opus'))
                return;
            let t = null
              , n = null;
            try {
                this.IsiOSCordova() ? n = await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : t = await this._assetManager.FetchBlob(this._opusWasmBinaryUrl)
            } catch (t) {
                return void console.info('Failed to fetch Opus decoder WASM; assuming project has no Opus audio.', t)
            }
            n ? this.AddJobWorkerBuffer(n, 'opus-decoder-wasm') : this.AddJobWorkerBlob(t, 'opus-decoder-wasm'),
            await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
        }
        async _WasmDecodeWebMOpus(t) {
            const e = await this.AddJob('OpusDecode', {
                arrayBuffer: t
            }, [t]);
            return e
        }
        async Start() {
            if (this._hasStarted = !0,
            this._startTime = Date.now(),
            this._usesLoaderLayout) {
                for (const t of this._allObjectClasses)
                    t.IsFamily() || t.IsOnLoaderLayout() || !t.IsWorldType() || t.OnCreate();
                this._assetManager.WaitForAllToLoad().then(()=>{
                    this._isLoading = !1,
                    this._OnLoadFinished()
                })
            } else
                this._isLoading = !1;
            this._assetManager.SetInitialLoadFinished(),
            this.IsDebug() && C3Debugger.RuntimeInit(_);
            for (const t of this._layoutManager.GetAllLayouts())
                t._CreateGlobalNonWorlds();
            const t = this._layoutManager.GetFirstLayout();
            await t._Load(null, this.GetWebGLRenderer()),
            await t._StartRunning(!0),
            this._fpsLastTime = performance.now(),
            this._usesLoaderLayout || this._OnLoadFinished();
            const e = await this.PostComponentMessageToDOMAsync('runtime', 'before-start-ticking');
            e.isSuspended ? this._suspendCount++ : this.Tick()
        }
        _OnLoadFinished() {
            this.Trigger(C3.Plugins.System.Cnds.OnLoadFinished, null, null),
            this.PostComponentMessageToDOM('runtime', 'register-sw')
        }
        GetObjectReference(t) {
            t = Math.floor(t);
            const n = this._objectReferenceTable;
            if (0 > t || t >= n.length)
                throw new Error('invalid object reference');
            return n[t]
        }
        _LoadJsPropNameTable() {
            for (const t of self.C3_JsPropNameTable) {
                const e = C3.first(Object.keys(t));
                this._jsPropNameTable.push(e)
            }
        }
        GetJsPropName(t) {
            t = Math.floor(t);
            const n = this._jsPropNameTable;
            if (0 > t || t >= n.length)
                throw new Error('invalid prop reference');
            return n[t]
        }
        HasDOM() {
            return this._hasDom
        }
        IsHeadless() {
            return this._isHeadless
        }
        IsInWorker() {
            return this._isInWorker
        }
        GetBaseURL() {
            return this._baseUrl
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetEventStack() {
            return this._eventSheetManager.GetEventStack()
        }
        GetCurrentEventStackFrame() {
            return this._eventSheetManager.GetCurrentEventStackFrame()
        }
        GetCurrentEvent() {
            return this._eventSheetManager.GetCurrentEvent()
        }
        GetCurrentCondition() {
            return this._eventSheetManager.GetCurrentCondition()
        }
        IsCurrentConditionFirst() {
            return 0 === this.GetCurrentEventStackFrame().GetConditionIndex()
        }
        GetCurrentAction() {
            return this._eventSheetManager.GetCurrentAction()
        }
        GetPluginManager() {
            return this._pluginManager
        }
        GetSystemPlugin() {
            return this._pluginManager.GetSystemPlugin()
        }
        GetObjectClassByIndex(t) {
            if (t = Math.floor(t),
            0 > t || t >= this._allObjectClasses.length)
                throw new RangeError('invalid index');
            return this._allObjectClasses[t]
        }
        GetObjectClassByName(t) {
            return this._objectClassesByName.get(t.toLowerCase()) || null
        }
        GetObjectClassBySID(t) {
            return this._objectClassesBySid.get(t) || null
        }
        GetSingleGlobalObjectClassByCtor(t) {
            const e = this._pluginManager.GetPluginByConstructorFunction(t);
            return e ? e.GetSingleGlobalObjectClass() : null
        }
        GetAllObjectClasses() {
            return this._allObjectClasses
        }
        Dispatcher() {
            return this._dispatcher
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(t) {
            const a = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
            a && C3Debugger.StartMeasuringScriptTime(),
            this._userScriptDispatcher.dispatchEvent(t),
            a && C3Debugger.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(e) {
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(e)
        }
        GetOriginalViewportWidth() {
            return this._originalViewportWidth
        }
        GetOriginalViewportHeight() {
            return this._originalViewportHeight
        }
        SetOriginalViewportSize(t, e) {
            this._originalViewportWidth = t,
            this._originalViewportHeight = e
        }
        GetViewportWidth() {
            return this._viewportWidth
        }
        GetViewportHeight() {
            return this._viewportHeight
        }
        SetViewportSize(t, e) {
            this._viewportWidth = t,
            this._viewportHeight = e
        }
        _SetDevicePixelRatio(t) {
            this._devicePixelRatio = t
        }
        GetDevicePixelRatio() {
            return this._devicePixelRatio
        }
        GetParallaxXOrigin() {
            return this._parallaxXorigin
        }
        GetParallaxYOrigin() {
            return this._parallaxYorigin
        }
        GetCanvasManager() {
            return this._canvasManager
        }
        GetDrawWidth() {
            return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
        }
        GetDrawHeight() {
            return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
        }
        GetRenderScale() {
            return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
        }
        GetDisplayScale() {
            return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
        }
        GetCanvasClientX() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
        }
        GetCanvasClientY() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
        }
        GetCanvasCssWidth() {
            return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
        }
        GetCanvasCssHeight() {
            return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
        }
        GetFullscreenMode() {
            return this._canvasManager ? this._canvasManager.GetFullscreenMode() : 'off'
        }
        GetAdditionalRenderTarget(t) {
            return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(t) : null
        }
        ReleaseAdditionalRenderTarget(t) {
            this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(t)
        }
        _SetUsesAnyBackgroundBlending(t) {
            this._usesAnyBackgroundBlending = !!t
        }
        UsesAnyBackgroundBlending() {
            return this._usesAnyBackgroundBlending
        }
        GetGPUUtilisation() {
            return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
        }
        IsLinearSampling() {
            return 'nearest' !== this.GetSampling()
        }
        GetFramerateMode() {
            return this._framerateMode
        }
        GetCompositingMode() {
            return this._compositingMode
        }
        GetSampling() {
            return this._sampling
        }
        UsesLoaderLayout() {
            return this._usesLoaderLayout
        }
        GetLayoutManager() {
            return this._layoutManager
        }
        GetMainRunningLayout() {
            return this._layoutManager.GetMainRunningLayout()
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetTransitionManager() {
            return this._transitionManager
        }
        GetAssetManager() {
            return this._assetManager
        }
        LoadImage(t) {
            return this._assetManager.LoadImage(t)
        }
        CreateInstance(r, e, a, n) {
            return this.CreateInstanceFromData(r, e, !1, a, n)
        }
        CreateInstanceFromData(h, e, f, n, t, y) {
            let i = null
              , G = null;
            if (h instanceof C3.ObjectClass) {
                if (G = h,
                G.IsFamily()) {
                    const t = G.GetFamilyMembers()
                      , e = Math.floor(this.Random() * t.length);
                    G = t[e]
                }
                i = G.GetDefaultInstanceData()
            } else
                i = h,
                G = this.GetObjectClassByIndex(i[1]);
            const b = G.GetPlugin().IsWorldType();
            if (this._isLoading && b && !G.IsOnLoaderLayout())
                return null;
            const d = e;
            b || (e = null);
            let _ = f && !y && i && !this._instancesByUid.has(i[2]) ? i[2] : this._nextUid++;
            const l = i ? i[0] : null
              , g = C3.New(C3.Instance, {
                runtime: this,
                objectType: G,
                layer: e,
                worldData: l,
                instVarData: i ? i[3] : null,
                uid: _
            });
            this._instancesByUid.set(_, g);
            let c = null;
            if (b && (c = g.GetWorldInfo(),
            'undefined' != typeof n && 'undefined' != typeof t && (c.SetX(n),
            c.SetY(t)),
            G._SetAnyCollisionCellChanged(!0)),
            e && (e._AddInstance(g, !0),
            (1 !== e.GetParallaxX() || 1 !== e.GetParallaxY()) && G._SetAnyInstanceParallaxed(!0),
            e.GetLayout().MaybeLoadTexturesFor(G)),
            this._objectCount++,
            G.IsInContainer() && !f && !y) {
                for (const r of G.GetContainer().objectTypes()) {
                    if (r === G)
                        continue;
                    const e = this.CreateInstanceFromData(r, d, !1, c ? c.GetX() : n, c ? c.GetY() : t, !0);
                    g._AddSibling(e)
                }
                for (const t of g.siblings()) {
                    t._AddSibling(g);
                    for (const e of g.siblings())
                        t !== e && t._AddSibling(e)
                }
            }
            G._SetIIDsStale();
            const T = i ? C3.cloneArray(i[5]) : null
              , m = i ? i[4].map(t=>C3.cloneArray(t)) : null
              , p = b && l && 14 === l.length;
            if (p && g._SetHasTilemap(),
            g._CreateSdkInstance(T, m),
            p) {
                const t = l[13];
                g.GetSdkInstance().LoadTilemapData(t[2], t[0], t[1])
            }
            return this._instancesPendingCreate.push(g),
            this._hasPendingInstances = !0,
            this.IsDebug() && C3Debugger.InstanceCreated(g),
            g
        }
        DestroyInstance(t) {
            if (this._instancesToReleaseAtEndOfTick.has(t))
                return;
            const e = t.GetObjectClass();
            let a = this._instancesPendingDestroy.get(e);
            if (a) {
                if (a.has(t))
                    return;
                a.add(t)
            } else
                a = new Set,
                a.add(t),
                this._instancesPendingDestroy.set(e, a);
            if (this.IsDebug() && C3Debugger.InstanceDestroyed(t),
            t._MarkDestroyed(),
            this._hasPendingInstances = !0,
            t.IsInContainer())
                for (const e of t.siblings())
                    this.DestroyInstance(e);
            if (!this._layoutManager.IsEndingLayout()) {
                const e = this.GetEventSheetManager();
                e.BlockFlushingInstances(!0),
                t._TriggerOnDestroyed(),
                e.BlockFlushingInstances(!1)
            }
        }
        FlushPendingInstances() {
            this._hasPendingInstances && (this._isFlushingPendingInstances = !0,
            this._FlushInstancesPendingCreate(),
            this._FlushInstancesPendingDestroy(),
            this._isFlushingPendingInstances = !1,
            this._hasPendingInstances = !1,
            this.UpdateRender())
        }
        _FlushInstancesPendingCreate() {
            for (const t of this._instancesPendingCreate) {
                const e = t.GetObjectClass();
                e._AddInstance(t);
                for (const a of e.GetFamilies())
                    a._AddInstance(t),
                    a._SetIIDsStale()
            }
            C3.clearArray(this._instancesPendingCreate)
        }
        _FlushInstancesPendingDestroy() {
            this._dispatcher.SetDelayRemoveEventsEnabled(!0);
            for (const [t,e] of this._instancesPendingDestroy.entries())
                this._FlushInstancesPendingDestroyForObjectClass(t, e),
                e.clear();
            this._instancesPendingDestroy.clear(),
            this._dispatcher.SetDelayRemoveEventsEnabled(!1)
        }
        _FlushInstancesPendingDestroyForObjectClass(t, r) {
            for (const i of r) {
                const t = this._eventObjects.instancedestroy;
                t.instance = i,
                this._dispatcher.dispatchEvent(t),
                this._instancesByUid.delete(i.GetUID());
                const e = i.GetWorldInfo();
                e && (e._RemoveFromCollisionCells(),
                e._RemoveFromRenderCells()),
                this._instancesToReleaseAtEndOfTick.add(i),
                this._objectCount--
            }
            C3.arrayRemoveAllInSet(t.GetInstances(), r),
            t._SetIIDsStale(),
            this._instancesToReleaseAffectedObjectClasses.add(t),
            0 === t.GetInstances().length && t._SetAnyInstanceParallaxed(!1);
            for (const e of t.GetFamilies())
                C3.arrayRemoveAllInSet(e.GetInstances(), r),
                e._SetIIDsStale(),
                this._instancesToReleaseAffectedObjectClasses.add(e);
            if (t.GetPlugin().IsWorldType()) {
                const t = new Set([...r].map(t=>t.GetWorldInfo().GetLayer()));
                for (const e of t)
                    e._RemoveAllInstancesInSet(r)
            }
        }
        _GetInstancesPendingCreate() {
            return this._instancesPendingCreate
        }
        _GetNewUID() {
            return this._nextUid++
        }
        _MapInstanceByUID(t, e) {
            this._instancesByUid.set(t, e)
        }
        _OnWebGLContextLost() {
            this._dispatcher.dispatchEvent(C3.New(C3.Event, 'webglcontextlost')),
            this.SetSuspended(!0);
            for (const t of this._allObjectClasses)
                !t.IsFamily() && t.HasLoadedTextures() && t.ReleaseTextures();
            this.GetMainRunningLayout()._OnWebGLContextLost(),
            C3.ImageInfo.OnWebGLContextLost(),
            C3.ImageAsset.OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer()),
            this._dispatcher.dispatchEvent(C3.New(C3.Event, 'webglcontextrestored')),
            this.SetSuspended(!1),
            this.UpdateRender()
        }
        _OnVisibilityChange(e) {
            this.SetSuspended(e.hidden)
        }
        _OnWindowBlur(e) {
            this.IsPreview() && this._pauseOnBlur && !C3.Platform.IsMobile && (e.data.parentHasFocus || (this.SetSuspended(!0),
            this._isPausedOnBlur = !0))
        }
        _OnWindowFocus() {
            this._isPausedOnBlur && (this.SetSuspended(!1),
            this._isPausedOnBlur = !1)
        }
        _RequestAnimationFrame() {
            const t = this._tickCallbacks;
            'vsync' === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(t.normal)) : 'unlimited-tick' === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C3.RequestUnlimitedAnimationFrame(t.tickOnly)),
            -1 === this._rafId && (this._rafId = self.requestAnimationFrame(t.renderOnly))) : -1 === this._ruafId && (this._ruafId = C3.RequestUnlimitedAnimationFrame(t.normal))
        }
        _CancelAnimationFrame() {
            -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId),
            this._rafId = -1),
            -1 !== this._ruafId && (C3.CancelUnlimitedAnimationFrame(this._ruafId),
            this._ruafId = -1)
        }
        IsSuspended() {
            return 0 < this._suspendCount
        }
        SetSuspended(t) {
            const e = this.IsSuspended();
            this._suspendCount += t ? 1 : -1,
            0 > this._suspendCount && (this._suspendCount = 0);
            const a = this.IsSuspended();
            if (!e && a)
                console.log('[Construct 3] Suspending'),
                this._CancelAnimationFrame(),
                this._dispatcher.dispatchEvent(C3.New(C3.Event, 'suspend')),
                this.Trigger(C3.Plugins.System.Cnds.OnSuspend, null, null);
            else if (e && !a) {
                console.log('[Construct 3] Resuming');
                const t = performance.now();
                this._lastTickTime = t,
                this._fpsLastTime = t,
                this._fpsFrameCount = 0,
                this._fps = 0,
                this._mainThreadTime = 0,
                this._mainThreadTimeCounter = 0,
                this._dispatcher.dispatchEvent(C3.New(C3.Event, 'resume')),
                this.Trigger(C3.Plugins.System.Cnds.OnResume, null, null),
                this.HitBreakpoint() || this.Tick(t)
            }
        }
        _AddBehInstToTick(t) {
            this._behInstsToTick.Add(t)
        }
        _AddBehInstToPostTick(t) {
            this._behInstsToPostTick.Add(t)
        }
        _AddBehInstToTick2(t) {
            this._behInstsToTick2.Add(t)
        }
        _RemoveBehInstToTick(t) {
            this._behInstsToTick.Remove(t)
        }
        _RemoveBehInstToPostTick(t) {
            this._behInstsToPostTick.Remove(t)
        }
        _RemoveBehInstToTick2(t) {
            this._behInstsToTick2.Remove(t)
        }
        _BehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const t of this._behInstsToTick)
                t.Tick();
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        _BehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const t of this._behInstsToPostTick)
                t.PostTick();
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        _BehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const t of this._behInstsToTick2)
                t.Tick2();
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        *_DebugBehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const t of this._behInstsToTick) {
                const e = t.Tick();
                C3.IsIterator(e) && (yield*e)
            }
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        *_DebugBehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const t of this._behInstsToPostTick) {
                const e = t.PostTick();
                C3.IsIterator(e) && (yield*e)
            }
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        *_DebugBehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const t of this._behInstsToTick2) {
                const e = t.Tick2();
                C3.IsIterator(e) && (yield*e)
            }
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        async Tick(l, r, _) {
            this._hasStartedTicking = !0;
            const n = 'background-wake' === _;
            if (this._hasStarted && (!this.IsSuspended() || r || n)) {
                const e = performance.now();
                this._isInTick = !0,
                l || (l = e),
                this._MeasureDt(l);
                const t = this.Step_BeforePreTick();
                this.IsDebugging() && (await t);
                const a = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick);
                a instanceof Promise && (await a);
                const i = this.Step_AfterPreTick();
                this.IsDebugging() && (await i),
                this._NeedsHandleSaveOrLoad() && (await this._HandleSaveOrLoad()),
                this.GetLayoutManager().IsPendingChangeMainLayout() && (await this._MaybeChangeLayout());
                const r = this.Step_RunEventsEtc();
                this.IsDebugging() && (await r),
                'background-wake' != _ && 'skip-render' != _ && this.Render(),
                this.IsSuspended() || n || this._RequestAnimationFrame(),
                this._tickCount++,
                this._tickCountNoSave++,
                this._execCount++,
                this._isInTick = !1,
                this._mainThreadTimeCounter += performance.now() - e
            }
        }
        async Step_BeforePreTick() {
            const t = this._eventSheetManager
              , e = this.IsDebug();
            this.FlushPendingInstances(),
            t.BlockFlushingInstances(!0),
            this.PushCurrentLayout(this.GetMainRunningLayout()),
            e && C3Debugger.StartMeasuringTime(),
            this.IsDebugging() ? await t.DebugRunScheduledWaits() : t.RunScheduledWaits(),
            e && C3Debugger.AddEventsTime(),
            this.PopCurrentLayout(),
            t.BlockFlushingInstances(!1),
            this.FlushPendingInstances(),
            t.BlockFlushingInstances(!0)
        }
        async Step_AfterPreTick() {
            const r = this.IsDebug()
              , e = this.IsDebugging()
              , a = this._dispatcher
              , n = this._eventObjects
              , t = this._userScriptEventObjects;
            r && C3Debugger.StartMeasuringTime(),
            e ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(),
            e ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(),
            r && C3Debugger.AddBehaviorTickTime(),
            r && C3Debugger.StartMeasuringTime(),
            e ? await this.DebugFireGeneratorEventAndBreak(n.tick) : a.dispatchEvent(n.tick),
            r && C3Debugger.AddPluginTickTime(),
            this._eventSheetManager.BlockFlushingInstances(!1),
            this.DispatchUserScriptEvent(t.tick)
        }
        async Step_RunEventsEtc() {
            const r = this._eventSheetManager
              , e = this._dispatcher
              , a = this._eventObjects
              , n = this.IsDebug()
              , t = this.IsDebugging();
            if (n && C3Debugger.StartMeasuringTime(),
            t ? await r.DebugRunEvents(this._layoutManager) : r.RunEvents(this._layoutManager),
            n && C3Debugger.AddEventsTime(),
            this._collisionEngine.ClearRegisteredCollisions(),
            0 < this._instancesToReleaseAtEndOfTick.size) {
                e.SetDelayRemoveEventsEnabled(!0);
                for (const t of this._instancesToReleaseAffectedObjectClasses)
                    t.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
                this._instancesToReleaseAffectedObjectClasses.clear(),
                this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
                for (const t of this._instancesToReleaseAtEndOfTick)
                    t.Release();
                this._instancesToReleaseAtEndOfTick.clear(),
                e.SetDelayRemoveEventsEnabled(!1)
            }
            this._isLayoutFirstTick = !1,
            r.BlockFlushingInstances(!0),
            n && C3Debugger.StartMeasuringTime(),
            t ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(),
            n && C3Debugger.AddBehaviorTickTime(),
            n && C3Debugger.StartMeasuringTime(),
            t ? await this.DebugFireGeneratorEventAndBreak(a.tick2) : e.dispatchEvent(a.tick2),
            n && C3Debugger.AddPluginTickTime(),
            r.BlockFlushingInstances(!1),
            t && (await r.RunQueuedDebugTriggersAsync())
        }
        async _MaybeChangeLayout() {
            const t = this.GetLayoutManager();
            for (let e = 0; t.IsPendingChangeMainLayout() && 10 > e++; )
                await this._DoChangeLayout(t.GetPendingChangeMainLayout())
        }
        _MeasureDt(t) {
            if (0 !== this._lastTickTime) {
                const e = Math.max(t - this._lastTickTime, 0);
                this._dt1 = e / 1e3;
                const a = 1 / this._minimumFramerate;
                .5 < this._dt1 ? this._dt1 = 0 : this._dt1 > a && (this._dt1 = a)
            }
            this._lastTickTime = t,
            this._dt = this._dt1 * this._timeScale,
            this._gameTime.Add(this._dt),
            this._wallTime.Add(this._dt1),
            this._canvasManager && this._canvasManager._UpdateTick(),
            1e3 <= t - this._fpsLastTime && (this._fpsLastTime += 1e3,
            1e3 <= t - this._fpsLastTime && (this._fpsLastTime = t),
            this._fps = this._fpsFrameCount,
            this._fpsFrameCount = 0,
            this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1),
            this._mainThreadTimeCounter = 0,
            this._canvasManager && this._canvasManager._Update1sFrameRange(),
            this._collisionEngine._Update1sStats(),
            this.IsDebug() && C3Debugger.Update1sPerfStats()),
            this._fpsFrameCount++
        }
        async _DoChangeLayout(r) {
            const e = this._dispatcher
              , a = this.GetLayoutManager()
              , n = a.GetMainRunningLayout();
            await n._StopRunning(),
            n._Unload(r, this.GetWebGLRenderer()),
            n === r && this._eventSheetManager.ClearAllScheduledWaits(),
            this._collisionEngine.ClearRegisteredCollisions(),
            e.dispatchEvent(this._eventObjects.beforelayoutchange),
            C3.Asyncify.SetHighThroughputMode(!0),
            await r._Load(n, this.GetWebGLRenderer()),
            C3.Asyncify.SetHighThroughputMode(!1),
            await r._StartRunning(!1),
            e.dispatchEvent(this._eventObjects.layoutchange),
            this.UpdateRender(),
            this._isLayoutFirstTick = !0,
            this.FlushPendingInstances()
        }
        UpdateRender() {
            this._needRender = !0
        }
        GetWebGLRenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
        }
        Render() {
            if (!this._canvasManager || this._canvasManager.IsWebGLContextLost())
                return;
            const r = this.GetWebGLRenderer();
            if (r.Start(),
            r.CheckForQueryResults(),
            !this._needRender)
                return void r.IncrementFrameNumber();
            const e = this.IsDebug();
            e && C3Debugger.StartMeasuringTime(),
            this._needRender = !1;
            let a = null;
            r.SupportsGPUProfiling() && (a = this._canvasManager.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(),
            r.StartQuery(a)),
            r.SetTextureFillMode(),
            r.SetAlphaBlend(),
            r.SetColorRgba(1, 1, 1, 1),
            r.SetRenderTarget(null),
            r.SetTexture(null);
            const i = this._layoutManager.GetMainRunningLayout();
            i.Draw(r),
            a && r.EndQuery(a),
            r.Finish(),
            e && (C3Debugger.AddDrawCallsTime(),
            C3Debugger.UpdateInspectHighlight()),
            this._canvasManager && this._canvasManager._MaybeTakeSnapshot()
        }
        Trigger(l, e, a) {
            if (!this._hasStarted)
                return !1;
            const n = !this._isInTick && !this._eventSheetManager.IsInTrigger();
            let t = 0;
            n && (t = performance.now());
            const _ = this.IsDebug();
            _ && this.SetDebuggingEnabled(!1);
            const i = this._eventSheetManager._Trigger(this._layoutManager, l, e, a);
            if (n) {
                const a = performance.now() - t;
                this._mainThreadTimeCounter += a,
                _ && C3Debugger.AddTriggersTime(a)
            }
            return _ && this.SetDebuggingEnabled(!0),
            i
        }
        DebugTrigger(t, e, a) {
            if (!this.IsDebug())
                return this.Trigger(t, e, a);
            if (this.HitBreakpoint())
                throw new Error('called DebugTrigger() while stopped on breakpoint');
            if (!this._isInTick && !this._eventSheetManager.IsInTrigger())
                throw new Error('called DebugTrigger() outside of event code - use TriggerAsync() instead');
            return this._eventSheetManager._DebugTrigger(this._layoutManager, t, e, a)
        }
        async TriggerAsync(r, e, a) {
            if (!this.IsDebugging())
                return this.Trigger(r, e, a);
            if (!this._hasStarted)
                return !1;
            if (this.HitBreakpoint())
                return this._eventSheetManager.QueueDebugTrigger(r, e, a);
            if (!this.GetMainRunningLayout())
                return this._eventSheetManager.QueueTrigger(r, e, a);
            const n = performance.now()
              , t = this._eventSheetManager._DebugTrigger(this._layoutManager, r, e, a);
            let l = t.next();
            for (; !l.done; )
                await this.DebugBreak(l.value),
                l = t.next();
            return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
            this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()),
            this._mainThreadTimeCounter += performance.now() - n,
            l.value
        }
        FastTrigger(r, e, a) {
            const n = this.IsDebug();
            n && this.SetDebuggingEnabled(!1);
            const t = this._eventSheetManager._FastTrigger(this._layoutManager, r, e, a);
            return n && this.SetDebuggingEnabled(!0),
            t
        }
        DebugFastTrigger(t, e, a) {
            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, t, e, a)
        }
        ScheduleTriggers(t) {
            return this._scheduleTriggersThrottle.Add(t)
        }
        PushCurrentLayout(t) {
            this._currentLayoutStack.push(t)
        }
        PopCurrentLayout() {
            if (!this._currentLayoutStack.length)
                throw new Error('layout stack empty');
            this._currentLayoutStack.pop()
        }
        GetCurrentLayout() {
            return this._currentLayoutStack.length ? this._currentLayoutStack[this._currentLayoutStack.length - 1] : this.GetMainRunningLayout()
        }
        GetDt(t) {
            return t && -1 !== t.GetTimeScale() ? this._dt1 * t.GetTimeScale() : this._dt
        }
        _GetDtFast() {
            return this._dt
        }
        GetDt1() {
            return this._dt1
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(t) {
            (isNaN(t) || 0 > t) && (t = 0),
            this._timeScale = t
        }
        SetMinimumFramerate(t) {
            this._minimumFramerate = C3.clamp(t, 1, 120)
        }
        GetMinimumFramerate() {
            return this._minimumFramerate
        }
        GetFPS() {
            return this._fps
        }
        GetMainThreadTime() {
            return this._mainThreadTime
        }
        GetStartTime() {
            return this._startTime
        }
        GetGameTime() {
            return this._gameTime.Get()
        }
        GetWallTime() {
            return this._wallTime.Get()
        }
        GetTickCount() {
            return this._tickCount
        }
        GetTickCountNoSave() {
            return this._tickCountNoSave
        }
        IncrementExecCount() {
            ++this._execCount
        }
        GetExecCount() {
            return this._execCount
        }
        GetObjectCount() {
            return this._objectCount
        }
        GetProjectName() {
            return this._projectName
        }
        GetProjectVersion() {
            return this._projectVersion
        }
        GetProjectUniqueId() {
            return this._projectUniqueId
        }
        GetAppId() {
            return this._appId
        }
        GetInstanceByUID(t) {
            if (this._isLoadingState)
                throw new Error('cannot call while loading state - wait until afterload event');
            return this._instancesByUid.get(t) || null
        }
        _RefreshUidMap() {
            this._instancesByUid.clear();
            for (const t of this._allObjectClasses)
                if (!t.IsFamily())
                    for (const e of t.GetInstances())
                        this._instancesByUid.set(e.GetUID(), e)
        }
        IsPreview() {
            return 'preview' === this._exportType
        }
        IsDebug() {
            return this._isDebug
        }
        GetExportType() {
            return this._exportType
        }
        IsCordova() {
            return 'cordova' === this._exportType
        }
        IsAndroidWebView() {
            return 'Android' === C3.Platform.OS && ('cordova' === this._exportType || 'playable-ad' === this._exportType || 'instant-games' === this._exportType)
        }
        IsiOSCordova() {
            return this._isiOSCordova
        }
        IsiOSWebView() {
            return this._isiOSWebView
        }
        GetCollisionEngine() {
            return this._collisionEngine
        }
        GetSolidBehavior() {
            return this._pluginManager.GetSolidBehavior()
        }
        GetJumpthruBehavior() {
            return this._pluginManager.GetJumpthruBehavior()
        }
        IsLayoutFirstTick() {
            return this._isLayoutFirstTick
        }
        SetPixelRoundingEnabled(e) {
            e = !!e,
            this._isPixelRoundingEnabled === e || (this._isPixelRoundingEnabled = e,
            this.UpdateRender())
        }
        IsPixelRoundingEnabled() {
            return this._isPixelRoundingEnabled
        }
        SaveToSlot(t) {
            this._saveToSlotName = t
        }
        LoadFromSlot(t) {
            this._loadFromSlotName = t
        }
        LoadFromJsonString(t) {
            this._loadFromJson = t
        }
        GetLastSaveJsonString() {
            return this._lastSaveJson
        }
        _NeedsHandleSaveOrLoad() {
            return !!(this._saveToSlotName || this._loadFromSlotName || null !== this._loadFromJson)
        }
        async _HandleSaveOrLoad() {
            if (this._saveToSlotName && (this.FlushPendingInstances(),
            await this._DoSaveToSlot(this._saveToSlotName),
            this._ClearSaveOrLoad()),
            this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName),
            this._ClearSaveOrLoad(),
            this.IsDebug() && C3Debugger.StepIfPausedInDebugger()),
            null !== this._loadFromJson) {
                this.FlushPendingInstances();
                try {
                    await this._DoLoadFromJsonString(this._loadFromJson),
                    this._lastSaveJson = this._loadFromJson,
                    await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadComplete, null),
                    this._lastSaveJson = ''
                } catch (t) {
                    console.error('[Construct 3] Failed to load state from JSON string: ', t),
                    await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadFailed, null)
                }
                this._ClearSaveOrLoad()
            }
        }
        _ClearSaveOrLoad() {
            this._saveToSlotName = '',
            this._loadFromSlotName = '',
            this._loadFromJson = null
        }
        _GetProjectStorage() {
            return this._projectStorage || (this._projectStorage = localforage.createInstance({
                name: 'c3-localstorage-' + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            })),
            this._projectStorage
        }
        _GetSavegamesStorage() {
            return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
                name: 'c3-savegames-' + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            })),
            this._savegamesStorage
        }
        async _DoSaveToSlot(t) {
            const e = await this._SaveToJsonString();
            try {
                await this._GetSavegamesStorage().setItem(t, e),
                console.log('[Construct 3] Saved state to storage (' + e.length + ' chars)'),
                this._lastSaveJson = e,
                await this.TriggerAsync(C3.Plugins.System.Cnds.OnSaveComplete, null),
                this._lastSaveJson = ''
            } catch (t) {
                console.error('[Construct 3] Failed to save state to storage: ', t),
                await this.TriggerAsync(C3.Plugins.System.Cnds.OnSaveFailed, null)
            }
        }
        async _DoLoadFromSlot(t) {
            try {
                const e = await this._GetSavegamesStorage().getItem(t);
                if (!e)
                    throw new Error('empty slot');
                console.log('[Construct 3] Loaded state from storage (' + e.length + ' chars)'),
                await this._DoLoadFromJsonString(e),
                this._lastSaveJson = e,
                await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadComplete, null),
                this._lastSaveJson = ''
            } catch (t) {
                console.error('[Construct 3] Failed to load state from storage: ', t),
                await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadFailed, null)
            }
        }
        async _SaveToJsonString() {
            const t = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this.GetGameTime(),
                    walltime: this.GetWallTime(),
                    timescale: this.GetTimeScale(),
                    tickcount: this.GetTickCount(),
                    execcount: this.GetExecCount(),
                    next_uid: this._nextUid,
                    running_layout: this.GetMainRunningLayout().GetSID(),
                    start_time_offset: Date.now() - this._startTime
                },
                types: {},
                layouts: {},
                events: this._eventSheetManager._SaveToJson(),
                timelines: this._timelineManager._SaveToJson(),
                user_script_data: null
            };
            for (const e of this._allObjectClasses)
                e.IsFamily() || e.HasNoSaveBehavior() || (t.types[e.GetSID().toString()] = e._SaveToJson());
            for (const e of this._layoutManager.GetAllLayouts())
                t.layouts[e.GetSID().toString()] = e._SaveToJson();
            const e = this._CreateUserScriptEvent('save');
            return e.saveData = null,
            await this.DispatchUserScriptEventAsyncWait(e),
            t.user_script_data = e.saveData,
            JSON.stringify(t)
        }
        IsLoadingState() {
            return this._isLoadingState
        }
        _TriggerOnCreateAfterLoad(t) {
            C3.shallowAssignArray(this._triggerOnCreateAfterLoad, t)
        }
        async _DoLoadFromJsonString(r) {
            const e = JSON.parse(r);
            if (e.c2save)
                throw new Error('C2 saves are incompatible with C3 runtime');
            if (!e.c3save)
                throw new Error('not valid C3 save data');
            if (1 < e.version)
                throw new Error('C3 save data from future version');
            this._isLoadingState = !0;
            const a = e.rt;
            this._gameTime.Set(a.time),
            this._wallTime.Set(a.walltime),
            this._timeScale = a.timescale,
            this._tickCount = a.tickcount,
            this._execCount = a.execcount,
            this._startTime = Date.now() - a.start_time_offset;
            const n = a.running_layout;
            if (n !== this.GetMainRunningLayout().GetSID()) {
                const t = this._layoutManager.GetLayoutBySID(n);
                if (t)
                    await this._DoChangeLayout(t);
                else
                    return
            }
            for (const [i,n] of Object.entries(e.types)) {
                const t = parseInt(i, 10)
                  , e = this.GetObjectClassBySID(t);
                !e || e.IsFamily() || e.HasNoSaveBehavior() || e._LoadFromJson(n)
            }
            this.FlushPendingInstances(),
            this._RefreshUidMap(),
            this._isLoadingState = !1,
            this._nextUid = a.next_uid;
            for (const [i,n] of Object.entries(e.layouts)) {
                const t = parseInt(i, 10)
                  , e = this._layoutManager.GetLayoutBySID(t);
                e && e._LoadFromJson(n)
            }
            this._eventSheetManager._LoadFromJson(e.events);
            for (const e of this._triggerOnCreateAfterLoad)
                e._TriggerOnCreated();
            C3.clearArray(this._triggerOnCreateAfterLoad);
            for (const i of this._allObjectClasses)
                if (!i.IsFamily() && i.IsInContainer())
                    for (const a of i.GetInstances()) {
                        const e = a.GetIID();
                        for (const n of i.GetContainer().objectTypes()) {
                            if (n === i)
                                continue;
                            const t = n.GetInstances();
                            if (0 > e || e >= t.length)
                                throw new Error('missing sibling instance');
                            a._AddSibling(t[e])
                        }
                    }
            this._timelineManager._LoadFromJson(e.timelines),
            this._dispatcher.dispatchEvent(C3.New(C3.Event, 'afterload'));
            const t = this._CreateUserScriptEvent('load');
            t.saveData = e.user_script_data,
            await this.DispatchUserScriptEventAsyncWait(t),
            this.UpdateRender()
        }
        async AddJobWorkerScripts(t) {
            const e = await Promise.all(t.map(t=>this._assetManager.FetchBlob(t)))
              , a = e.map(t=>URL.createObjectURL(t));
            this._jobScheduler.ImportScriptsToJobWorkers(a)
        }
        AddJobWorkerBlob(t, e) {
            this._jobScheduler.SendBlobToJobWorkers(t, e)
        }
        AddJobWorkerBuffer(t, e) {
            this._jobScheduler.SendBufferToJobWorkers(t, e)
        }
        AddJob(t, e, a) {
            return this._jobScheduler.AddJob(t, e, a)
        }
        BroadcastJob(t, e, a) {
            return this._jobScheduler.BroadcastJob(t, e, a)
        }
        InvokeDownload(t, e) {
            this.PostComponentMessageToDOM('runtime', 'invoke-download', {
                url: t,
                filename: e
            })
        }
        async RasterSvgImage(l, e, a, n, _, d) {
            if (n = n || e,
            _ = _ || a,
            this.IsInWorker()) {
                const t = await this.PostComponentMessageToDOMAsync('runtime', 'raster-svg-image', {
                    blob: l,
                    imageWidth: e,
                    imageHeight: a,
                    surfaceWidth: n,
                    surfaceHeight: _,
                    imageBitmapOpts: d
                });
                return t.imageBitmap
            } else {
                const t = await self.C3_RasterSvgImageBlob(l, e, a, n, _);
                return d ? await self.createImageBitmap(t, d) : t
            }
        }
        async GetSvgImageSize(t) {
            return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync('runtime', 'get-svg-image-size', {
                blob: t
            }) : await self.C3_GetSvgImageSize(t)
        }
        RequestDeviceOrientationEvent() {
            this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0,
            this.PostComponentMessageToDOM('runtime', 'enable-device-orientation'))
        }
        RequestDeviceMotionEvent() {
            this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0,
            this.PostComponentMessageToDOM('runtime', 'enable-device-motion'))
        }
        Random() {
            return this._randomNumberCallback()
        }
        SetRandomNumberGeneratorCallback(t) {
            this._randomNumberCallback = t
        }
        _GetRemotePreviewStatusInfo() {
            return {
                fps: this.GetFPS(),
                cpu: this.GetMainThreadTime(),
                gpu: this.GetGPUUtilisation(),
                layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : '',
                renderer: this.GetWebGLRenderer().GetUnmaskedRenderer()
            }
        }
        HitBreakpoint() {
            return !!this.IsDebug() && C3Debugger.HitBreakpoint()
        }
        DebugBreak(t) {
            return this.IsDebugging() ? C3Debugger.DebugBreak(t) : Promise.resolve()
        }
        DebugBreakNext() {
            return !!this.IsDebugging() && C3Debugger.BreakNext()
        }
        SetDebugBreakpointsEnabled(e) {
            this._breakpointsEnabled = !!e,
            this._UpdateDebuggingFlag()
        }
        AreDebugBreakpointsEnabled() {
            return this._breakpointsEnabled
        }
        IsDebugging() {
            return this._isDebugging
        }
        SetDebuggingEnabled(t) {
            t ? this._debuggingDisabled-- : this._debuggingDisabled++,
            this._UpdateDebuggingFlag()
        }
        _UpdateDebuggingFlag() {
            this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
        }
        IsCPUProfiling() {
            return this.IsDebug() && C3Debugger.IsCPUProfiling()
        }
        IsGPUProfiling() {
            return this.IsDebug() && this.GetWebGLRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling()
        }
        async DebugIterateAndBreak(t) {
            if (t)
                for (const e of t)
                    await this.DebugBreak(e)
        }
        DebugFireGeneratorEventAndBreak(t) {
            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(t))
        }
        _InvokeFunctionFromJS(e) {
            return this._eventSheetManager._InvokeFunctionFromJS(e.name, e.params)
        }
        GetIRuntime() {
            return this._iRuntime
        }
        _CreateUserScriptEvent(e) {
            const t = C3.New(C3.Event, e, !1);
            return t.runtime = this._iRuntime,
            t
        }
        _InitScriptInterfaces() {
            const t = {};
            for (const e of this._allObjectClasses)
                t[e.GetJsPropName()] = {
                    value: e.GetIObjectClass(),
                    enumerable: !0,
                    writable: !1
                };
            const e = Object.create(Object.prototype, t);
            this._iRuntime = new IRuntime(this,e),
            this._userScriptEventObjects = {
                tick: this._CreateUserScriptEvent('tick')
            }
        }
        _InitGlobalVariableScriptInterface() {
            const t = {};
            for (const e of this.GetEventSheetManager().GetAllGlobalVariables())
                t[e.GetJsPropName()] = e._GetScriptInterfaceDescriptor();
            this._iRuntime._InitGlobalVars(t)
        }
        _GetCommonScriptInterfaces() {
            return this._commonScriptInterfaces
        }
        _MapScriptInterface(t, e) {
            this._interfaceMap.set(t, e)
        }
        _UnwrapScriptInterface(t) {
            return this._interfaceMap.get(t)
        }
    }
    ,
    self.C3_CreateRuntime = C3.Runtime.Create,
    self.C3_InitRuntime = (t,e)=>t.Init(e)
}
'use strict',
C3.JobSchedulerRuntime = class extends C3.DefendedBase {
    constructor(e, t) {
        super(),
        this._runtime = e,
        this._jobPromises = new Map,
        this._nextJobId = 0,
        this._inputPort = t.inputPort,
        t.outputPort.onmessage = e=>this._OnJobWorkerMessage(e),
        this._maxNumWorkers = t.maxNumWorkers,
        this._jobWorkerCount = 1,
        this._isCreatingWorker = !1,
        this._hadErrorCreatingWorker = !1,
        this._isBroken = !1,
        this._testOkResolve = null
    }
    async Init() {
        await this._TestMessageChannelWorks()
    }
    ImportScriptsToJobWorkers(e) {
        this._isBroken || this._inputPort.postMessage({
            type: '_import_scripts',
            scripts: e
        })
    }
    SendBlobToJobWorkers(e, t) {
        this._isBroken || this._inputPort.postMessage({
            type: '_send_blob',
            blob: e,
            id: t
        })
    }
    SendBufferToJobWorkers(e, t) {
        this._isBroken || this._inputPort.postMessage({
            type: '_send_buffer',
            buffer: e,
            id: t
        }, [e])
    }
    AddJob(t, a, n, r, i) {
        if (this._isBroken)
            return Promise.reject('messagechannels broken');
        n || (n = []);
        const e = this._nextJobId++
          , l = {
            type: t,
            isBroadcast: !1,
            jobId: e,
            params: a,
            transferables: n
        }
          , _ = new Promise((t,a)=>{
            this._jobPromises.set(e, {
                resolve: t,
                progress: r,
                reject: a,
                cancelled: !1
            })
        }
        );
        return i && i.SetAction(()=>this._CancelJob(e)),
        this._inputPort.postMessage(l, n),
        this._MaybeCreateExtraWorker(),
        _
    }
    BroadcastJob(t, a, n) {
        if (!this._isBroken) {
            n || (n = []);
            const r = this._nextJobId++
              , i = {
                type: t,
                isBroadcast: !0,
                jobId: r,
                params: a,
                transferables: n
            };
            this._inputPort.postMessage(i, n)
        }
    }
    _CancelJob(e) {
        const t = this._jobPromises.get(e);
        t && (t.cancelled = !0,
        t.resolve = null,
        t.progress = null,
        t.reject = null,
        this._inputPort.postMessage({
            type: '_cancel',
            jobId: e
        }))
    }
    _OnJobWorkerMessage(e) {
        const t = e.data
          , a = t.type
          , n = t.jobId;
        switch (a) {
        case 'result':
            this._OnJobResult(n, t.result);
            break;
        case 'progress':
            this._OnJobProgress(n, t.progress);
            break;
        case 'error':
            this._OnJobError(n, t.error);
            break;
        case 'ready':
            this._OnJobWorkerReady();
            break;
        case '_testMessageChannelOk':
            this._OnTestMessageChannelOk();
            break;
        default:
            throw new Error(`unknown message from worker '${a}'`);
        }
    }
    _OnJobResult(e, t) {
        const a = this._jobPromises.get(e);
        if (!a)
            throw new Error('invalid job ID');
        a.cancelled || a.resolve(t),
        this._jobPromises.delete(e)
    }
    _OnJobProgress(e, t) {
        const a = this._jobPromises.get(e);
        if (!a)
            throw new Error('invalid job ID');
        !a.cancelled && a.progress && a.progress(t)
    }
    _OnJobError(e, t) {
        const a = this._jobPromises.get(e);
        if (!a)
            throw new Error('invalid job ID');
        a.cancelled || a.reject(t),
        this._jobPromises.delete(e)
    }
    _OnJobWorkerReady() {
        this._isCreatingWorker && (this._isCreatingWorker = !1,
        this._jobWorkerCount++,
        this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
            type: '_no_more_workers'
        }))
    }
    async _MaybeCreateExtraWorker() {
        if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount))
            try {
                this._isCreatingWorker = !0;
                const e = await this._runtime.PostComponentMessageToDOMAsync('runtime', 'create-job-worker');
                e.outputPort.onmessage = e=>this._OnJobWorkerMessage(e)
            } catch (e) {
                this._hadErrorCreatingWorker = !0,
                this._isCreatingWorker = !1,
                console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, e)
            }
    }
    _TestMessageChannelWorks() {
        return this._inputPort.postMessage({
            type: '_testMessageChannel'
        }),
        self.setTimeout(()=>this._CheckMessageChannelTestTimedOut(), 2e3),
        new Promise(e=>this._testOkResolve = e)
    }
    _OnTestMessageChannelOk() {
        this._testOkResolve(),
        this._testOkResolve = null
    }
    _CheckMessageChannelTestTimedOut() {
        this._testOkResolve && (console.warn('MessageChannel determined to be broken. Job scheduler disabled.'),
        this._isBroken = !0,
        this._testOkResolve(),
        this._testOkResolve = null)
    }
}
,
self.C3_Shaders = {},
self.C3_Shaders.hsladjust = {
    src: 'varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nprecision mediump float;\nuniform float huerotate;\nuniform float satadjust;\nuniform float lumadjust;\nvec3 rgb_to_hsl(vec3 color)\n{\nvec3 hsl = vec3(0.0, 0.0, 0.0);\nfloat fmin = min(min(color.r, color.g), color.b);\nfloat fmax = max(max(color.r, color.g), color.b);\nfloat delta = fmax - fmin;\nhsl.z = (fmax + fmin) / 2.0;\nif (delta == 0.0)\n{\nhsl.x = 0.0;\nhsl.y = 0.0;\n}\nelse\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin);\nelse\nhsl.y = delta / (2.0 - fmax - fmin);\nfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\nif (color.r == fmax)\nhsl.x = dB - dG;\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + dR - dB;\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + dG - dR;\nif (hsl.x < 0.0)\nhsl.x += 1.0;\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0;\n}\nreturn hsl;\n}\nfloat hue_to_rgb(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat ret;\nif ((6.0 * hue) < 1.0)\nret = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nret = f2;\nelse if ((3.0 * hue) < 2.0)\nret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nret = f1;\nreturn ret;\n}\nvec3 hsl_to_rgb(vec3 hsl)\n{\nvec3 rgb = vec3(hsl.z);\nif (hsl.y != 0.0)\n{\nfloat f2;\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\nfloat f1 = 2.0 * hsl.z - f2;\nrgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\nrgb.g = hue_to_rgb(f1, f2, hsl.x);\nrgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\n}\nreturn rgb;\n}\nvoid main(void)\n{\nvec4 front = texture2D(samplerFront, vTex);\nvec3 rgb = rgb_to_hsl(front.rgb) + vec3((huerotate > 0.5 ? huerotate - 1.0 : huerotate), 0, (lumadjust - 1.0) * front.a);\nrgb.y *= satadjust;\nrgb = hsl_to_rgb(rgb);\ngl_FragColor = vec4(rgb, front.a);\n}',
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: [['huerotate', 0, 'percent'], ['satadjust', 0, 'percent'], ['lumadjust', 0, 'percent']]
},
'use strict';
{
    function t(e, t) {
        const n = e[1]
          , r = t[1];
        if ('number' == typeof n && 'number' == typeof r)
            return n - r;
        else {
            const e = '' + n
              , t = '' + r;
            return e < t ? -1 : e > t ? 1 : 0
        }
    }
    let n = null
      , r = ''
      , l = ''
      , _ = []
      , e = ''
      , u = ''
      , g = '';
    const S = C3.New(C3.ArrayStack);
    C3.Plugins.System = class extends C3.SDKPluginBase {
        constructor(e) {
            super(e),
            this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(),
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(),
            this._imagesLoadingTotal = 0,
            this._imagesLoadingComplete = 0,
            this._functionMaps = new Map
        }
        Release() {
            super.Release()
        }
        UpdateRender() {
            this._runtime.UpdateRender()
        }
        Trigger(e) {
            this._runtime.Trigger(e, null, null)
        }
        GetRegex(t, a) {
            return n && t === r && a === l || (n = new RegExp(t,a),
            r = t,
            l = a),
            n.lastIndex = 0,
            n
        }
        GetRegexMatches(t, a, n) {
            if (t === e && a === u && n === g)
                return _;
            const r = this.GetRegex(a, n);
            return _ = t.match(r),
            e = t,
            u = a,
            g = n,
            _
        }
        async _LoadTexturesForObjectClasses(e, t) {
            if (t.length) {
                this._imagesLoadingTotal += t.length;
                const a = [];
                for (const n of t)
                    a.push(e.MaybeLoadTexturesFor(n));
                await C3.PromiseAllWithProgress(a, ()=>{
                    this._imagesLoadingComplete++
                }
                ),
                this._imagesLoadingComplete++,
                this._imagesLoadingComplete === this._imagesLoadingTotal && (this._runtime.Trigger(C3.Plugins.System.Cnds.OnImageLoadingComplete, null, null),
                this._imagesLoadingComplete = 0,
                this._imagesLoadingTotal = 0)
            }
        }
        _UnloadTexturesForObjectClasses(e, t) {
            for (const a of t)
                0 === a.GetInstanceCount() && e.MaybeUnloadTexturesFor(a)
        }
        _GetForEachStack() {
            return S
        }
        _Repeat(t) {
            const a = this._runtime.GetEventSheetManager()
              , n = a.GetEventStack()
              , r = n.GetCurrentStackFrame()
              , l = r.GetCurrentEvent()
              , e = l.GetSolModifiers()
              , _ = r.IsSolModifierAfterCnds()
              , d = n.Push(l)
              , u = a.GetLoopStack()
              , i = u.Push();
            if (i.SetEnd(t),
            _)
                for (let n = 0; n < t && !i.IsStopped(); ++n)
                    a.PushCopySol(e),
                    i.SetIndex(n),
                    l.Retrigger(r, d),
                    a.PopSol(e);
            else
                for (let e = 0; e < t && !i.IsStopped(); ++e)
                    i.SetIndex(e),
                    l.Retrigger(r, d);
            return n.Pop(),
            u.Pop(),
            !1
        }
        *_DebugRepeat(t) {
            const a = this._runtime.GetEventSheetManager()
              , n = a.GetEventStack()
              , r = n.GetCurrentStackFrame()
              , l = r.GetCurrentEvent()
              , e = l.GetSolModifiers()
              , _ = r.IsSolModifierAfterCnds()
              , d = n.Push(l)
              , u = a.GetLoopStack()
              , i = u.Push();
            if (i.SetEnd(t),
            _)
                for (let n = 0; n < t && !i.IsStopped(); ++n)
                    a.PushCopySol(e),
                    i.SetIndex(n),
                    yield*l.DebugRetrigger(r, d),
                    a.PopSol(e);
            else
                for (let e = 0; e < t && !i.IsStopped(); ++e)
                    i.SetIndex(e),
                    yield*l.DebugRetrigger(r, d);
            return n.Pop(),
            u.Pop(),
            !1
        }
        _While() {
            const t = this._runtime.GetEventSheetManager()
              , a = t.GetEventStack()
              , n = a.GetCurrentStackFrame()
              , r = n.GetCurrentEvent()
              , i = r.GetSolModifiers()
              , e = n.IsSolModifierAfterCnds()
              , l = a.Push(r)
              , _ = t.GetLoopStack()
              , d = _.Push();
            if (e)
                for (let e = 0; !d.IsStopped(); ++e)
                    t.PushCopySol(i),
                    d.SetIndex(e),
                    r.Retrigger(n, l) || d.Stop(),
                    t.PopSol(i);
            else
                for (let e = 0; !d.IsStopped(); ++e)
                    d.SetIndex(e),
                    r.Retrigger(n, l) || d.Stop();
            return a.Pop(),
            _.Pop(),
            !1
        }
        *_DebugWhile() {
            const t = this._runtime.GetEventSheetManager()
              , a = t.GetEventStack()
              , n = a.GetCurrentStackFrame()
              , r = n.GetCurrentEvent()
              , i = r.GetSolModifiers()
              , e = n.IsSolModifierAfterCnds()
              , l = a.Push(r)
              , _ = t.GetLoopStack()
              , d = _.Push();
            if (e)
                for (let e = 0; !d.IsStopped(); ++e) {
                    t.PushCopySol(i),
                    d.SetIndex(e);
                    const a = yield*r.DebugRetrigger(n, l);
                    a || d.Stop(),
                    t.PopSol(i)
                }
            else
                for (let e = 0; !d.IsStopped(); ++e) {
                    d.SetIndex(e);
                    const t = yield*r.DebugRetrigger(n, l);
                    t || d.Stop()
                }
            return a.Pop(),
            _.Pop(),
            !1
        }
        _For(t, n, r) {
            const _ = this._runtime.GetEventSheetManager()
              , a = _.GetEventStack()
              , e = a.GetCurrentStackFrame()
              , d = e.GetCurrentEvent()
              , u = d.GetSolModifiers()
              , c = e.IsSolModifierAfterCnds()
              , i = a.Push(d)
              , g = _.GetLoopStack()
              , m = g.Push();
            if (m.SetName(t),
            m.SetEnd(r),
            r < n) {
                if (c)
                    for (let t = n; t >= r && !m.IsStopped(); --t)
                        _.PushCopySol(u),
                        m.SetIndex(t),
                        d.Retrigger(e, i),
                        _.PopSol(u);
                else
                    for (let t = n; t >= r && !m.IsStopped(); --t)
                        m.SetIndex(t),
                        d.Retrigger(e, i);
            } else if (c)
                for (let t = n; t <= r && !m.IsStopped(); ++t)
                    _.PushCopySol(u),
                    m.SetIndex(t),
                    d.Retrigger(e, i),
                    _.PopSol(u);
            else
                for (let t = n; t <= r && !m.IsStopped(); ++t)
                    m.SetIndex(t),
                    d.Retrigger(e, i);
            return a.Pop(),
            g.Pop(),
            !1
        }
        *_DebugFor(t, n, r) {
            const _ = this._runtime.GetEventSheetManager()
              , a = _.GetEventStack()
              , e = a.GetCurrentStackFrame()
              , d = e.GetCurrentEvent()
              , u = d.GetSolModifiers()
              , c = e.IsSolModifierAfterCnds()
              , i = a.Push(d)
              , g = _.GetLoopStack()
              , m = g.Push();
            if (m.SetName(t),
            m.SetEnd(r),
            r < n) {
                if (c)
                    for (let t = n; t >= r && !m.IsStopped(); --t)
                        _.PushCopySol(u),
                        m.SetIndex(t),
                        yield*d.DebugRetrigger(e, i),
                        _.PopSol(u);
                else
                    for (let t = n; t >= r && !m.IsStopped(); --t)
                        m.SetIndex(t),
                        yield*d.DebugRetrigger(e, i);
            } else if (c)
                for (let t = n; t <= r && !m.IsStopped(); ++t)
                    _.PushCopySol(u),
                    m.SetIndex(t),
                    yield*d.DebugRetrigger(e, i),
                    _.PopSol(u);
            else
                for (let t = n; t <= r && !m.IsStopped(); ++t)
                    m.SetIndex(t),
                    yield*d.DebugRetrigger(e, i);
            return a.Pop(),
            g.Pop(),
            !1
        }
        _ForEach(t) {
            const a = this._runtime.GetEventSheetManager()
              , r = a.GetEventStack()
              , i = r.GetCurrentStackFrame()
              , _ = i.GetCurrentEvent()
              , e = _.GetSolModifiers()
              , d = i.IsSolModifierAfterCnds()
              , u = r.Push(_)
              , c = a.GetLoopStack()
              , p = c.Push()
              , h = t.IsInContainer()
              , l = t.GetCurrentSol()
              , m = S.Push();
            if (C3.shallowAssignArray(m, l.GetInstances()),
            p.SetEnd(m.length),
            d)
                for (let n = 0, r = m.length; n < r && !p.IsStopped(); ++n) {
                    a.PushCopySol(e);
                    const r = m[n];
                    t.GetCurrentSol().SetSinglePicked(r),
                    h && r.SetSiblingsSinglePicked(),
                    p.SetIndex(n),
                    _.Retrigger(i, u),
                    a.PopSol(e)
                }
            else {
                l._SetSelectAll(!1);
                const e = l._GetOwnInstances();
                C3.clearArray(e),
                e.push(null);
                for (let t = 0, a = m.length; t < a && !p.IsStopped(); ++t) {
                    const a = m[t];
                    e[0] = a,
                    h && a.SetSiblingsSinglePicked(),
                    p.SetIndex(t),
                    _.Retrigger(i, u)
                }
            }
            return r.Pop(),
            c.Pop(),
            C3.clearArray(m),
            S.Pop(),
            !1
        }
        *_DebugForEach(t) {
            const a = this._runtime.GetEventSheetManager()
              , r = a.GetEventStack()
              , i = r.GetCurrentStackFrame()
              , _ = i.GetCurrentEvent()
              , e = _.GetSolModifiers()
              , d = i.IsSolModifierAfterCnds()
              , u = r.Push(_)
              , c = a.GetLoopStack()
              , p = c.Push()
              , h = t.IsInContainer()
              , l = t.GetCurrentSol()
              , m = S.Push();
            if (C3.shallowAssignArray(m, l.GetInstances()),
            p.SetEnd(m.length),
            d)
                for (let n = 0, r = m.length; n < r && !p.IsStopped(); ++n) {
                    a.PushCopySol(e);
                    const r = m[n];
                    t.GetCurrentSol().SetSinglePicked(r),
                    h && r.SetSiblingsSinglePicked(),
                    p.SetIndex(n),
                    yield*_.DebugRetrigger(i, u),
                    a.PopSol(e)
                }
            else {
                l._SetSelectAll(!1);
                const e = l._GetOwnInstances();
                C3.clearArray(e),
                e.push(null);
                for (let t = 0, a = m.length; t < a && !p.IsStopped(); ++t) {
                    const a = m[t];
                    e[0] = a,
                    h && a.SetSiblingsSinglePicked(),
                    p.SetIndex(t),
                    yield*_.DebugRetrigger(i, u)
                }
            }
            return r.Pop(),
            c.Pop(),
            C3.clearArray(m),
            S.Pop(),
            !1
        }
        _ForEachOrdered(i, a) {
            const _ = this._runtime.GetEventSheetManager()
              , d = _.GetEventStack()
              , e = _.GetCurrentCondition()
              , u = d.GetCurrentStackFrame()
              , g = u.GetCurrentEvent()
              , h = g.GetSolModifiers()
              , c = u.IsSolModifierAfterCnds()
              , f = d.Push(g)
              , l = _.GetLoopStack()
              , m = l.Push()
              , n = i.IsInContainer()
              , y = i.GetCurrentSol()
              , p = S.Push();
            C3.clearArray(p);
            const G = y.GetInstances();
            m.SetEnd(G.length);
            for (let t = 0, n = G.length; t < n; ++t)
                p.push([G[t], e.ReevaluateParameter(1, t)]);
            if (p.sort(t),
            1 === a && p.reverse(),
            c)
                for (let e = 0, t = p.length; e < t && !m.IsStopped(); ++e) {
                    _.PushCopySol(h);
                    const t = p[e][0];
                    i.GetCurrentSol().SetSinglePicked(t),
                    n && t.SetSiblingsSinglePicked(),
                    m.SetIndex(e),
                    g.Retrigger(u, f),
                    _.PopSol(h)
                }
            else {
                y._SetSelectAll(!1);
                const e = y._GetOwnInstances();
                C3.clearArray(e),
                e.push(null);
                for (let t = 0, a = p.length; t < a && !m.IsStopped(); ++t) {
                    const a = p[t][0];
                    e[0] = a,
                    n && a.SetSiblingsSinglePicked(),
                    m.SetIndex(t),
                    g.Retrigger(u, f)
                }
            }
            return d.Pop(),
            l.Pop(),
            C3.clearArray(p),
            S.Pop(),
            !1
        }
        *_DebugForEachOrdered(i, a) {
            const _ = this._runtime.GetEventSheetManager()
              , d = _.GetEventStack()
              , e = _.GetCurrentCondition()
              , u = d.GetCurrentStackFrame()
              , g = u.GetCurrentEvent()
              , h = g.GetSolModifiers()
              , c = u.IsSolModifierAfterCnds()
              , f = d.Push(g)
              , l = _.GetLoopStack()
              , m = l.Push()
              , n = i.IsInContainer()
              , y = i.GetCurrentSol()
              , p = S.Push();
            C3.clearArray(p);
            const G = y.GetInstances();
            m.SetEnd(G.length);
            for (let t = 0, n = G.length; t < n; ++t)
                p.push([G[t], e.ReevaluateParameter(1, t)]);
            if (p.sort(t),
            1 === a && p.reverse(),
            c)
                for (let e = 0, t = p.length; e < t && !m.IsStopped(); ++e) {
                    _.PushCopySol(h);
                    const t = p[e][0];
                    i.GetCurrentSol().SetSinglePicked(t),
                    n && t.SetSiblingsSinglePicked(),
                    m.SetIndex(e),
                    yield*g.DebugRetrigger(u, f),
                    _.PopSol(h)
                }
            else {
                y._SetSelectAll(!1);
                const e = y._GetOwnInstances();
                C3.clearArray(e),
                e.push(null);
                for (let t = 0, a = p.length; t < a && !m.IsStopped(); ++t) {
                    const a = p[t][0];
                    e[0] = a,
                    n && a.SetSiblingsSinglePicked(),
                    m.SetIndex(t),
                    yield*g.DebugRetrigger(u, f)
                }
            }
            return d.Pop(),
            l.Pop(),
            C3.clearArray(p),
            S.Pop(),
            !1
        }
        _GetFunctionMap(e, t) {
            let a = this._functionMaps.get(e);
            return a ? a : t ? (a = {
                defaultFunc: null,
                strMap: new Map
            },
            this._functionMaps.set(e, a),
            a) : null
        }
        _DoCallMappedFunction(t, a, n, r, i) {
            a.GetEventBlock().RunAsMappedFunctionCall(n),
            r && t.PopSol(i)
        }
        *_DebugDoCallMappedFunction(t, a, n, r, i) {
            yield*a.GetEventBlock().DebugRunAsMappedFunctionCall(n),
            r && t.PopSol(i)
        }
    }
}
'use strict',
C3.Plugins.System.Type = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._objectClass = e,
        this._runtime = e.GetRuntime(),
        this._plugin = e.GetPlugin()
    }
    OnCreate() {}
    Release() {
        this._objectClass = null,
        this._runtime = null,
        this._plugin = null
    }
}
,
'use strict',
C3.Plugins.System.Instance = class extends C3.DefendedBase {
    constructor(e) {
        super(),
        this._inst = e,
        this._objectClass = this._inst.GetObjectClass(),
        this._sdkType = this._objectClass.GetSdkType(),
        this._runtime = this._inst.GetRuntime()
    }
    Release() {
        this._inst = null,
        this._objectClass = null,
        this._sdkType = null,
        this._runtime = null
    }
}
,
'use strict';
{
    const t = [];
    C3.Plugins.System.Cnds = {
        EveryTick() {
            return !0
        },
        OnLayoutStart() {
            return !0
        },
        OnLayoutEnd() {
            return !0
        },
        OnSuspend() {
            return !0
        },
        OnResume() {
            return !0
        },
        IsSuspended() {
            return this._runtime.IsSuspended()
        },
        Else() {
            const e = this._runtime.GetCurrentEventStackFrame();
            return !e.GetElseBranchRan() && !e.GetLastEventTrue()
        },
        TriggerOnce() {
            const e = this._runtime.GetCurrentCondition()
              , t = e.GetSavedDataMap();
            let a = t.get('TriggerOnce_lastTick');
            'undefined' == typeof a && (a = -1,
            t.set('TriggerOnce_lastTick', -1));
            const n = this._runtime.GetTickCount();
            return t.set('TriggerOnce_lastTick', n),
            this._runtime.IsLayoutFirstTick() || a !== n - 1
        },
        Every(t) {
            const a = this._runtime.GetCurrentCondition()
              , n = a.GetSavedDataMap()
              , r = n.get('Every_lastTime') || 0
              , i = this._runtime.GetGameTime();
            n.has('Every_seconds') || n.set('Every_seconds', t);
            const e = n.get('Every_seconds');
            return i >= r + e ? (n.set('Every_lastTime', r + e),
            i >= n.get('Every_lastTime') + .04 && n.set('Every_lastTime', i),
            n.set('Every_seconds', t),
            !0) : (i < r - .1 && n.set('Every_lastTime', i),
            !1)
        },
        IsGroupActive(e) {
            const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
            return t && t.IsGroupActive()
        },
        IsPreview() {
            return this._runtime.IsPreview()
        },
        IsMobile() {
            return C3.Platform.IsMobile
        },
        OnLoadFinished() {
            return !0
        },
        OnCanvasSnapshot() {
            return !0
        },
        EffectsSupported() {
            return !0
        },
        OnSaveComplete() {
            return !0
        },
        OnSaveFailed() {
            return !0
        },
        OnLoadComplete() {
            return !0
        },
        OnLoadFailed() {
            return !0
        },
        ObjectUIDExists(e) {
            return !!this._runtime.GetInstanceByUID(e)
        },
        IsOnPlatform(e) {
            return 0 === e ? 'browser' === C3.Platform.Context : 1 === e ? 'iOS' === C3.Platform.OS : 2 === e ? 'Android' === C3.Platform.OS : 8 === e ? 'cordova' === C3.Platform.Context : 9 === e ? 'scirra-arcade' === this._runtime.GetExportType() : 10 === e ? 'nwjs' === C3.Platform.Context : 13 == e && 'windows-uwp' === this._runtime.GetExportType()
        },
        RegexTest(e, t, a) {
            const n = this.GetRegex(t, a);
            return n.test(e)
        },
        Compare(e, t, a) {
            return C3.compare(e, t, a)
        },
        CompareBetween(e, t, n) {
            return e >= t && e <= n
        },
        CompareVar(e, t, a) {
            return C3.compare(e.GetValue(), t, a)
        },
        CompareBoolVar(e) {
            return !!e.GetValue()
        },
        CompareTime(e, t) {
            const n = this._runtime.GetGameTime();
            if (0 === e) {
                const e = this._runtime.GetCurrentCondition()
                  , a = e.GetSavedDataMap();
                return !a.get('CompareTime_executed') && n >= t && (a.set('CompareTime_executed', !0),
                !0)
            }
            return C3.compare(n, e, t)
        },
        IsNaN(e) {
            return isNaN(e)
        },
        AngleWithin(e, t, a) {
            return C3.angleDiff(C3.toRadians(e), C3.toRadians(a)) <= C3.toRadians(t)
        },
        IsClockwiseFrom(e, t) {
            return C3.angleClockwise(C3.toRadians(e), C3.toRadians(t))
        },
        IsBetweenAngles(t, n, a) {
            let r = C3.toRadians(t)
              , i = C3.toRadians(n)
              , e = C3.toRadians(a)
              , l = !C3.angleClockwise(e, i);
            return l ? C3.angleClockwise(r, i) || !C3.angleClockwise(r, e) : C3.angleClockwise(r, i) && !C3.angleClockwise(r, e)
        },
        IsValueType(e, t) {
            return 'number' == typeof e ? 0 === t : 1 === t
        },
        PickByComparison(t, n, r, l) {
            if (!t)
                return !1;
            const a = this._GetForEachStack()
              , _ = a.Push()
              , u = t.GetCurrentSol();
            C3.shallowAssignArray(_, u.GetInstances()),
            u.IsSelectAll() && C3.clearArray(u._GetOwnElseInstances());
            const c = this._runtime.GetCurrentCondition();
            let g = 0;
            for (let d = 0, e = _.length; d < e; ++d) {
                const e = _[d];
                _[g] = e,
                n = c.ReevaluateParameter(1, d),
                l = c.ReevaluateParameter(3, d),
                C3.compare(n, r, l) ? ++g : u._PushElseInstance(e)
            }
            C3.truncateArray(_, g),
            u.SetArrayPicked(_);
            const e = !!_.length;
            return C3.clearArray(_),
            a.Pop(),
            t.ApplySolToContainer(),
            e
        },
        PickByEvaluate(t, n) {
            if (!t)
                return !1;
            const a = this._GetForEachStack()
              , r = a.Push()
              , i = t.GetCurrentSol();
            C3.shallowAssignArray(r, i.GetInstances()),
            i.IsSelectAll() && C3.clearArray(i._GetOwnElseInstances());
            const e = this._runtime.GetCurrentCondition();
            let l = 0;
            for (let _ = 0, a = r.length; _ < a; ++_) {
                const t = r[_];
                r[l] = t,
                n = e.ReevaluateParameter(1, _),
                n ? ++l : i._PushElseInstance(t)
            }
            C3.truncateArray(r, l),
            i.SetArrayPicked(r);
            const _ = !!r.length;
            return C3.clearArray(r),
            a.Pop(),
            t.ApplySolToContainer(),
            _
        },
        PickNth(t, a) {
            if (!t)
                return !1;
            const n = t.GetCurrentSol()
              , r = n.GetInstances();
            if (a = Math.floor(a),
            a >= r.length)
                return !1;
            const i = r[a];
            return n.PickOne(i),
            t.ApplySolToContainer(),
            !0
        },
        PickRandom(t) {
            if (!t)
                return !1;
            const a = t.GetCurrentSol()
              , n = a.GetInstances()
              , r = Math.floor(this._runtime.Random() * n.length);
            if (r >= n.length)
                return !1;
            const i = n[r];
            return a.PickOne(i),
            t.ApplySolToContainer(),
            !0
        },
        PickAll(e) {
            if (!e)
                return !1;
            if (!e.GetInstanceCount())
                return !1;
            const t = e.GetCurrentSol();
            return t._SetSelectAll(!0),
            e.ApplySolToContainer(),
            !0
        },
        PickOverlappingPoint(a, n, r) {
            if (!a)
                return !1;
            const i = a.GetCurrentSol()
              , e = i.GetInstances()
              , l = this._runtime.GetCurrentEvent()
              , _ = l.IsOrBlock()
              , d = this._runtime.GetCurrentCondition().IsInverted();
            i.IsSelectAll() ? (C3.shallowAssignArray(t, e),
            i.ClearArrays(),
            i._SetSelectAll(!1)) : _ ? (C3.shallowAssignArray(t, i._GetOwnElseInstances()),
            C3.clearArray(i._GetOwnElseInstances())) : (C3.shallowAssignArray(t, i._GetOwnInstances()),
            C3.clearArray(i._GetOwnInstances()));
            for (let e = 0, l = t.length; e < l; ++e) {
                const a = t[e];
                C3.xor(a.GetWorldInfo().ContainsPoint(n, r), d) ? i._PushInstance(a) : i._PushElseInstance(a)
            }
            return a.ApplySolToContainer(),
            C3.xor(!!i._GetOwnInstances().length, d)
        },
        PickLastCreated(t) {
            if (!t)
                return !1;
            const a = t.IsFamily();
            let n = null;
            const r = this._runtime._GetInstancesPendingCreate();
            for (let i = r.length - 1; 0 <= i; --i) {
                const e = r[i];
                if (a) {
                    if (e.GetObjectClass().BelongsToFamily(t)) {
                        n = e;
                        break
                    }
                } else if (e.GetObjectClass() === t) {
                    n = e;
                    break
                }
            }
            if (!n) {
                const e = t.GetInstances();
                e.length && (n = e[e.length - 1])
            }
            if (!n)
                return !1;
            const i = t.GetCurrentSol();
            return i.PickOne(n),
            t.ApplySolToContainer(),
            !0
        },
        Repeat(e) {
            return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e)
        },
        While() {
            return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
        },
        For(e, t, a) {
            return this._runtime.IsDebugging() ? this._DebugFor(e, t, a) : this._For(e, t, a)
        },
        ForEach(e) {
            return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e)
        },
        ForEachOrdered(e, t, a) {
            return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, a) : this._ForEachOrdered(e, a)
        },
        LayerVisible(e) {
            return !!e && e.IsVisible()
        },
        LayerEmpty(e) {
            return !!e && !e.GetInstanceCount()
        },
        LayerCmpOpacity(e, t, a) {
            return !!e && C3.compare(100 * e.GetOpacity(), t, a)
        },
        OnImageLoadingComplete() {
            return !0
        },
        IsLoadingImages() {
            return 0 < this._imagesLoadingTotal
        }
    }
}
{
    function t(t, n) {
        const a = t[0]
          , r = n[0]
          , i = a - r;
        if (0 != i)
            return i;
        const e = t[1]
          , l = n[1];
        return e - l
    }
    function a(e, t) {
        return e[1] - t[1]
    }
    const r = []
      , i = []
      , n = C3.New(C3.Color);
    C3.Plugins.System.Acts = {
        SetVar(e, t) {
            e.SetValue(t)
        },
        AddVar(e, t) {
            e.IsNumber() && 'number' != typeof t && (t = parseFloat(t)),
            e.SetValue(e.GetValue() + t)
        },
        SubVar(e, t) {
            e.IsNumber() && e.SetValue(e.GetValue() - t)
        },
        SetBoolVar(e, t) {
            e.SetValue(!!t)
        },
        ToggleBoolVar(e) {
            e.SetValue(!e.GetValue())
        },
        ResetGlobals() {
            this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
        },
        CreateObject(t, a, n, r) {
            if (t && a) {
                const i = this._runtime.CreateInstance(t, a, n, r);
                if (i) {
                    const e = this._runtime.GetEventSheetManager();
                    if (e.BlockFlushingInstances(!0),
                    i._TriggerOnCreated(),
                    i.IsInContainer())
                        for (const e of i.siblings())
                            e._TriggerOnCreated();
                    e.BlockFlushingInstances(!1),
                    t.GetCurrentSol().SetSinglePicked(i),
                    i.IsInContainer() && i.SetSiblingsSinglePicked()
                }
            }
        },
        CreateObjectByName(t, a, n, r) {
            if (t && a) {
                const i = this._runtime.GetObjectClassByName(t);
                i && C3.Plugins.System.Acts.CreateObject.call(this, i, a, n, r)
            }
        },
        RecreateInitialObjects(t, a, n, r, i) {
            t && this._runtime.GetCurrentLayout().RecreateInitialObjects(t, a, n, r, i)
        },
        StopLoop() {
            const e = this._loopStack;
            e.IsInLoop() && e.GetCurrent().Stop()
        },
        SetGroupActive(e, t) {
            const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
            n && (0 === t ? n.SetGroupActive(!1) : 1 === t ? n.SetGroupActive(!0) : n.SetGroupActive(!n.IsGroupActive()))
        },
        SetTimescale(e) {
            this._runtime.SetTimeScale(e)
        },
        SetObjectTimescale(e, t) {
            if (0 > t && (t = 0),
            !!e) {
                const a = e.GetCurrentSol()
                  , n = a.GetInstances();
                for (const e of n)
                    e.SetTimeScale(t)
            }
        },
        RestoreObjectTimescale(e) {
            if (e) {
                const t = e.GetCurrentSol()
                  , n = t.GetInstances();
                for (const e of n)
                    e.RestoreTimeScale()
            }
        },
        Wait(e) {
            if (!(0 > e))
                return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(e),
                !0
        },
        WaitForSignal(e) {
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e),
            !0
        },
        WaitForPreviousActions() {
            const e = this._runtime.GetEventSheetManager();
            return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()),
            !0
        },
        Signal(e) {
            const t = e.toLowerCase();
            for (const a of this._runtime.GetEventSheetManager().scheduledWaits())
                a.IsSignal() && a.GetSignalTag() === t && a.SetSignalled()
        },
        async SnapshotCanvas(e, t) {
            const a = this._runtime.GetCanvasManager();
            a && (this.UpdateRender(),
            await a.SnapshotCanvas(0 === e ? 'image/png' : 'image/jpeg', t / 100),
            await this._runtime.TriggerAsync(C3.Plugins.System.Cnds.OnCanvasSnapshot, null))
        },
        SetCanvasSize(e, t) {
            if (!(0 >= e || 0 >= t)) {
                this._runtime.SetViewportSize(e, t);
                const n = this._runtime.GetCurrentLayout();
                n.BoundScrolling();
                for (const e of n.GetLayers())
                    e.UpdateViewport();
                const a = this._runtime.GetCanvasManager();
                a && ('off' === a.GetCurrentFullscreenMode() ? a.SetSize(a.GetLastWidth(), a.GetLastHeight(), !0) : (this._runtime.SetOriginalViewportSize(e, t),
                a.SetSize(a.GetLastWidth(), a.GetLastHeight(), !0)),
                this._runtime.UpdateRender())
            }
        },
        SetFullscreenQuality(e) {
            const t = this._runtime.GetCanvasManager();
            t && 'off' !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 === e ? 'low' : 'high'),
            t.SetSize(t.GetLastWidth(), t.GetLastHeight(), !0))
        },
        SaveState(e) {
            this._runtime.SaveToSlot(e)
        },
        LoadState(e) {
            this._runtime.LoadFromSlot(e)
        },
        LoadStateJSON(e) {
            this._runtime.LoadFromJsonString(e)
        },
        SetHalfFramerateMode() {},
        ResetPersisted() {
            for (const e of this._runtime.GetLayoutManager().GetAllLayouts())
                e.ResetPersistData()
        },
        SetPixelRounding(e) {
            this._runtime.SetPixelRoundingEnabled(0 !== e)
        },
        SetMinimumFramerate(e) {
            this._runtime.SetMinimumFramerate(e)
        },
        SortZOrderByInstVar(_, e) {
            if (!_)
                return;
            const d = _.GetCurrentSol()
              , u = d.GetInstances()
              , g = r
              , p = i
              , h = this._runtime.GetCurrentLayout()
              , l = _.IsFamily()
              , m = _.GetFamilyIndex();
            for (let t = 0, a = u.length; t < a; ++t) {
                const a = u[t]
                  , n = a.GetWorldInfo();
                if (!n)
                    continue;
                let r;
                r = l ? a.GetInstanceVariableValue(e + a.GetObjectClass().GetFamilyInstanceVariableOffset(m)) : a.GetInstanceVariableValue(e),
                g.push([n.GetLayer().GetIndex(), n.GetZIndex()]),
                p.push([a, r])
            }
            if (!g.length)
                return;
            g.sort(t),
            p.sort(a);
            let n = !1;
            for (let t = 0, a = g.length; t < a; ++t) {
                const a = p[t][0]
                  , r = h.GetLayerByIndex(g[t][0])
                  , i = g[t][1]
                  , l = r._GetInstances();
                l[i] !== a && (l[i] = a,
                a.GetWorldInfo()._SetLayer(r),
                r.SetZIndicesChanged(),
                n = !0)
            }
            n && this._runtime.UpdateRender(),
            C3.clearArray(r),
            C3.clearArray(i)
        },
        GoToLayout(e) {
            if (!this._runtime.IsLoading()) {
                const t = this._runtime.GetLayoutManager();
                t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e)
            }
        },
        GoToLayoutByName(e) {
            if (!this._runtime.IsLoading()) {
                const t = this._runtime.GetLayoutManager();
                if (!t.IsPendingChangeMainLayout()) {
                    const a = t.GetLayoutByName(e);
                    a && t.ChangeMainLayout(a)
                }
            }
        },
        NextPrevLayout(t) {
            if (!this._runtime.IsLoading()) {
                const a = this._runtime.GetLayoutManager();
                if (!a.IsPendingChangeMainLayout()) {
                    const n = a.GetAllLayouts()
                      , r = n.indexOf(a.GetMainRunningLayout());
                    if (!(t && 0 === r) && (t || r !== n.length - 1)) {
                        const i = n[r + (t ? -1 : 1)];
                        a.ChangeMainLayout(i)
                    }
                }
            }
        },
        RestartLayout() {
            if (!this._runtime.IsLoading()) {
                const e = this._runtime.GetLayoutManager();
                e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()),
                this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
            }
        },
        SetLayerVisible(e, t) {
            e && e.SetVisible(t)
        },
        SetLayerOpacity(e, t) {
            e && e.SetOpacity(t / 100)
        },
        SetLayerScale(e, t) {
            e && e.SetOwnScale(t)
        },
        SetLayerScaleRate(e, t) {
            e && e.SetScaleRate(t)
        },
        SetLayerAngle(e, t) {
            e && (t = C3.clampAngle(C3.toRadians(+t)),
            e.GetOwnAngle() === t || (e.SetAngle(t),
            this.UpdateRender()))
        },
        SetLayerParallax(e, t, a) {
            e && e.SetParallax(t / 100, a / 100)
        },
        SetLayerZElevation(e, t) {
            e && e.SetZElevation(t)
        },
        SetLayerBackground(e, t) {
            if (e) {
                n.setFromRgbValue(t),
                n.clamp();
                const a = e.GetBackgroundColor();
                a.equalsIgnoringAlpha(n) || (a.copyRgb(n),
                this.UpdateRender())
            }
        },
        SetLayerTransparent(e, t) {
            e && (t = !!t,
            e.IsTransparent() === t || (e.SetTransparent(t),
            this.UpdateRender()))
        },
        SetLayerBlendMode(e, t) {
            e && e.GetBlendMode() !== t && (e.SetBlendMode(t),
            this.UpdateRender())
        },
        SetLayerEffectEnabled(e, t, a) {
            if (e) {
                const n = e.GetEffectList()
                  , r = n.GetEffectTypeByName(a);
                if (r) {
                    const e = 1 === t;
                    r.IsActive() === e || (r.SetActive(e),
                    n.UpdateActiveEffects(),
                    this._runtime.UpdateRender())
                }
            }
        },
        SetLayerEffectParam(e, t, r, i) {
            if (e) {
                const l = e.GetEffectList()
                  , _ = l.GetEffectTypeByName(t);
                if (_) {
                    const e = _.GetIndex()
                      , t = l.GetEffectParametersForIndex(e);
                    if (r = Math.floor(r),
                    !(0 > r || r >= t.length)) {
                        const e = _.GetShaderProgram().GetParameterType(r);
                        if ('color' === e) {
                            n.setFromRgbValue(i);
                            const e = t[r];
                            if (n.equalsIgnoringAlpha(e))
                                return;
                            e.copyRgb(n)
                        } else {
                            if ('percent' === e && (i /= 100),
                            t[r] === i)
                                return;
                            t[r] = i
                        }
                        _.IsActive() && this._runtime.UpdateRender()
                    }
                }
            }
        },
        SetLayerForceOwnTexture(e, t) {
            e && (t = !!t,
            e.IsForceOwnTexture() === t || (e.SetForceOwnTexture(t),
            this.UpdateRender()))
        },
        SetLayoutScale(e) {
            const t = this._runtime.GetCurrentLayout();
            t.GetScale() === e || (t.SetScale(e),
            this.UpdateRender())
        },
        SetLayoutAngle(e) {
            e = C3.clampAngle(C3.toRadians(+e));
            const t = this._runtime.GetCurrentLayout();
            t.GetAngle() === e || (t.SetAngle(e),
            this.UpdateRender())
        },
        SetLayoutEffectEnabled(e, t) {
            const a = this._runtime.GetCurrentLayout()
              , n = a.GetEffectList()
              , r = n.GetEffectTypeByName(t);
            if (r) {
                const t = 1 === e;
                r.IsActive() === t || (r.SetActive(t),
                n.UpdateActiveEffects(),
                this._runtime.UpdateRender())
            }
        },
        SetLayoutEffectParam(e, t, r) {
            const a = this._runtime.GetCurrentLayout()
              , i = a.GetEffectList()
              , l = i.GetEffectTypeByName(e);
            if (l) {
                const e = l.GetIndex()
                  , _ = i.GetEffectParametersForIndex(e);
                if (t = Math.floor(t),
                !(0 > t || t >= _.length)) {
                    const e = l.GetShaderProgram().GetParameterType(t);
                    if ('color' === e) {
                        n.setFromRgbValue(r);
                        const e = _[t];
                        if (n.equalsIgnoringAlpha(e))
                            return;
                        e.copyRgb(n)
                    } else {
                        if ('percent' === e && (r /= 100),
                        _[t] === r)
                            return;
                        _[t] = r
                    }
                    l.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        ScrollX(e) {
            const t = this._runtime.GetCurrentLayout();
            t.SetScrollX(e)
        },
        ScrollY(e) {
            const t = this._runtime.GetCurrentLayout();
            t.SetScrollY(e)
        },
        Scroll(e, t) {
            const a = this._runtime.GetCurrentLayout();
            a.SetScrollX(e),
            a.SetScrollY(t)
        },
        ScrollToObject(e) {
            if (e) {
                const t = e.GetFirstPicked();
                if (t) {
                    const e = t.GetWorldInfo();
                    if (e) {
                        const t = this._runtime.GetCurrentLayout();
                        t.SetScrollX(e.GetX()),
                        t.SetScrollY(e.GetY())
                    }
                }
            }
        },
        async LoadObjectTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            if (t && e && !this._runtime.IsLoading()) {
                const a = e.IsFamily() ? e.GetFamilyMembers() : [e];
                await this._LoadTexturesForObjectClasses(t, a)
            }
        },
        async LoadObjectTexturesByName(e) {
            await C3.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e))
        },
        UnloadObjectTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            if (t && e) {
                const a = e.IsFamily() ? e.GetFamilyMembers() : [e];
                this._UnloadTexturesForObjectClasses(t, a)
            }
        },
        UnloadObjectTexturesByName(e) {
            C3.Plugins.System.Acts.UnloadObjectTexturesByName.call(this, this._runtime.GetObjectClassByName(e))
        },
        UnloadUnusedTextures() {
            const e = this._runtime.GetMainRunningLayout();
            if (e) {
                const t = e._GetTextureLoadedObjectTypes();
                this._UnloadTexturesForObjectClasses(e, t)
            }
        },
        async LoadLayoutTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            e && t && !this._runtime.IsLoading() && (await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses()))
        },
        async LoadLayoutTexturesByName(e) {
            const t = this._runtime.GetMainRunningLayout()
              , a = this._runtime.GetLayoutManager().GetLayoutByName(e);
            a && t && !this._runtime.IsLoading() && (await this._LoadTexturesForObjectClasses(t, a._GetInitialObjectClasses()))
        },
        SetFunctionReturnValue(e) {
            const t = this._eventStack.GetCurrentExpFuncStackFrame();
            if (t)
                switch (t.GetFunctionReturnType()) {
                case 1:
                    'number' == typeof e && t.SetFunctionReturnValue(e);
                    break;
                case 2:
                    'string' == typeof e && t.SetFunctionReturnValue(e);
                    break;
                case 3:
                    t.SetFunctionReturnValue(e);
                }
        },
        MapFunction(t, a, n) {
            const r = this._GetFunctionMap(t.toLowerCase(), !0)
              , i = r.strMap
              , e = a.toLowerCase();
            i.has(e) && console.warn(`[Construct 3] Function map '${t}' string '${a}' already in map; overwriting entry`);
            const l = C3.first(i.values()) || r.defaultFunc;
            if (l) {
                const r = 0 !== l.GetReturnType()
                  , i = 0 !== n.GetReturnType();
                if (r != i)
                    return void console.error(`[Construct 3] Function map '${t}' string '${a}' function return type not compatible with other functions in the map; entry ignored`)
            }
            i.set(e, n)
        },
        MapFunctionDefault(t, a) {
            const e = this._GetFunctionMap(t.toLowerCase(), !0);
            e.defaultFunc && console.warn(`[Construct 3] Function map '${t}' already has a default; overwriting entry`);
            const n = C3.first(e.strMap.values()) || e.defaultFunc;
            if (n) {
                const r = 0 !== n.GetReturnType()
                  , i = 0 !== a.GetReturnType();
                if (r != i)
                    return void console.error(`[Construct 3] Function map '${t}' default: function return type not compatible with other functions in the map; entry ignored`)
            }
            e.defaultFunc = a
        },
        CallMappedFunction(t, a, n) {
            n = Math.floor(n);
            const r = this._GetFunctionMap(t.toLowerCase(), !1);
            if (!r)
                return void console.warn(`[Construct 3] Call mapped function: map name '${t}' not found; call ignored`);
            let _ = r.strMap.get(a.toLowerCase());
            if (!_)
                if (r.defaultFunc)
                    _ = r.defaultFunc,
                    n = 0;
                else
                    return void console.warn(`[Construct 3] Call mapped function: no function associated with map '${t}' string '${a}'; call ignored (consider setting a default)`);
            if (_.IsEnabled()) {
                if (0 !== _.GetReturnType())
                    return void console.warn(`[Construct 3] Call mapped function: map '${t}' string '${a}' has a return type so cannot be called`);
                const e = this._runtime
                  , r = e.GetEventSheetManager()
                  , d = r.GetCurrentEvent()
                  , u = d.GetSolModifiersIncludingParents()
                  , c = 0 < u.length;
                c && r.PushCleanSol(u);
                const i = []
                  , g = r.FindFirstFunctionBlockParent(d);
                if (g) {
                    const e = g.GetFunctionParameters();
                    for (let t = n, a = e.length; t < a; ++t)
                        i.push(e[t].GetValue())
                }
                const m = _.GetFunctionParameters();
                for (let e = i.length, t = m.length; e < t; ++e)
                    i.push(m[e].GetInitialValue());
                return e.IsDebugging() ? this._DebugDoCallMappedFunction(r, _, i, c, u) : this._DoCallMappedFunction(r, _, i, c, u)
            }
        }
    }
}
'use strict',
C3.Plugins.System.Exps = {
    int: function(e) {
        return 'string' == typeof e && (e = parseInt(e, 10),
        isNaN(e) && (e = 0)),
        Math.floor(e)
    },
    float: function(e) {
        return 'string' == typeof e && (e = parseFloat(e),
        isNaN(e) && (e = 0)),
        e
    },
    str(e) {
        return e.toString()
    },
    len(e) {
        return 'string' == typeof e ? e.length : 0
    },
    random(e, t) {
        return 'undefined' == typeof t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e
    },
    choose(...e) {
        const t = Math.floor(this._runtime.Random() * e.length);
        return e[t]
    },
    pi() {
        return Math.PI
    },
    infinity() {
        return 1 / 0
    },
    sqrt(e) {
        return Math.sqrt(e)
    },
    abs(e) {
        return Math.abs(e)
    },
    round(e) {
        return Math.round(e)
    },
    floor(e) {
        return Math.floor(e)
    },
    ceil(e) {
        return Math.ceil(e)
    },
    sign(e) {
        return Math.sign(e)
    },
    sin(e) {
        return Math.sin(C3.toRadians(e))
    },
    cos(e) {
        return Math.cos(C3.toRadians(e))
    },
    tan(e) {
        return Math.tan(C3.toRadians(e))
    },
    asin(e) {
        return C3.toDegrees(Math.asin(e))
    },
    acos(e) {
        return C3.toDegrees(Math.acos(e))
    },
    atan(e) {
        return C3.toDegrees(Math.atan(e))
    },
    exp(e) {
        return Math.exp(e)
    },
    ln(e) {
        return Math.log(e)
    },
    log10(e) {
        return Math.log(e) / Math.LN10
    },
    max(...t) {
        let a = t[0];
        'number' != typeof a && (a = 0);
        for (let n = 1, r = t.length, e; n < r; ++n)
            e = t[n],
            'number' == typeof e && a < e && (a = e);
        return a
    },
    min(...t) {
        let a = t[0];
        'number' != typeof a && (a = 0);
        for (let n = 1, r = t.length, e; n < r; ++n)
            e = t[n],
            'number' == typeof e && a > e && (a = e);
        return a
    },
    clamp(e, t, a) {
        return C3.clamp(e, t, a)
    },
    distance(e, t, a, n) {
        return C3.distanceTo(e, t, a, n)
    },
    angle(e, t, a, n) {
        return C3.toDegrees(C3.angleTo(e, t, a, n))
    },
    lerp(e, t, a) {
        return C3.lerp(e, t, a)
    },
    unlerp(e, t, a) {
        return C3.unlerp(e, t, a)
    },
    qarp(e, t, a, n) {
        return C3.qarp(e, t, a, n)
    },
    cubic(t, e, a, n, r) {
        return C3.cubic(t, e, a, n, r)
    },
    cosp(e, t, a) {
        return C3.cosp(e, t, a)
    },
    anglediff(e, t) {
        return C3.toDegrees(C3.angleDiff(C3.toRadians(e), C3.toRadians(t)))
    },
    anglelerp(e, t, a) {
        return C3.toDegrees(C3.angleLerp(C3.toRadians(e), C3.toRadians(t), a))
    },
    anglerotate(e, t, a) {
        return C3.toDegrees(C3.angleRotate(C3.toRadians(e), C3.toRadians(t), C3.toRadians(a)))
    },
    setbit(e, t, n) {
        return e |= 0,
        t |= 0,
        n = 0 === n ? 0 : 1,
        e & ~(1 << t) | n << t
    },
    togglebit(e, t) {
        return e |= 0,
        t |= 0,
        e ^ 1 << t
    },
    getbit(e, t) {
        return e |= 0,
        t |= 0,
        e & 1 << t ? 1 : 0
    },
    newline() {
        return '\n'
    },
    uppercase(e) {
        return 'string' == typeof e ? e.toUpperCase() : ''
    },
    lowercase(e) {
        return 'string' == typeof e ? e.toLowerCase() : ''
    },
    left(e, t) {
        return 'string' == typeof e ? e.substr(0, t) : ''
    },
    mid(e, t, a) {
        return 'string' == typeof e ? 0 > a ? e.substr(t) : e.substr(t, a) : ''
    },
    right(e, t) {
        return 'string' == typeof e ? e.substr(e.length - t) : ''
    },
    trim(e) {
        return 'string' == typeof e ? e.trim() : ''
    },
    tokenat(e, t, a) {
        if ('string' != typeof e || 'string' != typeof a)
            return '';
        let n = e.split(a);
        return t = Math.floor(t),
        0 > t || t >= n.length ? '' : n[t]
    },
    tokencount(e, t) {
        return 'string' == typeof e && 'string' == typeof t && e.length ? e.split(t).length : 0
    },
    find(e, t) {
        return 'string' == typeof e && 'string' == typeof t ? e.search(new RegExp(C3.EscapeRegex(t),'i')) : -1
    },
    findcase(e, t) {
        return 'string' == typeof e && 'string' == typeof t ? e.search(new RegExp(C3.EscapeRegex(t),'')) : -1
    },
    replace(e, t, a) {
        return 'string' == typeof e && 'string' == typeof t && 'string' == typeof a ? e.replace(new RegExp(C3.EscapeRegex(t),'gi'), a) : 'string' == typeof e ? e : ''
    },
    regexsearch(e, t, a) {
        const n = this.GetRegex(t, a);
        return e ? e.search(n) : -1
    },
    regexreplace(t, a, n, r) {
        const i = this.GetRegex(a, n);
        return t ? t.replace(i, r) : ''
    },
    regexmatchcount(e, t, a) {
        const n = this.GetRegexMatches(e.toString(), t, a);
        return n ? n.length : 0
    },
    regexmatchat(t, a, n, r) {
        r = Math.floor(r);
        const i = this.GetRegexMatches(t.toString(), a, n);
        return !i || 0 > r || r >= i.length ? '' : i[r]
    },
    zeropad(e, t) {
        let n = 0 > e ? '-' : '';
        0 > e && (e = -e);
        const r = t - e.toString().length;
        return n += '0'.repeat(Math.max(r, 0)),
        n + e.toString()
    },
    urlencode(e) {
        return encodeURIComponent(e)
    },
    urldecode(e) {
        return decodeURIComponent(e)
    },
    dt() {
        return this._runtime._GetDtFast()
    },
    timescale() {
        return this._runtime.GetTimeScale()
    },
    wallclocktime() {
        return (Date.now() - this._runtime.GetStartTime()) / 1e3
    },
    unixtime() {
        return Date.now()
    },
    time() {
        return this._runtime.GetGameTime()
    },
    tickcount() {
        return this._runtime.GetTickCount()
    },
    objectcount() {
        return this._runtime.GetObjectCount()
    },
    fps() {
        return this._runtime.GetFPS()
    },
    cpuutilisation() {
        return this._runtime.GetMainThreadTime()
    },
    gpuutilisation() {
        return this._runtime.GetGPUUtilisation()
    },
    windowwidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    windowheight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    originalwindowwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalwindowheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    originalviewportwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalviewportheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    scrollx() {
        return this._runtime.GetCurrentLayout().GetScrollX()
    },
    scrolly() {
        return this._runtime.GetCurrentLayout().GetScrollY()
    },
    layoutname() {
        return this._runtime.GetCurrentLayout().GetName()
    },
    layoutscale() {
        return this._runtime.GetCurrentLayout().GetScale()
    },
    layoutangle() {
        return C3.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
    },
    layoutwidth() {
        return this._runtime.GetCurrentLayout().GetWidth()
    },
    layoutheight() {
        return this._runtime.GetCurrentLayout().GetHeight()
    },
    viewportleft(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().getLeft() : 0
    },
    viewporttop(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().getTop() : 0
    },
    viewportright(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().getRight() : 0
    },
    viewportbottom(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().getBottom() : 0
    },
    viewportwidth(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().width() : 0
    },
    viewportheight(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetViewport().height() : 0
    },
    canvastolayerx(e, t, a) {
        const n = this._runtime.GetCurrentLayout().GetLayer(e);
        return n ? n.CanvasCssToLayer(t, a)[0] : 0
    },
    canvastolayery(e, t, a) {
        const n = this._runtime.GetCurrentLayout().GetLayer(e);
        return n ? n.CanvasCssToLayer(t, a)[1] : 0
    },
    layertocanvasx(e, t, a) {
        const n = this._runtime.GetCurrentLayout().GetLayer(e);
        return n ? n.LayerToCanvasCss(t, a)[0] : 0
    },
    layertocanvasy(e, t, a) {
        const n = this._runtime.GetCurrentLayout().GetLayer(e);
        return n ? n.LayerToCanvasCss(t, a)[1] : 0
    },
    layerscale(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetOwnScale() : 0
    },
    layerangle(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? C3.toDegrees(t.GetOwnAngle()) : 0
    },
    layeropacity(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? 100 * t.GetOpacity() : 0
    },
    layerscalerate(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetScaleRate() : 0
    },
    layerparallaxx(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? 100 * t.GetParallaxX() : 0
    },
    layerparallaxy(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? 100 * t.GetParallaxY() : 0
    },
    layerzelevation(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetZElevation() : 0
    },
    layerindex(e) {
        const t = this._runtime.GetCurrentLayout().GetLayer(e);
        return t ? t.GetIndex() : -1
    },
    canvassnapshot() {
        const e = this._runtime.GetCanvasManager();
        return e ? e.GetCanvasSnapshotUrl() : ''
    },
    loopindex(e) {
        const t = this._loopStack;
        if (!t.IsInLoop())
            return 0;
        if (e) {
            const a = t.FindByName(e);
            return a ? a.GetIndex() : 0
        }
        return t.GetCurrent().GetIndex()
    },
    savestatejson() {
        return this._runtime.GetLastSaveJsonString()
    },
    callmapped(t, a, ...r) {
        const _ = this._GetFunctionMap(t.toLowerCase(), !1);
        if (!_)
            return console.warn(`[Construct 3] Call mapped function: map name '${t}' not found; returning 0`),
            0;
        let d = _.strMap.get(a.toLowerCase());
        if (!d)
            if (_.defaultFunc)
                d = _.defaultFunc;
            else
                return console.warn(`[Construct 3] Call mapped function: no function associated with map '${t}' string '${a}'; returning 0 (consider setting a default)`),
                0;
        const u = d.GetReturnType()
          , c = d.GetDefaultReturnValue();
        if (0 === u)
            return console.warn(`[Construct 3] Call mapped function: map '${t}' string '${a}' has no return type so cannot be called from an expression; returning 0`),
            0;
        if (!d.IsEnabled())
            return c;
        const g = this._runtime
          , p = g.GetEventSheetManager()
          , i = p.GetCurrentEvent()
          , h = i.GetSolModifiersIncludingParents()
          , f = 0 < h.length;
        f && p.PushCleanSol(h);
        const l = d.GetFunctionParameters();
        for (let n = r.length, i = l.length; n < i; ++n)
            r.push(l[n].GetInitialValue());
        const m = d.GetEventBlock()
          , n = m.RunAsExpressionFunctionCall(m.GetSolModifiersIncludingParents(), u, c, ...r);
        return f && p.PopSol(h),
        n
    },
    loadingprogress() {
        return this._runtime.GetAssetManager().GetLoadProgress()
    },
    imageloadingprogress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
    },
    renderer() {
        return 'webgl'
    },
    rendererdetail() {
        return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    imagememoryusage() {
        let e = this._runtime.GetWebGLRenderer().GetEstimatedTextureMemoryUsage();
        return Math.round(100 * e / 1048576) / 100
    },
    rgb(e, t, a) {
        return C3.PackRGB(e, t, a)
    },
    rgbex(e, t, a) {
        return C3.PackRGBEx(e / 100, t / 100, a / 100)
    },
    rgba(t, a, n, e) {
        return C3.PackRGBAEx(t / 100, a / 100, n / 100, e / 100)
    },
    rgbex255(e, t, a) {
        return C3.PackRGBEx(e / 255, t / 255, a / 255)
    },
    rgba255(t, a, n, e) {
        return C3.PackRGBAEx(t / 255, a / 255, n / 255, e / 255)
    },
    projectname() {
        return this._runtime.GetProjectName()
    },
    projectversion() {
        return this._runtime.GetProjectVersion()
    },
    currenteventsheetname() {
        return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
    },
    currenteventnumber() {
        return this._runtime.GetCurrentEvent().GetDisplayNumber()
    }
},
'use strict',
C3.Plugins.Sprite = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.Sprite.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e),
        this._animations = e.GetAnimations()
    }
    Release() {
        C3.clearArray(this._animations),
        super.Release()
    }
    OnCreate() {
        for (const e of this._animations)
            e.LoadAllAssets(this._runtime)
    }
    LoadTextures(e) {
        const t = {
            sampling: this._runtime.GetSampling()
        };
        return Promise.all(this._animations.map(a=>a.LoadAllTextures(e, t)))
    }
    ReleaseTextures() {
        for (const e of this._animations)
            e.ReleaseAllTextures()
    }
    OnDynamicTextureLoadComplete() {
        this._UpdateAllCurrentTexture()
    }
    _UpdateAllCurrentTexture() {
        for (const e of this._objectClass.instancesIncludingPendingCreate())
            e.GetSdkInstance()._UpdateCurrentTexture()
    }
    FinishCondition(e) {
        C3.Plugins.Sprite._FinishCondition(this, e)
    }
}
,
'use strict';
{
    const t = C3.New(C3.Quad)
      , n = C3.New(C3.Vector2);
    C3.Plugins.Sprite.Instance = class extends C3.SDKWorldInstanceBase {
        constructor(t, a) {
            super(t);
            let n = !0
              , r = ''
              , i = 0
              , l = !0;
            a && (n = !!a[0],
            r = a[1],
            i = a[2],
            l = a[3]),
            this._currentAnimation = this._objectClass.GetAnimationByName(r) || this._objectClass.GetAnimations()[0],
            this._currentFrameIndex = C3.clamp(i, 0, this._currentAnimation.GetFrameCount() - 1),
            this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const _ = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = _.GetTexture(),
            this._currentRcTex = _.GetTexRect(),
            this.HandleWebGLContextLoss(),
            t.SetFlag(2, !0),
            t.SetFlag(1, 0 <= this._currentAnimation.GetSpeed()),
            this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()),
            this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(),
            this._animationTimer = C3.New(C3.KahanSum),
            this._frameStartTime = 0,
            this._animationRepeats = 0,
            this._animTriggerName = '',
            this._changeAnimFrameIndex = -1,
            this._changeAnimationName = '',
            this._changeAnimationFrom = 0;
            const u = this.GetWorldInfo();
            this._bquadRef = u.GetBoundingQuad(),
            u.SetVisible(n),
            u.SetCollisionEnabled(l),
            u.SetOriginX(this._currentAnimationFrame.GetOriginX()),
            u.SetOriginY(this._currentAnimationFrame.GetOriginY()),
            u.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()),
            u.SetBboxChanged(),
            (1 !== this._objectClass.GetAnimationCount() || 1 !== this._objectClass.GetAnimations()[0].GetFrameCount()) && 0 !== this._currentAnimationSpeed && this._StartTicking()
        }
        Release() {
            this._currentAnimation = null,
            this._currentAnimationFrame = null,
            this._currentTexture = null,
            this._animationTimer = null,
            super.Release()
        }
        GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo()
        }
        OnWebGLContextLost() {
            this._currentTexture = null
        }
        OnWebGLContextRestored() {
            this._UpdateCurrentTexture()
        }
        Draw(a) {
            var n = Math.round;
            const r = this._currentTexture;
            if (null !== r) {
                const i = this._bquadRef
                  , e = this._currentRcTex;
                if (a.SetTexture(r),
                this._runtime.IsPixelRoundingEnabled()) {
                    const r = this.GetWorldInfo()
                      , l = n(r.GetX()) - r.GetX()
                      , _ = n(r.GetY()) - r.GetY();
                    t.copy(i),
                    t.offset(l, _),
                    a.Quad3(t, e)
                } else
                    a.Quad3(i, e)
            }
        }
        _DrawCollisionPoly(t) {
            const a = this.GetWorldInfo()
              , n = a.GetTransformedCollisionPoly();
            t.SetColorFillMode(),
            t.SetColorRgba(1, 0, 0, 1);
            const r = n.pointsArr()
              , l = a.GetX()
              , e = a.GetY();
            for (let a = 0, n = r.length; a < n; a += 2) {
                const _ = (a + 2) % n
                  , d = r[a] + l
                  , u = r[a + 1] + e
                  , i = r[_] + l
                  , c = r[_ + 1] + e;
                t.Line(d, u, i, c)
            }
            t.SetTextureFillMode(),
            t.SetColorRgba(1, 1, 1, 1)
        }
        GetAnimationTime() {
            return this._animationTimer.Get()
        }
        IsAnimationPlaying() {
            return this._inst.GetFlag(2)
        }
        SetAnimationPlaying(e) {
            this._inst.SetFlag(2, e)
        }
        IsPlayingForwards() {
            return this._inst.GetFlag(1)
        }
        SetPlayingForwards(e) {
            this._inst.SetFlag(1, e)
        }
        IsInAnimationTrigger() {
            return this._inst.GetFlag(4)
        }
        SetInAnimationTrigger(e) {
            this._inst.SetFlag(4, e)
        }
        Tick() {
            this._changeAnimationName && this._DoChangeAnimation(),
            0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
            const t = this._currentAnimationSpeed;
            if (!this.IsAnimationPlaying() || 0 === t)
                return void this._StopTicking();
            const a = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(a);
            const n = this.GetAnimationTime()
              , r = this._currentAnimationFrame
              , l = r.GetDuration() / t;
            if (!(n < this._frameStartTime + l)) {
                const e = this._currentAnimation
                  , a = this._currentAnimationRepeatTo
                  , _ = e.GetFrameCount()
                  , d = e.GetRepeatCount()
                  , u = e.IsLooping()
                  , i = e.IsPingPong();
                this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--,
                this._frameStartTime += l,
                this._currentFrameIndex >= _ && (i ? (this.SetPlayingForwards(!1),
                this._currentFrameIndex = _ - 2) : u ? this._currentFrameIndex = a : (this._animationRepeats++,
                this._animationRepeats >= d ? this._FinishAnimation(!1) : this._currentFrameIndex = a)),
                0 > this._currentFrameIndex && (i ? (this._currentFrameIndex = 1,
                this.SetPlayingForwards(!0),
                !u && (this._animationRepeats++,
                this._animationRepeats >= d && this._FinishAnimation(!0))) : u ? this._currentFrameIndex = a : (this._animationRepeats++,
                this._animationRepeats >= d ? this._FinishAnimation(!0) : this._currentFrameIndex = a)),
                this._currentFrameIndex = C3.clamp(this._currentFrameIndex, 0, _ - 1);
                const c = e.GetFrameAt(this._currentFrameIndex);
                n > this._frameStartTime + c.GetDuration() / t && (this._frameStartTime = n),
                this._OnFrameChanged(r, c)
            }
        }
        _FinishAnimation(e) {
            this._currentFrameIndex = e ? 0 : this._currentAnimation.GetFrameCount() - 1,
            this.SetAnimationPlaying(!1),
            this._animTriggerName = this._currentAnimation.GetName(),
            this.SetInAnimationTrigger(!0),
            this.Trigger(C3.Plugins.Sprite.Cnds.OnAnyAnimFinished),
            this.Trigger(C3.Plugins.Sprite.Cnds.OnAnimFinished),
            this.SetInAnimationTrigger(!1),
            this._animationRepeats = 0
        }
        _OnFrameChanged(t, a) {
            const n = this.GetWorldInfo()
              , r = t.GetImageInfo()
              , l = a.GetImageInfo()
              , e = r.GetWidth()
              , _ = r.GetHeight()
              , d = l.GetWidth()
              , u = l.GetHeight();
            e !== d && n.SetWidth(n.GetWidth() * (d / e)),
            _ !== u && n.SetHeight(n.GetHeight() * (u / _)),
            n.SetOriginX(a.GetOriginX()),
            n.SetOriginY(a.GetOriginY()),
            n.SetSourceCollisionPoly(a.GetCollisionPoly()),
            n.SetBboxChanged(),
            this._currentAnimationFrame = a,
            this._currentTexture = l.GetTexture(),
            this._currentRcTex = l.GetTexRect();
            const i = this.GetInstance().GetBehaviorInstances();
            for (let e = 0, n = i.length; e < n; ++e)
                i[e].OnSpriteFrameChanged(t, a);
            this.Trigger(C3.Plugins.Sprite.Cnds.OnFrameChanged),
            this._runtime.UpdateRender()
        }
        _StartAnim(e) {
            this.SetAnimationPlaying(!0),
            this._frameStartTime = this.GetAnimationTime(),
            1 === e && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0,
            !this.IsInAnimationTrigger() && this._DoChangeAnimFrame()),
            this._StartTicking()
        }
        _SetAnim(e, t) {
            this._changeAnimationName = e,
            this._changeAnimationFrom = t,
            this._StartTicking(),
            this.IsInAnimationTrigger() || this._DoChangeAnimation()
        }
        _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
        }
        _SetAnimFrame(e) {
            isFinite(e) && (this._changeAnimFrameIndex = e,
            !this.IsInAnimationTrigger() && this._DoChangeAnimFrame())
        }
        _GetAnimFrame() {
            return this._currentFrameIndex
        }
        _SetAnimSpeed(e) {
            this._currentAnimationSpeed = Math.abs(e),
            this.SetPlayingForwards(0 <= e),
            0 < this._currentAnimationSpeed && this._StartTicking()
        }
        _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
        }
        _SetAnimRepeatToFrame(e) {
            e = C3.clamp(Math.floor(e), 0, this._currentAnimation.GetFrameCount() - 1),
            this._currentAnimationRepeatTo = e
        }
        _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo
        }
        _DoChangeAnimation() {
            const e = this._currentAnimationFrame
              , t = this._objectClass.GetAnimationByName(this._changeAnimationName);
            if ((this._changeAnimationName = '',
            !!t) && !(t === this._currentAnimation && this.IsAnimationPlaying())) {
                this._currentAnimation = t,
                this.SetPlayingForwards(0 <= t.GetSpeed()),
                this._currentAnimationSpeed = Math.abs(t.GetSpeed()),
                this._currentAnimationRepeatTo = t.GetRepeatTo(),
                this._currentFrameIndex = C3.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1),
                1 === this._changeAnimationFrom && (this._currentFrameIndex = 0),
                this.SetAnimationPlaying(!0),
                this._frameStartTime = this.GetAnimationTime();
                const a = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
                this._OnFrameChanged(e, a)
            }
        }
        _DoChangeAnimFrame() {
            const e = this._currentAnimationFrame
              , t = this._currentFrameIndex;
            if (this._currentFrameIndex = C3.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1),
            this._changeAnimFrameIndex = -1,
            t !== this._currentFrameIndex) {
                const t = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
                this._OnFrameChanged(e, t),
                this._frameStartTime = this.GetAnimationTime()
            }
        }
        _UpdateCurrentTexture() {
            const e = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = e.GetTexture(),
            this._currentRcTex = e.GetTexRect()
        }
        GetImagePoint(t) {
            const a = this._currentAnimationFrame
              , r = this.GetWorldInfo();
            let i = null;
            if ('string' == typeof t)
                i = a.GetImagePointByName(t);
            else if ('number' == typeof t)
                i = a.GetImagePointByIndex(t - 1);
            else
                throw new TypeError('expected string or number');
            return i ? (n.copy(i.GetVec2()),
            n.offset(-a.GetOriginX(), -a.GetOriginY()),
            n.scale(r.GetWidth(), r.GetHeight()),
            n.rotate(r.GetAngle()),
            n.offset(r.GetX(), r.GetY()),
            [n.getX(), n.getY()]) : [r.GetX(), r.GetY()]
        }
        GetDebuggerProperties() {
            const e = C3.Plugins.Sprite.Acts;
            return [{
                title: 'plugins.sprite.debugger.animation-properties.title',
                properties: [{
                    name: 'plugins.sprite.debugger.animation-properties.current-animation',
                    value: this._currentAnimation.GetName(),
                    onedit: t=>this.CallAction(e.SetAnim, t, 0)
                }, {
                    name: 'plugins.sprite.debugger.animation-properties.current-frame',
                    value: this._currentFrameIndex,
                    onedit: t=>this.CallAction(e.SetAnimFrame, t)
                }, {
                    name: 'plugins.sprite.debugger.animation-properties.is-playing',
                    value: this.IsAnimationPlaying(),
                    onedit: t=>t ? this.CallAction(e.StartAnim, 0) : this.CallAction(e.StopAnim)
                }, {
                    name: 'plugins.sprite.debugger.animation-properties.speed',
                    value: this._currentAnimationSpeed,
                    onedit: t=>this.CallAction(e.SetAnimSpeed, t)
                }, {
                    name: 'plugins.sprite.debugger.animation-properties.repeats',
                    value: this._animationRepeats,
                    onedit: e=>this._animationRepeats = e
                }]
            }]
        }
        SaveToJson() {
            const e = {
                a: this._currentAnimation.GetSID()
            };
            0 !== this._frameStartTime && (e.fs = this._frameStartTime);
            const t = this.GetAnimationTime();
            0 !== t && (e.at = t),
            0 !== this._currentFrameIndex && (e.f = this._currentFrameIndex),
            0 !== this._currentAnimationSpeed && (e.cas = this._currentAnimationSpeed),
            1 !== this._animationRepeats && (e.ar = this._animationRepeats),
            0 !== this._currentAnimationRepeatTo && (e.rt = this._currentAnimationRepeatTo),
            this.IsAnimationPlaying() || (e.ap = this.IsAnimationPlaying()),
            this.IsPlayingForwards() || (e.af = this.IsPlayingForwards());
            const a = this.GetWorldInfo();
            return a.IsCollisionEnabled() && (e.ce = a.IsCollisionEnabled()),
            e
        }
        LoadFromJson(t) {
            const a = this.GetObjectClass().GetAnimationBySID(t.a);
            a && (this._currentAnimation = a),
            this._frameStartTime = t.hasOwnProperty('fs') ? t.fs : 0,
            this._animationTimer.Set(t.hasOwnProperty('at') ? t.at : 0);
            const n = t.hasOwnProperty('f') ? t.f : 0;
            this._currentFrameIndex = C3.clamp(n, 0, this._currentAnimation.GetFrameCount() - 1),
            this._currentAnimationSpeed = t.hasOwnProperty('cas') ? t.cas : 0,
            this._animationRepeats = t.hasOwnProperty('ar') ? t.ar : 1;
            const r = t.hasOwnProperty('rt') ? t.rt : 0;
            this._currentAnimationRepeatTo = C3.clamp(r, 0, this._currentAnimation.GetFrameCount() - 1),
            this.SetAnimationPlaying(!t.hasOwnProperty('ap') || !!t.ap),
            this.SetPlayingForwards(!t.hasOwnProperty('af') || !!t.af);
            const i = this._currentAnimation.GetFrameAt(this._currentFrameIndex)
              , e = i.GetImageInfo();
            this._currentAnimationFrame = i,
            this._currentTexture = e.GetTexture(),
            this._currentRcTex = e.GetTexRect();
            const l = this.GetWorldInfo();
            l.SetOriginX(i.GetOriginX()),
            l.SetOriginY(i.GetOriginY()),
            l.SetSourceCollisionPoly(i.GetCollisionPoly()),
            l.SetCollisionEnabled(!!t.ce)
        }
        GetPropertyValueByIndex(e) {
            const t = this.GetWorldInfo();
            return 3 === e ? t.IsCollisionEnabled() : void 0
        }
        SetPropertyValueByIndex(e, t) {
            const a = this.GetWorldInfo();
            3 === e ? a.SetCollisionEnabled(!!t) : void 0
        }
        GetScriptInterfaceClass() {
            return ISpriteInstance
        }
    }
    ;
    const r = new WeakMap
      , i = new Map([['current-frame', 0], ['beginning', 1]]);
    self.ISpriteInstance = class extends IWorldInstance {
        constructor() {
            super(),
            r.set(this, IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePointX(e) {
            if ('string' != typeof e && 'number' != typeof e)
                throw new TypeError('expected string or number');
            return r.get(this).GetImagePoint(e)[0]
        }
        getImagePointY(e) {
            if ('string' != typeof e && 'number' != typeof e)
                throw new TypeError('expected string or number');
            return r.get(this).GetImagePoint(e)[1]
        }
        stopAnimation() {
            r.get(this).SetAnimationPlaying(!1)
        }
        startAnimation(e='current-frame') {
            const t = i.get(e);
            if ('undefined' == typeof t)
                throw new Error('invalid mode');
            r.get(this)._StartAnim(t)
        }
        setAnimation(t, a='beginning') {
            const n = i.get(a);
            if ('undefined' == typeof n)
                throw new Error('invalid mode');
            r.get(this)._SetAnim(t, n)
        }
        get animationName() {
            return r.get(this)._GetCurrentAnimationName()
        }
        set animationFrame(e) {
            r.get(this)._SetAnimFrame(e)
        }
        get animationFrame() {
            return r.get(this)._GetAnimFrame()
        }
        set animationSpeed(e) {
            r.get(this)._SetAnimSpeed(e)
        }
        get animationSpeed() {
            return r.get(this)._GetAnimSpeed()
        }
        set animationRepeatToFrame(e) {
            r.get(this)._SetAnimRepeatToFrame(e)
        }
        get animationRepeatToFrame() {
            return r.get(this)._GetAnimRepeatToFrame()
        }
        get imageWidth() {
            return r.get(this).GetCurrentImageInfo().GetWidth()
        }
        get imageHeight() {
            return r.get(this).GetCurrentImageInfo().GetHeight()
        }
    }
}
{
    function t(t, n, r, a) {
        const i = n.GetUID()
          , e = r.GetUID();
        i < e ? t.Set(n, r, a) : t.Set(r, n, a)
    }
    function a(t, n, r) {
        const a = n.GetUID()
          , i = r.GetUID();
        a < i ? t.Delete(n, r) : t.Delete(r, n)
    }
    function n(e, t) {
        e.DeleteEither(t)
    }
    function _(t, n, r) {
        const a = n.GetUID()
          , i = r.GetUID();
        return a < i ? t.Get(n, r) : t.Get(r, n)
    }
    function r(l, a, _, c) {
        if (!a)
            return !1;
        const d = l.GetInstance()
          , e = 0 !== _ || 0 !== c
          , f = d.GetWorldInfo()
          , h = d.GetRuntime()
          , m = h.GetCollisionEngine()
          , n = h.GetCurrentCondition()
          , G = n.GetEventBlock().IsOrBlock()
          , p = n.GetObjectClass()
          , b = n.IsInverted()
          , r = a.GetCurrentSol()
          , T = p !== a;
        y = a,
        i = T && !b;
        let t = 0, I = 0, C = !1, P;
        r.IsSelectAll() ? (S.copy(f.GetBoundingBox()),
        S.offset(_, c),
        m.GetCollisionCandidates(f.GetLayer(), a, S, g),
        P = g) : G ? h.IsCurrentConditionFirst() && !r._GetOwnElseInstances().length && r._GetOwnInstances().length ? P = r._GetOwnInstances() : P = r._GetOwnElseInstances() : P = r._GetOwnInstances(),
        e && (t = f.GetX(),
        I = f.GetY(),
        f.OffsetXY(_, c),
        f.SetBboxChanged());
        for (const e of P)
            if (m.TestOverlap(d, e)) {
                if (C = !0,
                b)
                    break;
                T && u.add(e)
            }
        return e && (f.SetXY(t, I),
        f.SetBboxChanged()),
        C3.clearArray(g),
        C
    }
    function e(t) {
        const a = t.GetRuntime().GetCurrentEvent().IsOrBlock()
          , n = y.GetCurrentSol()
          , r = n._GetOwnInstances()
          , i = n._GetOwnElseInstances();
        if (n.IsSelectAll()) {
            if (n._SetSelectAll(!1),
            C3.shallowAssignArray(r, [...u]),
            a) {
                C3.clearArray(i);
                for (const e of y.GetInstances())
                    u.has(e) || n._PushElseInstance(e)
            }
        } else if (a)
            for (const e of u)
                r.push(e),
                C3.arrayFindRemove(i, e);
        else
            C3.shallowAssignArray(r, [...u]);
        y.ApplySolToContainer()
    }
    const S = C3.New(C3.Rect)
      , d = []
      , g = [];
    let i = !1
      , y = null;
    const u = new Set;
    C3.Plugins.Sprite._FinishCondition = function(t, a) {
        i && (a && e(t),
        u.clear(),
        y = null,
        i = !1)
    }
    ,
    C3.Plugins.Sprite.Cnds = {
        OnCollision(S) {
            if (this._runtime.IsDebugging())
                return C3.Plugins.Sprite.Cnds.DebugOnCollision.call(this, S);
            if (!S)
                return !1;
            const e = this._runtime
              , y = e.GetCollisionEngine()
              , g = e.GetEventSheetManager()
              , i = g.GetEventStack()
              , c = g.GetCurrentCondition()
              , G = c.GetObjectClass()
              , l = c.GetSavedDataMap()
              , m = c.GetUnsavedDataMap()
              , T = i.GetCurrentStackFrame()
              , I = e.GetTickCount()
              , p = T.GetCurrentEvent()
              , C = i.Push(p);
            let r = l.get('collmemory');
            r || (r = C3.New(C3.PairMap),
            l.set('collmemory', r)),
            m.get('spriteCreatedDestroyCallback') || (m.set('spriteCreatedDestroyCallback', !0),
            e.Dispatcher().addEventListener('instancedestroy', e=>n(r, e.instance)));
            const h = G.GetCurrentSol()
              , b = S.GetCurrentSol()
              , u = h.GetInstances();
            let v = null;
            for (let e = 0; e < u.length; ++e) {
                const n = u[e];
                b.IsSelectAll() ? (y.GetCollisionCandidates(n.GetWorldInfo().GetLayer(), S, n.GetWorldInfo().GetBoundingBox(), d),
                v = d,
                y.AddRegisteredCollisionCandidates(n, S, v)) : v = b.GetInstances();
                for (let e = 0; e < v.length; ++e) {
                    const i = v[e];
                    if (y.TestOverlap(n, i) || y.CheckRegisteredCollision(n, i)) {
                        const e = _(r, n, i);
                        let a = !1
                          , l = -2;
                        'number' == typeof e && (a = !0,
                        l = e);
                        const d = !a || l < I - 1;
                        if (t(r, n, i, I),
                        d) {
                            const e = p.GetSolModifiers();
                            g.PushCopySol(e);
                            const t = G.GetCurrentSol()
                              , r = S.GetCurrentSol();
                            if (t._SetSelectAll(!1),
                            r._SetSelectAll(!1),
                            G === S) {
                                const e = t._GetOwnInstances();
                                C3.clearArray(e),
                                e.push(n),
                                e.push(i),
                                G.ApplySolToContainer()
                            } else {
                                const e = t._GetOwnInstances()
                                  , a = r._GetOwnInstances();
                                C3.clearArray(e),
                                C3.clearArray(a),
                                e.push(n),
                                a.push(i),
                                G.ApplySolToContainer(),
                                S.ApplySolToContainer()
                            }
                            p.Retrigger(T, C),
                            g.PopSol(e)
                        }
                    } else
                        a(r, n, i)
                }
                C3.clearArray(d)
            }
            return i.Pop(),
            !1
        },
        *DebugOnCollision(S) {
            if (!S)
                return !1;
            const e = this._runtime
              , y = e.GetCollisionEngine()
              , g = e.GetEventSheetManager()
              , i = g.GetEventStack()
              , G = i.GetCurrentStackFrame()
              , T = e.GetTickCount()
              , l = G.GetCurrentEvent()
              , m = i.Push(l)
              , c = g.GetCurrentCondition()
              , I = c.GetObjectClass()
              , p = c.GetSavedDataMap()
              , h = c.GetUnsavedDataMap();
            let r = p.get('collmemory');
            r || (r = C3.New(C3.PairMap),
            p.set('collmemory', r)),
            h.get('spriteCreatedDestroyCallback') || (h.set('spriteCreatedDestroyCallback', !0),
            e.Dispatcher().addEventListener('instancedestroy', e=>n(r, e.instance)));
            const f = I.GetCurrentSol()
              , b = S.GetCurrentSol()
              , u = f.GetInstances();
            let C = null;
            for (let e = 0; e < u.length; ++e) {
                const n = u[e];
                b.IsSelectAll() ? (y.GetCollisionCandidates(n.GetWorldInfo().GetLayer(), S, n.GetWorldInfo().GetBoundingBox(), d),
                C = d,
                y.AddRegisteredCollisionCandidates(n, S, C)) : C = b.GetInstances();
                for (let e = 0; e < C.length; ++e) {
                    const i = C[e];
                    if (y.TestOverlap(n, i) || y.CheckRegisteredCollision(n, i)) {
                        const e = _(r, n, i);
                        let a = !1
                          , d = -2;
                        'number' == typeof e && (a = !0,
                        d = e);
                        const u = !a || d < T - 1;
                        if (t(r, n, i, T),
                        u) {
                            const e = l.GetSolModifiers();
                            g.PushCopySol(e);
                            const t = I.GetCurrentSol()
                              , r = S.GetCurrentSol();
                            if (t._SetSelectAll(!1),
                            r._SetSelectAll(!1),
                            I === S) {
                                const e = t._GetOwnInstances();
                                C3.clearArray(e),
                                e.push(n),
                                e.push(i),
                                I.ApplySolToContainer()
                            } else {
                                const e = t._GetOwnInstances()
                                  , a = r._GetOwnInstances();
                                C3.clearArray(e),
                                C3.clearArray(a),
                                e.push(n),
                                a.push(i),
                                I.ApplySolToContainer(),
                                S.ApplySolToContainer()
                            }
                            yield*l.DebugRetrigger(G, m),
                            g.PopSol(e)
                        }
                    } else
                        a(r, n, i)
                }
                C3.clearArray(d)
            }
            return i.Pop(),
            !1
        },
        IsOverlapping(e) {
            return r(this, e, 0, 0)
        },
        IsOverlappingOffset(e, t, a) {
            return r(this, e, t, a)
        },
        IsAnimPlaying(e) {
            return C3.equalsNoCase(this._GetCurrentAnimationName(), e)
        },
        CompareFrame(e, t) {
            return C3.compare(this._currentFrameIndex, e, t)
        },
        CompareAnimSpeed(e, t) {
            return C3.compare(this._GetAnimSpeed(), e, t)
        },
        OnAnimFinished(e) {
            return C3.equalsNoCase(this._animTriggerName, e)
        },
        OnAnyAnimFinished() {
            return !0
        },
        OnFrameChanged() {
            return !0
        },
        IsMirrored() {
            return 0 > this.GetWorldInfo().GetWidth()
        },
        IsFlipped() {
            return 0 > this.GetWorldInfo().GetHeight()
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        },
        IsCollisionEnabled() {
            return this.GetWorldInfo().IsCollisionEnabled()
        }
    }
}
'use strict',
C3.Plugins.Sprite.Acts = {
    Spawn(t, a, n) {
        if (!t || !a)
            return;
        const [r,l] = this.GetImagePoint(n)
          , e = this._runtime.CreateInstance(t, a, r, l);
        if (!e)
            return;
        if (t.GetPlugin().IsRotatable()) {
            const t = e.GetWorldInfo();
            t.SetAngle(this.GetWorldInfo().GetAngle()),
            t.SetBboxChanged()
        }
        const _ = this._runtime.GetEventSheetManager();
        if (_.BlockFlushingInstances(!0),
        e._TriggerOnCreated(),
        e.IsInContainer())
            for (const t of e.siblings())
                t._TriggerOnCreated();
        _.BlockFlushingInstances(!1);
        const d = this._runtime.GetCurrentAction()
          , u = d.GetSavedDataMap();
        let i = !1;
        if ((!u.has('Spawn_LastExec') || u.get('Spawn_LastExec') < this._runtime.GetExecCount()) && (i = !0,
        u.set('Spawn_LastExec', this._runtime.GetExecCount())),
        t !== this.GetObjectClass()) {
            const a = t.GetCurrentSol();
            a._SetSelectAll(!1);
            const n = a._GetOwnInstances();
            if (i ? (C3.clearArray(n),
            n.push(e)) : n.push(e),
            e.IsInContainer())
                for (const t of e.siblings()) {
                    const e = t.GetObjectClass().GetCurrentSol();
                    i ? e.SetSinglePicked(t) : (e._SetSelectAll(!1),
                    e._PushInstance(t))
                }
        }
    },
    StopAnim() {
        this.SetAnimationPlaying(!1)
    },
    StartAnim(e) {
        this._StartAnim(e)
    },
    SetAnim(e, t) {
        this._SetAnim(e, t)
    },
    SetAnimFrame(e) {
        this._SetAnimFrame(e)
    },
    SetAnimSpeed(e) {
        this._SetAnimSpeed(e)
    },
    SetAnimRepeatToFrame(e) {
        this._SetAnimRepeatToFrame(e)
    },
    SetMirrored(e) {
        const t = this.GetWorldInfo()
          , a = t.GetWidth()
          , n = Math.abs(a) * (0 === e ? -1 : 1);
        a === n || (t.SetWidth(n),
        t.SetBboxChanged())
    },
    SetFlipped(e) {
        const t = this.GetWorldInfo()
          , a = t.GetHeight()
          , n = Math.abs(a) * (0 === e ? -1 : 1);
        a === n || (t.SetHeight(n),
        t.SetBboxChanged())
    },
    SetScale(t) {
        const a = this._currentAnimationFrame
          , n = a.GetImageInfo()
          , r = this.GetWorldInfo()
          , i = 0 > r.GetWidth() ? -1 : 1
          , e = 0 > r.GetHeight() ? -1 : 1
          , l = n.GetWidth() * t * i
          , _ = n.GetHeight() * t * e;
        (r.GetWidth() !== l || r.GetHeight() !== _) && (r.SetSize(l, _),
        r.SetBboxChanged())
    },
    async LoadURL(t, a) {
        const n = this._currentAnimationFrame
          , r = n.GetImageInfo()
          , i = this.GetWorldInfo()
          , e = this._runtime;
        if (r.GetURL() === t)
            return 0 === a && (i.SetSize(r.GetWidth(), r.GetHeight()),
            i.SetBboxChanged()),
            void this.Trigger(C3.Plugins.Sprite.Cnds.OnURLLoaded);
        const l = C3.New(C3.ImageInfo);
        return await l.LoadDynamicAsset(e, t),
        l.IsLoaded() ? void (await l.LoadStaticTexture(e.GetWebGLRenderer(), {
            sampling: this._runtime.GetSampling()
        }),
        r.ReplaceWith(l),
        this._sdkType._UpdateAllCurrentTexture(),
        !this.WasReleased() && 0 === a && (i.SetSize(r.GetWidth(), r.GetHeight()),
        i.SetBboxChanged()),
        e.UpdateRender(),
        !this.WasReleased() && (await this.TriggerAsync(C3.Plugins.Sprite.Cnds.OnURLLoaded))) : void this.Trigger(C3.Plugins.Sprite.Cnds.OnURLFailed)
    },
    SetCollisions(e) {
        this.GetWorldInfo().SetCollisionEnabled(e)
    },
    SetSolidCollisionFilter(e, t) {
        this.GetWorldInfo().SetSolidCollisionFilter(0 === e, t)
    },
    SetEffect(e) {
        this.GetWorldInfo().SetBlendMode(e),
        this._runtime.UpdateRender()
    }
},
'use strict',
C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._currentFrameIndex
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(e) {
        return this.GetImagePoint(e)[0]
    },
    ImagePointY(e) {
        return this.GetImagePoint(e)[1]
    },
    ImagePointCount() {
        return this._currentAnimationFrame.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    }
},
'use strict',
C3.Plugins.TiledBg = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.TiledBg.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(e) {
        return this.GetImageInfo().LoadStaticTexture(e, {
            sampling: this._runtime.GetSampling(),
            isTiled: !0
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
}
,
'use strict';
{
    const t = C3.New(C3.Quad)
      , a = C3.New(C3.Rect)
      , n = C3.New(C3.Quad);
    C3.Plugins.TiledBg.Instance = class extends C3.SDKWorldInstanceBase {
        constructor(e, t) {
            super(e),
            this._imageOffsetX = 0,
            this._imageOffsetY = 0,
            this._imageScaleX = 1,
            this._imageScaleY = 1,
            this._imageAngle = 0,
            this._ownImageInfo = null,
            t && (this.GetWorldInfo().SetVisible(!!t[0]),
            this._imageOffsetX = t[2],
            this._imageOffsetY = t[3],
            this._imageScaleX = t[4],
            this._imageScaleY = t[5],
            this._imageAngle = C3.toRadians(t[6]))
        }
        Release() {
            this._ReleaseOwnImage(),
            super.Release()
        }
        _ReleaseOwnImage() {
            this._ownImageInfo && (this._ownImageInfo.Release(),
            this._ownImageInfo = null)
        }
        Draw(r) {
            var _ = Math.round;
            const e = this.GetCurrentImageInfo()
              , d = e.GetTexture();
            if (!d)
                return;
            const u = this.GetWorldInfo();
            let g = u.GetBoundingQuad();
            r.SetTexture(d);
            const c = e.GetWidth()
              , p = e.GetHeight()
              , h = this._imageOffsetX / c
              , l = this._imageOffsetY / p;
            if (a.set(0, 0, u.GetWidth() / (c * this._imageScaleX), u.GetHeight() / (p * this._imageScaleY)),
            a.offset(-h, -l),
            this._runtime.IsPixelRoundingEnabled()) {
                const e = _(u.GetX()) - u.GetX()
                  , a = _(u.GetY()) - u.GetY();
                t.copy(g),
                t.offset(e, a),
                g = t
            }
            0 === this._imageAngle ? r.Quad3(g, a) : (n.setFromRotatedRect(a, -this._imageAngle),
            r.Quad4(g, n))
        }
        GetCurrentImageInfo() {
            return this._ownImageInfo || this._objectClass.GetImageInfo()
        }
        _SetImageOffsetX(e) {
            this._imageOffsetX === e || (this._imageOffsetX = e,
            this._runtime.UpdateRender())
        }
        _GetImageOffsetX() {
            return this._imageOffsetX
        }
        _SetImageOffsetY(e) {
            this._imageOffsetY === e || (this._imageOffsetY = e,
            this._runtime.UpdateRender())
        }
        _GetImageOffsetY() {
            return this._imageOffsetY
        }
        _SetImageScaleX(e) {
            this._imageScaleX === e || (this._imageScaleX = e,
            this._runtime.UpdateRender())
        }
        _GetImageScaleX() {
            return this._imageScaleX
        }
        _SetImageScaleY(e) {
            this._imageScaleY === e || (this._imageScaleY = e,
            this._runtime.UpdateRender())
        }
        _GetImageScaleY() {
            return this._imageScaleY
        }
        _SetImageAngle(e) {
            this._imageAngle === e || (this._imageAngle = e,
            this._runtime.UpdateRender())
        }
        _GetImageAngle() {
            return this._imageAngle
        }
        GetPropertyValueByIndex(e) {
            return 2 === e ? this._GetImageOffsetX() : 3 === e ? this._GetImageOffsetY() : 4 === e ? this._GetImageScaleX() : 5 === e ? this._GetImageScaleY() : 6 === e ? this._GetImageAngle() : void 0
        }
        SetPropertyValueByIndex(e, t) {
            2 === e ? this._SetImageOffsetX(t) : 3 === e ? this._SetImageOffsetY(t) : 4 === e ? this._SetImageScaleX(t) : 5 === e ? this._SetImageScaleY(t) : 6 === e ? this._SetImageAngle(t) : void 0
        }
        GetScriptInterfaceClass() {
            return ITiledBackgroundInstance
        }
    }
    ;
    const e = new WeakMap;
    self.ITiledBackgroundInstance = class extends IWorldInstance {
        constructor() {
            super(),
            e.set(this, IInstance._GetInitInst().GetSdkInstance())
        }
        set imageOffsetX(t) {
            e.get(this)._SetImageOffsetX(t)
        }
        get imageOffsetX() {
            return e.get(this)._GetImageOffsetX()
        }
        set imageOffsetY(t) {
            e.get(this)._SetImageOffsetY(t)
        }
        get imageOffsetY() {
            return e.get(this)._GetImageOffsetY()
        }
        set imageScaleX(t) {
            e.get(this)._SetImageScaleX(t)
        }
        get imageScaleX() {
            return e.get(this)._GetImageScaleX()
        }
        set imageScaleY(t) {
            e.get(this)._SetImageScaleY(t)
        }
        get imageScaleY() {
            return e.get(this)._GetImageScaleY()
        }
        set imageAngle(t) {
            e.get(this)._SetImageAngle(t)
        }
        get imageAngle() {
            return e.get(this)._GetImageAngle()
        }
        set imageAngleDegrees(t) {
            e.get(this)._SetImageAngle(C3.toRadians(t))
        }
        get imageAngleDegrees() {
            return C3.toDegrees(e.get(this)._GetImageAngle())
        }
    }
}
'use strict',
C3.Plugins.TiledBg.Cnds = {
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    }
},
'use strict',
C3.Plugins.TiledBg.Acts = {
    SetImageOffsetX(e) {
        this._SetImageOffsetX(e)
    },
    SetImageOffsetY(e) {
        this._SetImageOffsetY(e)
    },
    SetImageScaleX(e) {
        this._SetImageScaleX(e / 100)
    },
    SetImageScaleY(e) {
        this._SetImageScaleY(e / 100)
    },
    SetImageAngle(e) {
        this._SetImageAngle(C3.toRadians(e))
    },
    SetEffect(e) {
        this.GetWorldInfo().SetBlendMode(e),
        this._runtime.UpdateRender()
    },
    async LoadURL(e) {
        if (!(this._ownImageInfo && this._ownImageInfo.GetURL() === e)) {
            const t = this._runtime
              , a = C3.New(C3.ImageInfo);
            if (await a.LoadDynamicAsset(t, e),
            !a.IsLoaded())
                return void this.Trigger(C3.Plugins.TiledBg.Cnds.OnURLFailed);
            if (this.WasReleased())
                return a.Release(),
                null;
            const n = await a.LoadStaticTexture(t.GetWebGLRenderer(), {
                sampling: this._runtime.GetSampling(),
                isTiled: !0
            });
            return n ? this.WasReleased() ? void a.Release() : void (this._ReleaseOwnImage(),
            this._ownImageInfo = a,
            t.UpdateRender(),
            await this.TriggerAsync(C3.Plugins.TiledBg.Cnds.OnURLLoaded)) : void 0
        }
    }
},
'use strict',
C3.Plugins.TiledBg.Exps = {
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    ImageOffsetX() {
        return this._imageOffsetX
    },
    ImageOffsetY() {
        return this._imageOffsetY
    },
    ImageScaleX() {
        return 100 * this._imageScaleX
    },
    ImageScaleY() {
        return 100 * this._imageScaleY
    },
    ImageAngle() {
        return C3.toDegrees(this._imageAngle)
    }
},
'use strict',
C3.Plugins.Spritefont2 = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.Spritefont2.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e),
        this._spriteFont = C3.New(SpriteFont)
    }
    Release() {
        super.Release()
    }
    OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(e) {
        return this.GetImageInfo().LoadStaticTexture(e, {
            sampling: this._runtime.GetSampling(),
            isTiled: !0
        })
    }
    ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture()
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    UpdateSettings(t, a, n, r) {
        const i = this.GetImageInfo()
          , e = this._spriteFont;
        e.SetWidth(i.GetWidth()),
        e.SetHeight(i.GetHeight()),
        e.SetCharacterWidth(t),
        e.SetCharacterHeight(a),
        e.SetCharacterSet(n),
        e.SetSpacingData(r),
        e.UpdateCharacterMap()
    }
}
,
'use strict';
{
    const t = ['left', 'center', 'right']
      , a = ['top', 'center', 'bottom']
      , n = C3.New(C3.Quad);
    C3.Plugins.Spritefont2.Instance = class extends C3.SDKWorldInstanceBase {
        constructor(e, t) {
            super(e),
            this._text = '',
            this._enableBBcode = !0,
            this._characterWidth = 16,
            this._characterHeight = 16,
            this._characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#"\'&()[]|`\\/@\xB0+=*$\xA3\u20AC<>';
            let n = '';
            if (this._characterScale = 1,
            this._characterSpacing = 0,
            this._lineHeight = 0,
            this._horizontalAlign = 0,
            this._verticalAlign = 0,
            this._wrapByWord = !0,
            this._spriteFontText = null,
            this._typewriterStartTime = -1,
            this._typewriterEndTime = -1,
            this._typewriterLength = 0,
            t) {
                this._text = t[0],
                this._enableBBcode = t[1],
                this._characterWidth = t[2],
                this._characterHeight = t[3],
                this._characterSet = t[4],
                n = t[5],
                this._characterScale = t[6],
                this._characterSpacing = t[7],
                this._lineHeight = t[8],
                this._horizontalAlign = t[9],
                this._verticalAlign = t[10],
                this._wrapByWord = 0 === t[11];
                const e = this.GetWorldInfo();
                e.SetVisible(t[12])
            }
            this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight, this._characterSet, n),
            this._spriteFontText = C3.New(SpriteFontText, this._sdkType.GetSpriteFont());
            const a = this.GetWorldInfo();
            this._spriteFontText.SetSize(a.GetWidth(), a.GetHeight()),
            this._UpdateSettings()
        }
        Release() {
            this._CancelTypewriter(),
            this._spriteFontText.Release(),
            this._spriteFontText = null,
            super.Release()
        }
        _UpdateSettings() {
            const e = this._spriteFontText;
            e && (e.SetBBCodeEnabled(this._enableBBcode),
            e.SetText(this._text),
            e.SetWordWrapMode(this._wrapByWord ? 'word' : 'character'),
            e.SetHorizontalAlign(t[this._horizontalAlign]),
            e.SetVerticalAlign(a[this._verticalAlign]),
            e.SetScale(this._characterScale),
            e.SetSpacing(this._characterSpacing),
            e.SetLineHeight(this._lineHeight))
        }
        Draw(t) {
            var r = Math.round;
            const a = this._objectClass.GetImageInfo()
              , i = a.GetTexture();
            if (!i)
                return;
            t.SetTexture(i);
            const e = this.GetWorldInfo();
            let l = e.GetBoundingQuad();
            const _ = this._spriteFontText;
            if (this._runtime.IsPixelRoundingEnabled()) {
                const t = r(e.GetX()) - e.GetX()
                  , a = r(e.GetY()) - e.GetY();
                n.copy(l),
                n.offset(t, a),
                l = n
            }
            _.SetSize(e.GetWidth(), e.GetHeight()),
            _.GetSpriteFont().SetTexRect(a.GetTexRect()),
            _.SetColor(e.GetUnpremultipliedColor()),
            _.Draw(t, l.getTlx(), l.getTly(), e.GetAngle())
        }
        SaveToJson() {
            const e = {
                t: this._text,
                ebbc: this._enableBBcode,
                csc: this._characterScale,
                csp: this._characterSpacing,
                lh: this._lineHeight,
                ha: this._horizontalAlign,
                va: this._verticalAlign,
                w: this._wrapByWord,
                cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
                ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
                cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
                sd: this._sdkType.GetSpriteFont().GetSpacingData()
            };
            return -1 !== this._typewriterEndTime && (o.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            }),
            e
        }
        LoadFromJson(e) {
            if (this._CancelTypewriter(),
            this._text = e.t,
            this._enableBBcode = e.ebbc,
            this._characterScale = e.csc,
            this._characterSpacing = e.csp,
            this._lineHeight = e.lh,
            this._horizontalAlign = e.ha,
            this._verticalAlign = e.va,
            this._wrapByWord = e.w,
            e.hasOwnProperty('tw')) {
                const t = e.tw;
                this._typewriterStartTime = t.st,
                this._typewriterEndTime = t.en,
                this._typewriterLength = e.l
            }
            const t = this._sdkType.GetSpriteFont();
            t.SetCharacterWidth(e.cw),
            t.SetCharacterHeight(e.ch),
            t.SetCharacterSet(e.cs),
            t.SetSpacingData(e.sd),
            this._UpdateSettings(),
            -1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this._text : 1 === e ? this._enableBBcode : 2 === e ? this._sdkType.GetSpriteFont().GetCharacterWidth() : 3 === e ? this._sdkType.GetSpriteFont().GetCharacterHeight() : 4 === e ? this._sdkType.GetSpriteFont().GetCharacterSet() : 5 === e ? this._sdkType.GetSpriteFont().GetSpacingData() : 6 === e ? this._characterScale : 7 === e ? this._characterSpacing : 8 === e ? this._lineHeight : 9 === e ? this._horizontalAlign : 10 === e ? this._verticalAlign : 11 === e ? this._wrapByWord ? 1 : 0 : void 0
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
            case 0:
                if (this._text === t)
                    return;
                this._text = t,
                this._UpdateSettings();
                break;
            case 1:
                if (this._enableBBcode === !!t)
                    return;
                this._enableBBcode = !!t,
                this._UpdateSettings();
                break;
            case 2:
                this._sdkType.GetSpriteFont().SetCharacterWidth(t);
                break;
            case 3:
                this._sdkType.GetSpriteFont().SetCharacterHeight(t);
                break;
            case 4:
                this._sdkType.GetSpriteFont().SetCharacterSet(t);
                break;
            case 5:
                this._sdkType.GetSpriteFont().SetSpacingData(t);
                break;
            case 6:
                if (this._characterScale === t)
                    return;
                this._characterScale = t,
                this._UpdateSettings();
                break;
            case 7:
                if (this._characterSpacing === t)
                    return;
                this._characterSpacing = t,
                this._UpdateSettings();
                break;
            case 8:
                if (this._lineHeight === t)
                    return;
                this._lineHeight = t,
                this._UpdateSettings();
                break;
            case 9:
                if (this._horizontalAlign === t)
                    return;
                this._horizontalAlign = t,
                this._UpdateSettings();
                break;
            case 10:
                if (this._verticalAlign === t)
                    return;
                this._verticalAlign = t,
                this._UpdateSettings();
                break;
            case 11:
                if (this._wrapByWord === (0 === t))
                    return;
                this._wrapByWord = 0 === t,
                this._UpdateSettings();
            }
        }
        _SetText(e) {
            this._text === e || (this._text = e,
            this._spriteFontText.SetText(e),
            this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(e, t) {
            this._SetText(e),
            this._typewriterStartTime = this._runtime.GetGameTime(),
            this._typewriterEndTime = this._typewriterStartTime + t,
            this._typewriterLength = C3.BBString.StripAnyTags(e).length,
            this._spriteFontText.SetDrawMaxCharacterCount(0),
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterStartTime = -1,
            this._typewriterEndTime = -1,
            this._typewriterLength = 0,
            this._spriteFontText.SetDrawMaxCharacterCount(-1),
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 === this._typewriterEndTime || (this._CancelTypewriter(),
            this.Trigger(C3.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
            this._runtime.UpdateRender())
        }
        _SetScale(e) {
            this._characterScale === e || (this._characterScale = e,
            this._spriteFontText.SetScale(this._characterScale),
            this._runtime.UpdateRender())
        }
        _GetScale() {
            return this._characterScale
        }
        _SetCharacterSpacing(e) {
            this._characterSpacing === e || (this._characterSpacing = e,
            this._spriteFontText.SetSpacing(this._characterSpacing),
            this._runtime.UpdateRender())
        }
        _GetCharacterSpacing() {
            return this._characterSpacing
        }
        _SetLineHeight(e) {
            this._lineHeight === e || (this._lineHeight = e,
            this._spriteFontText.SetLineHeight(this._lineHeight),
            this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeight
        }
        _SetHAlign(e) {
            this._horizontalAlign === e || (this._horizontalAlign = e,
            this._UpdateSettings(),
            this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(e) {
            this._verticalAlign === e || (this._verticalAlign = e,
            this._UpdateSettings(),
            this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(e) {
            e = !!e,
            this._wrapByWord === e || (this._wrapByWord = e,
            this._UpdateSettings(),
            this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            const e = this._runtime.GetGameTime();
            if (e >= this._typewriterEndTime)
                this._CancelTypewriter(),
                this.Trigger(C3.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished),
                this._runtime.UpdateRender();
            else {
                let t = C3.relerp(this._typewriterStartTime, this._typewriterEndTime, e, 0, this._typewriterLength);
                t = Math.floor(t),
                t !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(t),
                this._runtime.UpdateRender())
            }
        }
        GetDebuggerProperties() {
            return [{
                title: 'plugins.spritefont2.name',
                properties: [{
                    name: 'plugins.spritefont2.properties.text.name',
                    value: this._text,
                    onedit: e=>this._SetText(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return ISpriteFontInstance
        }
    }
    ;
    const r = new WeakMap
      , i = new Map([['left', 0], ['center', 1], ['right', 2]])
      , e = new Map([['top', 0], ['center', 1], ['bottom', 2]])
      , l = new Map([['word', !0], ['character', !1]]);
    self.ISpriteFontInstance = class extends IWorldInstance {
        constructor() {
            super(),
            r.set(this, IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return r.get(this).GetText()
        }
        set text(e) {
            const t = r.get(this);
            t._CancelTypewriter(),
            t._SetText(e)
        }
        typewriterText(e, t) {
            const a = r.get(this);
            a._CancelTypewriter(),
            a._StartTypewriter(e, t)
        }
        typewriterFinish() {
            r.get(this)._FinishTypewriter()
        }
        set characterScale(e) {
            r.get(this)._SetScale(e)
        }
        get characterScale() {
            return r.get(this)._GetScale()
        }
        set characterSpacing(e) {
            r.get(this)._SetCharacterSpacing(e)
        }
        get characterSpacing() {
            return r.get(this)._GetCharacterSpacing()
        }
        set lineHeight(e) {
            r.get(this)._SetLineHeight(e)
        }
        get lineHeight() {
            return r.get(this)._GetLineHeight()
        }
        set horizontalAlign(e) {
            const t = i.get(e);
            if ('undefined' == typeof t)
                throw new Error('invalid mode');
            r.get(this)._SetHAlign(t)
        }
        get horizontalAlign() {
            return t[r.get(this)._GetHAlign()]
        }
        set verticalAlign(t) {
            const a = e.get(t);
            if ('undefined' == typeof a)
                throw new Error('invalid mode');
            r.get(this)._SetVAlign(a)
        }
        get verticalAlign() {
            return a[r.get(this)._GetVAlign()]
        }
        set wordWrapMode(e) {
            const t = l.get(e);
            if ('undefined' == typeof t)
                throw new Error('invalid mode');
            r.get(this)._SetWrapByWord(t)
        }
        get wordWrapMode() {
            return r.get(this)._IsWrapByWord() ? 'word' : 'character'
        }
    }
}
'use strict',
C3.Plugins.Spritefont2.Cnds = {
    CompareText(e, t) {
        return t ? this._text === e : C3.equalsNoCase(this._text, e)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    }
},
'use strict',
C3.Plugins.Spritefont2.Acts = {
    SetText(e) {
        this._CancelTypewriter(),
        'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
        this._SetText(e.toString())
    },
    AppendText(e) {
        this._CancelTypewriter(),
        'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
        e = e.toString(),
        e && this._SetText(this._text + e)
    },
    TypewriterText(e, t) {
        this._CancelTypewriter(),
        'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
        this._StartTypewriter(e.toString(), t)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(e) {
        this._SetScale(e)
    },
    SetCharacterSpacing(e) {
        this._SetCharacterSpacing(e)
    },
    SetLineHeight(e) {
        this._SetLineHeight(e)
    },
    SetCharacterWidth(t, n) {
        let r = !1;
        const i = this._sdkType.GetSpriteFont();
        for (const l of t)
            if (' ' === l)
                i.SetSpaceWidth(n),
                r = !0;
            else {
                const e = i.GetCharacter(l);
                e && (e.SetDisplayWidth(n),
                r = !0)
            }
        r && i.SetCharacterWidthsChanged(),
        this._runtime.UpdateRender()
    },
    SetEffect(e) {
        this.GetWorldInfo().SetBlendMode(e),
        this._runtime.UpdateRender()
    },
    SetHAlign(e) {
        this._SetHAlign(e)
    },
    SetVAlign(e) {
        this._SetVAlign(e)
    },
    SetWrapping(e) {
        this._SetWrapByWord(0 === e)
    }
},
'use strict',
C3.Plugins.Spritefont2.Exps = {
    CharacterWidth(e) {
        const t = this._sdkType.GetSpriteFont().GetCharacter(e);
        return t ? t.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
    },
    CharacterHeight() {
        return this._characterHeight
    },
    CharacterScale() {
        return this._characterScale
    },
    CharacterSpacing() {
        return this._characterSpacing
    },
    LineHeight() {
        return this._lineHeight
    },
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3.BBString.StripAnyTags(this._text) : this._text
    },
    TextWidth() {
        const e = this.GetWorldInfo();
        return this._spriteFontText.SetSize(e.GetWidth(), e.GetHeight()),
        this._spriteFontText.GetTextWidth()
    },
    TextHeight() {
        const e = this.GetWorldInfo();
        return this._spriteFontText.SetSize(e.GetWidth(), e.GetHeight()),
        this._spriteFontText.GetTextHeight()
    }
},
'use strict';
{
    const e = {
        width: 256,
        height: 256,
        characterWidth: 16,
        characterHeight: 16,
        characterSet: ''
    };
    self.SpriteFont = class {
        constructor(t) {
            if (t = Object.assign({}, e, t),
            0 >= t.width || 0 >= t.height || 0 >= t.characterWidth || 0 >= t.characterHeight)
                throw new Error('invalid size');
            this._width = t.width,
            this._height = t.height,
            this._characterWidth = t.characterWidth,
            this._characterHeight = t.characterHeight,
            this._characterSet = t.characterSet,
            this._spacingData = '',
            this._spacingParsed = null,
            this._hasAnyCustomWidths = !1,
            this._spaceWidth = -1,
            this._texRect = new C3.Rect(0,0,1,1),
            this._characterMap = new Map,
            this._mapChanged = !0,
            this._allTexts = new Set
        }
        Release() {
            this._texRect = null,
            this._ReleaseCharacters(),
            this._characterMap = null,
            this._allTexts && this._allTexts.clear(),
            this._allTexts = null
        }
        _ReleaseCharacters() {
            for (let e of this._characterMap.values())
                e.Release();
            this._characterMap.clear()
        }
        _AddSpriteFontText(e) {
            this._allTexts.add(e)
        }
        _RemoveSpriteFontText(e) {
            this._allTexts.delete(e)
        }
        UpdateCharacterMap() {
            var t = Math.floor;
            if (this._mapChanged) {
                this._ReleaseCharacters();
                let a = [...this._characterSet]
                  , n = t(this._width / this._characterWidth)
                  , r = t(this._height / this._characterHeight);
                for (let i = 0, e = a.length; i < e && !(i >= n * r); ++i) {
                    let e = i % n
                      , r = t(i / n)
                      , l = a[i];
                    this._characterMap.set(l, C3.New(SpriteFontCharacter, this, l, e * this._characterWidth, r * this._characterHeight))
                }
                if (this._hasAnyCustomWidths = !1,
                this._spaceWidth = -1,
                Array.isArray(this._spacingParsed))
                    for (let e of this._spacingParsed) {
                        if (!Array.isArray(e))
                            continue;
                        if (2 !== e.length)
                            continue;
                        let t = e[0]
                          , n = e[1];
                        if ('number' == typeof t && isFinite(t) && 'string' == typeof n && t !== this._characterWidth)
                            for (let e of n) {
                                let a = this._characterMap.get(e);
                                a ? (a.SetDisplayWidth(t),
                                this._hasAnyCustomWidths = !0) : ' ' === e && (this._spaceWidth = t,
                                this._hasAnyCustomWidths = !0)
                            }
                    }
                this._mapChanged = !1;
                for (let e of this._allTexts)
                    e._SetWrapChanged()
            }
        }
        SetCharacterWidthsChanged() {
            this._hasAnyCustomWidths = !0;
            for (const e of this._allTexts)
                e._SetWrapChanged()
        }
        GetCharacter(e) {
            return this.UpdateCharacterMap(),
            this._characterMap.get(e) || null
        }
        HasAnyCustomWidths() {
            return this._hasAnyCustomWidths
        }
        SetWidth(e) {
            if (e = Math.floor(e),
            0 >= e)
                throw new Error('invalid size');
            this._width === e || (this._width = e,
            this._mapChanged = !0)
        }
        GetWidth() {
            return this._width
        }
        SetHeight(e) {
            if (e = Math.floor(e),
            0 >= e)
                throw new Error('invalid size');
            this._height === e || (this._height = e,
            this._mapChanged = !0)
        }
        GetHeight() {
            return this._height
        }
        SetTexRect(e) {
            if (!this._texRect.equals(e)) {
                this._texRect.copy(e);
                for (const e of this._characterMap.values())
                    e._UpdateTexRect()
            }
        }
        GetTexRect() {
            return this._texRect
        }
        SetCharacterWidth(e) {
            if (e = Math.floor(e),
            0 >= e)
                throw new Error('invalid size');
            this._characterWidth === e || (this._characterWidth = e,
            this._mapChanged = !0)
        }
        GetCharacterWidth() {
            return this._characterWidth
        }
        SetCharacterHeight(e) {
            if (e = Math.floor(e),
            0 >= e)
                throw new Error('invalid size');
            this._characterHeight === e || (this._characterHeight = e,
            this._mapChanged = !0)
        }
        GetCharacterHeight() {
            return this._characterHeight
        }
        SetCharacterSet(e) {
            this._characterSet === e || (this._characterSet = e,
            this._mapChanged = !0)
        }
        GetCharacterSet() {
            return this._characterSet
        }
        SetSpacingData(e) {
            if (this._spacingData !== e && (this._spacingData = e,
            this._mapChanged = !0,
            this._spacingParsed = null,
            this._spacingData.length))
                try {
                    this._spacingParsed = JSON.parse(this._spacingData)
                } catch (e) {
                    this._spacingParsed = null
                }
        }
        GetSpacingData() {
            return this._spacingData
        }
        SetSpaceWidth(e) {
            0 > e && (e = -1),
            this._spaceWidth === e || (this._spaceWidth = e,
            0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
        }
        GetSpaceWidth() {
            return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
        }
    }
}
'use strict',
self.SpriteFontCharacter = class {
    constructor(t, a, n, r) {
        let i = t.GetCharacterWidth()
          , e = t.GetCharacterHeight();
        this._spriteFont = t,
        this._char = a,
        this._pxRect = new C3.Rect(n,r,n + i,r + e),
        this._texRect = new C3.Rect,
        this._displayWidth = -1,
        this._UpdateTexRect()
    }
    Release() {
        this._spriteFont = null,
        this._pxRect = null,
        this._texRect = null
    }
    _UpdateTexRect() {
        let e = this._spriteFont.GetWidth()
          , t = this._spriteFont.GetHeight();
        this._texRect.copy(this._pxRect),
        this._texRect.divide(e, t),
        this._texRect.lerpInto(this._spriteFont.GetTexRect())
    }
    GetSpriteFont() {
        return this._spriteFont
    }
    GetChar() {
        return this._char
    }
    GetTexRect() {
        return this._texRect
    }
    SetDisplayWidth(e) {
        this._displayWidth = e
    }
    GetDisplayWidth() {
        return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
    }
}
,
'use strict';
{
    const _ = new C3.Rect
      , a = new C3.Quad
      , S = new C3.Color
      , t = new Set(['left', 'center', 'right'])
      , n = new Set(['top', 'center', 'bottom'])
      , e = new Set(['word', 'character']);
    self.SpriteFontText = class {
        constructor(e) {
            this._spriteFont = e,
            this._cssWidth = 0,
            this._cssHeight = 0,
            this._text = '',
            this._isBBcodeEnabled = !1,
            this._bbString = null,
            this._wrappedText = C3.New(C3.WordWrap),
            this._wrapMode = 'word',
            this._wrapChanged = !1,
            this._horizontalAlign = 'left',
            this._verticalAlign = 'top',
            this._scale = 1,
            this._spacing = 0,
            this._lineHeight = 0,
            this._color = C3.New(C3.Color),
            this._drawMaxCharCount = -1,
            this._drawCharCount = 0,
            this._measureTextCallback = (e,t)=>this._MeasureText(e, t),
            this._spriteFont._AddSpriteFontText(this)
        }
        Release() {
            this._spriteFont._RemoveSpriteFontText(this),
            this._color = null,
            this._measureTextCallback = null,
            this._wrappedText.Clear(),
            this._wrappedText = null,
            this._spriteFont = null,
            this._bbString = null
        }
        _MeasureText(t, a) {
            const n = this._GetStyleTag(a, 'scale')
              , r = n ? parseFloat(n.param) : this._scale
              , _ = this._GetStyleTag(a, 'scalex')
              , u = (_ ? parseFloat(_.param) : 1) * r
              , e = this._GetStyleTag(a, 'scaley')
              , d = (e ? parseFloat(e.param) : 1) * r
              , g = this._spriteFont.GetCharacterHeight() * d + this._lineHeight
              , i = this.GetSpriteFont()
              , m = i.GetCharacterWidth() * u
              , p = this.GetSpacing();
            if (i.HasAnyCustomWidths()) {
                let n = 0
                  , r = 0;
                for (const l of t) {
                    let t = m;
                    const a = i.GetCharacter(l);
                    a ? t = a.GetDisplayWidth() * u : ' ' === l && (t = i.GetSpaceWidth() * u),
                    r += t,
                    ++n
                }
                return {
                    width: r + n * p,
                    height: g
                }
            } else {
                const e = [...t].length
                  , a = Math.max(e, 0);
                return {
                    width: m * e + a * p,
                    height: g
                }
            }
        }
        _SetWrapChanged() {
            this._wrapChanged = !0,
            this._wrappedText.Clear()
        }
        SetSize(e, t) {
            0 >= e || 0 >= t || this._cssWidth === e && this._cssHeight === t || (this._cssWidth !== e && this._SetWrapChanged(),
            this._cssWidth = e,
            this._cssHeight = t)
        }
        SetDrawMaxCharacterCount(e) {
            this._drawMaxCharCount = Math.floor(e)
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(e, t) {
            for (let a = e.length - 1; 0 <= a; --a) {
                const n = e[a];
                if (n.tag === t)
                    return n
            }
            return null
        }
        _HasStyleTag(e, t) {
            return !!this._GetStyleTag(e, t)
        }
        _MaybeWrapText() {
            if (this._wrapChanged) {
                this._isBBcodeEnabled && (!this._bbString || this._bbString.toString() !== this._text) && (this._bbString = new C3.BBString(this._text,{
                    noEscape: !0
                }));
                const e = -this.GetSpacing();
                this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, e),
                this._wrapChanged = !1
            }
        }
        Draw(t, a, n, r) {
            var l = Math.floor;
            this._MaybeWrapText(),
            this._drawCharCount = 0;
            let _ = 0;
            const u = this._lineHeight
              , c = C3.cloneArray(this._wrappedText.GetLines())
              , g = Math.sin(r)
              , m = Math.cos(r)
              , e = c.reduce((e,t)=>e + t.height, 0) - u;
            'center' === this._verticalAlign ? _ = Math.max(l(this._cssHeight / 2 - e / 2), 0) : 'bottom' === this._verticalAlign && (_ = l(this._cssHeight - e));
            for (let l = 0, e = c.length; l < e; ++l) {
                const e = c[l]
                  , r = e.height;
                if (0 < l && _ > this._cssHeight - (r - u))
                    break;
                0 <= _ && this._DrawLine(t, e, a, n, _, g, m),
                _ += r
            }
        }
        _DrawLine(t, a, n, r, l, e, _) {
            var d = Math.floor
              , u = Math.max;
            const i = a.height;
            let c = 0;
            'center' === this._horizontalAlign ? c = u(d((this._cssWidth - a.width) / 2), 0) : 'right' === this._horizontalAlign && (c = u(d(this._cssWidth - a.width), 0));
            for (const d of a.fragments)
                this._DrawFragment(t, d, n, r, c, l, e, _, i),
                c += d.width
        }
        _DrawFragment(G, t, d, f, g, b, T, I, c) {
            let e = t.text
              , l = t.width;
            const P = t.styles;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                this._drawCharCount + e.length > this._drawMaxCharCount && (e = e.substr(0, this._drawMaxCharCount - this._drawCharCount),
                l = this._MeasureText(e, P).width),
                this._drawCharCount += e.length
            }
            const R = this._GetStyleTag(P, 'background');
            if (!(C3.IsStringAllWhitespace(e) && !R || this._HasStyleTag(P, 'hide'))) {
                const n = this._GetStyleTag(P, 'scale')
                  , i = n ? parseFloat(n.param) : this._scale
                  , m = this._GetStyleTag(P, 'scalex')
                  , r = (m ? parseFloat(m.param) : 1) * i
                  , p = this._GetStyleTag(P, 'scaley')
                  , t = (p ? parseFloat(p.param) : 1) * i
                  , u = this._spriteFont.GetCharacterHeight() * t
                  , h = this._lineHeight;
                b += c - h - u;
                const v = this._GetStyleTag(P, 'offsetx');
                g += v ? parseFloat(v.param) : 0;
                const x = this._GetStyleTag(P, 'offsety');
                b += x ? parseFloat(x.param) : 0,
                R && (G.SetColorFillMode(),
                S.parseString(R.param),
                S.setA(1),
                G.SetColor(S),
                _.set(g, b, g + l, b + u),
                _.getRight() > this._cssWidth && _.setRight(this._cssWidth),
                a.setFromRotatedRectPrecalc(_, T, I),
                a.offset(d, f),
                G.Quad(a),
                G.SetTextureFillMode());
                const y = this._GetStyleTag(P, 'color');
                y ? (S.parseString(y.param),
                S.setA(this._color.getA())) : S.copy(this._color);
                const E = this._GetStyleTag(P, 'opacity');
                E && S.setA(S.getA() * parseFloat(E.param) / 100),
                S.premultiply(),
                G.SetColor(S);
                const A = this._spriteFont.GetCharacterWidth() * r
                  , D = Math.abs(this.GetSpacing());
                for (const t of e) {
                    const n = this._spriteFont.GetCharacter(t);
                    if (n) {
                        const e = n.GetDisplayWidth() * r;
                        if (g + e > this._cssWidth + D + 1e-5)
                            return;
                        _.set(g, b, g + A, b + u),
                        a.setFromRotatedRectPrecalc(_, T, I),
                        a.offset(d, f),
                        G.Quad3(a, n.GetTexRect()),
                        g += e + this._spacing
                    } else
                        g += this._spriteFont.GetSpaceWidth() * r + this._spacing
                }
            }
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        SetBBCodeEnabled(e) {
            e = !!e,
            this._isBBcodeEnabled === e || (this._isBBcodeEnabled = e,
            this._SetWrapChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetText(e) {
            this._text === e || (this._text = e,
            this._SetWrapChanged())
        }
        SetWordWrapMode(t) {
            if (!e.has(t))
                throw new Error('invalid word wrap mode');
            this._wrapMode === t || (this._wrapMode = t,
            this._SetWrapChanged())
        }
        SetHorizontalAlign(e) {
            if (!t.has(e))
                throw new Error('invalid alignment');
            this._horizontalAlign = e
        }
        SetVerticalAlign(e) {
            if (!n.has(e))
                throw new Error('invalid alignment');
            this._verticalAlign = e
        }
        SetScale(e) {
            this._scale === e || (this._scale = e,
            this._SetWrapChanged())
        }
        GetScale() {
            return this._scale
        }
        SetSpacing(e) {
            this._spacing === e || (this._spacing = e,
            this._SetWrapChanged())
        }
        GetSpacing() {
            return this._spacing
        }
        SetLineHeight(e) {
            this._lineHeight = e,
            this._SetWrapChanged()
        }
        GetLineHeight() {
            return this._lineHeight
        }
        SetOpacity(e) {
            e = C3.clamp(e, 0, 1),
            this._color.a = e
        }
        SetColor(e) {
            this._color.equals(e) || this._color.copy(e)
        }
        GetColor() {
            return this._color
        }
        GetTextWidth() {
            return this._MaybeWrapText(),
            this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            const e = this._spriteFont.GetCharacterHeight() * this._scale
              , t = this._lineHeight;
            return this._wrappedText.GetLineCount() * (e + t) - t
        }
    }
}
'use strict',
C3.Plugins.LocalStorage = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.LocalStorage.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Plugins.LocalStorage.Instance = class extends C3.SDKInstanceBase {
    constructor(e) {
        super(e),
        this._currentKey = '',
        this._lastValue = '',
        this._keyNamesList = [],
        this._errorMessage = '',
        this._pendingGets = 0,
        this._pendingSets = 0,
        this._storage = this._runtime._GetProjectStorage(),
        this._debugCache = new Map,
        this._isLoadingDebugCache = !1
    }
    Release() {
        super.Release()
    }
    async _TriggerStorageError(e) {
        this._errorMessage = this._GetErrorString(e),
        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnError)
    }
    _GetErrorString(e) {
        return e ? 'string' == typeof e ? e : 'string' == typeof e.message ? e.message : 'string' == typeof e.name ? e.name : 'string' == typeof e.data ? e.data : 'unknown error' : 'unknown error'
    }
    GetDebuggerProperties() {
        return this._isLoadingDebugCache || this._DebugCacheStorage(),
        [{
            title: 'plugins.localstorage.name',
            properties: [...this._debugCache.entries()].map(e=>({
                name: '$' + e[0],
                value: e[1],
                onedit: t=>this._storage.setItem(e[0], t)
            }))
        }]
    }
    async _DebugCacheStorage() {
        this._isLoadingDebugCache = !0;
        try {
            const e = await this._storage.keys();
            e.sort((e,t)=>{
                const a = e.toLowerCase()
                  , n = t.toLowerCase();
                return a < n ? -1 : n < a ? 1 : 0
            }
            );
            const t = await Promise.all(e.map(e=>this._storage.getItem(e)));
            this._debugCache.clear();
            for (let a = 0, n = e.length; a < n; ++a)
                this._debugCache.set(e[a], t[a])
        } catch (e) {
            console.warn('[C3 debugger] Error displaying local storage: ', e)
        } finally {
            this._isLoadingDebugCache = !1
        }
    }
}
,
'use strict',
C3.Plugins.LocalStorage.Cnds = {
    OnItemSet(e) {
        return this._currentKey === e
    },
    OnAnyItemSet() {
        return !0
    },
    OnItemGet(e) {
        return this._currentKey === e
    },
    OnAnyItemGet() {
        return !0
    },
    OnItemRemoved(e) {
        return this._currentKey === e
    },
    OnAnyItemRemoved() {
        return !0
    },
    OnCleared() {
        return !0
    },
    OnAllKeyNamesLoaded() {
        return !0
    },
    OnError() {
        return !0
    },
    OnItemExists(e) {
        return this._currentKey === e
    },
    OnItemMissing(e) {
        return this._currentKey === e
    },
    CompareKey(e, t) {
        return C3.compare(this._currentKey, e, t)
    },
    CompareValue(e, t) {
        return C3.compare(this._lastValue, e, t)
    },
    IsProcessingSets() {
        return 0 < this._pendingSets
    },
    IsProcessingGets() {
        return 0 < this._pendingGets
    },
    OnAllSetsComplete() {
        return !0
    },
    OnAllGetsComplete() {
        return !0
    }
},
'use strict';
{
    function e(e) {
        return 'string' == typeof e || 'number' == typeof e
    }
    C3.Plugins.LocalStorage.Acts = {
        async SetItem(e, t) {
            this._pendingSets++;
            try {
                const a = await this._storage.setItem(e, t);
                await this.ScheduleTriggers(async()=>{
                    this._currentKey = e,
                    this._lastValue = a,
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemSet),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemSet)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            } finally {
                this._pendingSets--,
                0 === this._pendingSets && (await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllSetsComplete))
            }
        },
        async SetBinaryItem(e, t) {
            if (t) {
                const a = t.GetFirstPicked(this._inst);
                if (a) {
                    const t = a.GetSdkInstance();
                    if (t) {
                        const a = t.GetArrayBufferReadOnly();
                        this._pendingSets++;
                        try {
                            await this._storage.setItem(e, a),
                            await this.ScheduleTriggers(async()=>{
                                this._currentKey = e,
                                this._lastValue = '',
                                await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemSet),
                                await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemSet)
                            }
                            )
                        } catch (e) {
                            await this._TriggerStorageError(e)
                        } finally {
                            this._pendingSets--,
                            0 === this._pendingSets && (await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllSetsComplete))
                        }
                    }
                }
            }
        },
        async GetItem(t) {
            this._pendingGets++;
            try {
                const a = await this._storage.getItem(t);
                await this.ScheduleTriggers(async()=>{
                    this._currentKey = t,
                    this._lastValue = e(a) ? a : '',
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemGet),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemGet)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            } finally {
                this._pendingGets--,
                0 === this._pendingGets && (await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllGetsComplete))
            }
        },
        async GetBinaryItem(e, t) {
            if (!t)
                return;
            const a = t.GetFirstPicked(this._inst);
            if (!a)
                return;
            const n = a.GetSdkInstance();
            this._pendingGets++;
            try {
                let t = await this._storage.getItem(e);
                t = t instanceof ArrayBuffer ? t : new ArrayBuffer(0),
                await this.ScheduleTriggers(async()=>{
                    this._lastValue = '',
                    this._currentKey = e,
                    n.SetArrayBufferTransfer(t),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemGet),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemGet)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            } finally {
                this._pendingGets--,
                0 === this._pendingGets && (await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllGetsComplete))
            }
        },
        async CheckItemExists(t) {
            try {
                const a = await this._storage.getItem(t);
                await this.ScheduleTriggers(async()=>{
                    this._currentKey = t,
                    'undefined' == typeof a || null === a ? (this._lastValue = '',
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = e(a) ? a : '',
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemExists))
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            }
        },
        async RemoveItem(e) {
            try {
                await this._storage.removeItem(e),
                await this.ScheduleTriggers(async()=>{
                    this._currentKey = e,
                    this._lastValue = '',
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemRemoved),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemRemoved)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            }
        },
        async ClearStorage() {
            try {
                await this._storage.clear(),
                await this.ScheduleTriggers(async()=>{
                    this._currentKey = '',
                    this._lastValue = '',
                    C3.clearArray(this._keyNamesList),
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnCleared)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            }
        },
        async GetAllKeyNames() {
            try {
                const e = await this._storage.keys();
                await this.ScheduleTriggers(async()=>{
                    this._keyNamesList = e,
                    await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)
                }
                )
            } catch (e) {
                await this._TriggerStorageError(e)
            }
        }
    }
}
'use strict',
C3.Plugins.LocalStorage.Exps = {
    ItemValue() {
        return this._lastValue
    },
    Key() {
        return this._currentKey
    },
    KeyCount() {
        return this._keyNamesList.length
    },
    KeyAt(e) {
        return e = Math.floor(e),
        0 > e || e >= this._keyNamesList.length ? '' : this._keyNamesList[e]
    },
    ErrorMessage() {
        return this._errorMessage
    }
},
'use strict',
C3.Plugins.Mouse = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict';
{
    function e() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    C3.Plugins.Mouse.Type = class extends C3.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return IMouseObjectType
        }
    }
    ;
    let t = null;
    self.IMouseObjectType = class extends IObjectClass {
        constructor(e) {
            super(e),
            t = e,
            e.GetRuntime()._GetCommonScriptInterfaces().mouse = this
        }
        getMouseX(t) {
            return e().GetMousePositionForLayer(t)[0]
        }
        getMouseY(t) {
            return e().GetMousePositionForLayer(t)[1]
        }
        getMousePosition(t) {
            return e().GetMousePositionForLayer(t)
        }
        isMouseButtonDown(t) {
            return e().IsMouseButtonDown(t)
        }
    }
}
'use strict',
C3.Plugins.Mouse.Instance = class extends C3.SDKInstanceBase {
    constructor(e) {
        super(e, 'mouse'),
        this._buttonMap = [!1, !1, !1],
        this._mouseXcanvas = 0,
        this._mouseYcanvas = 0,
        this._triggerButton = 0,
        this._triggerType = 0,
        this._triggerDir = 0;
        const t = this.GetRuntime().Dispatcher();
        this._disposables = new C3.CompositeDisposable(C3.Disposable.From(t, 'pointermove', e=>this._OnPointerMove(e.data)),C3.Disposable.From(t, 'pointerdown', e=>this._OnPointerDown(e.data)),C3.Disposable.From(t, 'pointerup', e=>this._OnPointerUp(e.data)),C3.Disposable.From(t, 'dblclick', e=>this._OnDoubleClick(e.data)),C3.Disposable.From(t, 'wheel', e=>this._OnMouseWheel(e.data)),C3.Disposable.From(t, 'window-blur', ()=>this._OnWindowBlur()))
    }
    Release() {
        super.Release()
    }
    _OnPointerDown(e) {
        'mouse' !== e.pointerType || (this._mouseXcanvas = e.clientX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = e.clientY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(e.lastButtons, e.buttons))
    }
    _OnPointerMove(e) {
        'mouse' !== e.pointerType || (this._mouseXcanvas = e.clientX - this._runtime.GetCanvasClientX(),
        this._mouseYcanvas = e.clientY - this._runtime.GetCanvasClientY(),
        this._CheckButtonChanges(e.lastButtons, e.buttons))
    }
    _OnPointerUp(e) {
        'mouse' !== e.pointerType || this._CheckButtonChanges(e.lastButtons, e.buttons)
    }
    _CheckButtonChanges(e, t) {
        this._CheckButtonChange(e, t, 1, 0),
        this._CheckButtonChange(e, t, 4, 1),
        this._CheckButtonChange(e, t, 2, 2)
    }
    _CheckButtonChange(e, t, a, n) {
        !(e & a) && t & a ? this._OnMouseDown(n) : e & a && !(t & a) && this._OnMouseUp(n)
    }
    _OnMouseDown(e) {
        this._buttonMap[e] = !0,
        this.Trigger(C3.Plugins.Mouse.Cnds.OnAnyClick),
        this._triggerButton = e,
        this._triggerType = 0,
        this.Trigger(C3.Plugins.Mouse.Cnds.OnClick),
        this.Trigger(C3.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseUp(e) {
        this._buttonMap[e] && (this._buttonMap[e] = !1,
        this._triggerButton = e,
        this.Trigger(C3.Plugins.Mouse.Cnds.OnRelease))
    }
    _OnDoubleClick(e) {
        this._triggerButton = e.button,
        this._triggerType = 1,
        this.Trigger(C3.Plugins.Mouse.Cnds.OnClick),
        this.Trigger(C3.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseWheel(e) {
        this._triggerDir = 0 > e.deltaY ? 1 : 0,
        this.Trigger(C3.Plugins.Mouse.Cnds.OnWheel)
    }
    _OnWindowBlur() {
        for (let e = 0, t = this._buttonMap.length; e < t; ++e) {
            if (!this._buttonMap[e])
                return;
            this._buttonMap[e] = !1,
            this._triggerButton = e,
            this.Trigger(C3.Plugins.Mouse.Cnds.OnRelease)
        }
    }
    GetMousePositionForLayer(t) {
        const n = this._runtime.GetMainRunningLayout()
          , r = this._mouseXcanvas
          , i = this._mouseYcanvas;
        if ('undefined' == typeof t) {
            const e = n.GetLayerByIndex(0);
            return e.CanvasCssToLayer_DefaultTransform(r, i)
        } else {
            const a = n.GetLayer(t);
            return a ? a.CanvasCssToLayer(r, i) : [0, 0]
        }
    }
    IsMouseButtonDown(e) {
        return e = Math.floor(e),
        !!this._buttonMap[e]
    }
    _IsMouseOverCanvas() {
        return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
        return [{
            title: 'plugins.mouse.name',
            properties: [{
                name: 'plugins.mouse.debugger.absolute-position',
                value: this._mouseXcanvas + ',' + this._mouseYcanvas
            }, {
                name: 'plugins.mouse.debugger.left-button',
                value: this._buttonMap[0]
            }, {
                name: 'plugins.mouse.debugger.middle-button',
                value: this._buttonMap[1]
            }, {
                name: 'plugins.mouse.debugger.right-button',
                value: this._buttonMap[2]
            }]
        }, {
            title: 'plugins.mouse.debugger.position-on-each-layer',
            properties: this._runtime.GetMainRunningLayout().GetLayers().map(e=>({
                name: '$' + e.GetName(),
                value: e.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(', ')
            }))
        }]
    }
}
,
'use strict',
C3.Plugins.Mouse.Cnds = {
    OnClick(e, t) {
        return this._triggerButton === e && this._triggerType === t
    },
    OnAnyClick() {
        return !0
    },
    IsButtonDown(e) {
        return this._buttonMap[e]
    },
    OnRelease(e) {
        return this._triggerButton === e
    },
    IsOverObject(t) {
        if (!this._IsMouseOverCanvas())
            return !1;
        const a = this._runtime.GetCurrentCondition()
          , n = a.IsInverted()
          , r = this._mouseXcanvas
          , i = this._mouseYcanvas;
        return C3.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, r, i, n), n)
    },
    OnObjectClicked(t, a, n) {
        if (t !== this._triggerButton || a !== this._triggerType)
            return !1;
        if (!this._IsMouseOverCanvas())
            return !1;
        const r = this._mouseXcanvas
          , i = this._mouseYcanvas;
        return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(n, r, i, !1)
    },
    OnWheel(e) {
        return this._triggerDir === e
    }
},
'use strict';
{
    let t = null;
    const e = ['auto', 'pointer', 'text', 'crosshair', 'move', 'help', 'wait', 'none'];
    C3.Plugins.Mouse.Acts = {
        SetCursor(a) {
            const n = e[a];
            t === n || (t = n,
            this.PostToDOM('cursor', n))
        },
        SetCursorSprite(a) {
            if (C3.Platform.IsMobile || !a)
                return;
            const n = a.GetFirstPicked();
            if (!n)
                return;
            const r = n.GetWorldInfo()
              , i = n.GetCurrentImageInfo();
            r && i && t !== i && (t = i,
            i.ExtractImageToCanvas().then(e=>C3.CanvasToBlob(e)).then(e=>{
                var t = Math.round;
                const a = URL.createObjectURL(e)
                  , n = `url(${a}) ${t(r.GetOriginX() * i.GetWidth())} ${t(r.GetOriginY() * i.GetHeight())}, auto`;
                this.PostToDOM('cursor', ''),
                this.PostToDOM('cursor', n)
            }
            ))
        }
    }
}
'use strict',
C3.Plugins.Mouse.Exps = {
    X(e) {
        return this.GetMousePositionForLayer(e)[0]
    },
    Y(e) {
        return this.GetMousePositionForLayer(e)[1]
    },
    AbsoluteX() {
        return this._mouseXcanvas
    },
    AbsoluteY() {
        return this._mouseYcanvas
    }
},
'use strict',
C3.Plugins.progressbar = class extends C3.SDKDOMPluginBase {
    constructor(e) {
        super(e, 'progress-bar'),
        this.AddElementMessageHandler('click', (e,t)=>e._OnClick(t))
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.progressbar.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict';
{
    const e = 0;
    C3.Plugins.progressbar.Instance = class extends C3.SDKDOMInstanceBase {
        constructor(t, a) {
            super(t, 'progress-bar'),
            this._value = 0,
            this._max = 100,
            this._title = '',
            this._id = '',
            a && (this._value = a[e],
            this._max = a[1],
            this._title = a[2],
            this.GetWorldInfo().SetVisible(a[3]),
            this._id = a[4]),
            this.CreateElement({
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                value: this._value,
                max: this._max,
                title: this._title
            }
        }
        async _OnClick() {
            await this.TriggerAsync(C3.Plugins.progressbar.Cnds.OnClicked)
        }
        Draw() {}
        SaveToJson() {
            return {
                v: this._value,
                m: this._max,
                t: this._title,
                id: this._id
            }
        }
        LoadFromJson(e) {
            this._value = e.v,
            this._max = e.m,
            this._title = e.t,
            this._id = e.id,
            this.UpdateElementState()
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this._value : 1 === e ? this._max : 2 === e ? this._title : 4 === e ? this._id : void 0
        }
        SetPropertyValueByIndex(t, a) {
            switch (t) {
            case e:
                if (this._value === a)
                    return;
                this._value = a,
                this.UpdateElementState();
                break;
            case 1:
                if (this._max === a)
                    return;
                this._max = a,
                this.UpdateElementState();
                break;
            case 2:
                if (this._title === a)
                    return;
                this._title = a,
                this.UpdateElementState();
                break;
            case 4:
                if (this._id === a)
                    return;
                this._id = a,
                this.UpdateElementState();
            }
        }
        GetDebuggerProperties() {
            const e = C3.Plugins.progressbar.Acts;
            return [{
                title: 'plugins.progressbar.name',
                properties: [{
                    name: 'plugins.progressbar.properties.value.name',
                    value: this._value,
                    onedit: t=>this.CallAction(e.SetProgress, t)
                }, {
                    name: 'plugins.progressbar.properties.maximum.name',
                    value: this._max,
                    onedit: t=>this.CallAction(e.SetMaximum, t)
                }]
            }]
        }
    }
}
'use strict',
C3.Plugins.progressbar.Cnds = {
    OnClicked() {
        return !0
    },
    CompareProgress(e, t) {
        return C3.compare(this._value, e, t)
    }
},
'use strict',
C3.Plugins.progressbar.Acts = {
    SetTooltip(e) {
        this._title === e || (this._title = e,
        this.UpdateElementState())
    },
    SetVisible(e) {
        const t = this.GetWorldInfo();
        e = 0 !== e,
        t.IsVisible() === e || t.SetVisible(e)
    },
    SetCSSStyle(e, t) {
        this.SetElementCSSStyle(e, t)
    },
    SetProgress(e) {
        this._value === e || (this._value = e,
        this.UpdateElementState())
    },
    SetMaximum(e) {
        this._max === e || (this._max = e,
        this.UpdateElementState())
    },
    SetIndeterminate() {
        this._max = 0,
        this._value = 0,
        this.UpdateElementState()
    }
},
'use strict',
C3.Plugins.progressbar.Exps = {
    Progress() {
        return this._value
    },
    Maximum() {
        return this._max
    }
},
'use strict',
C3.Plugins.Text = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.Text.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
    LoadTextures() {}
    ReleaseTextures() {}
}
,
'use strict';
{
    const t = [0, 0, 0]
      , n = ['left', 'center', 'right']
      , r = ['top', 'center', 'bottom']
      , _ = new C3.Rect
      , u = new C3.Quad;
    C3.Plugins.Text.Instance = class extends C3.SDKWorldInstanceBase {
        constructor(e, t) {
            if (super(e),
            this._text = '',
            this._enableBBcode = !0,
            this._faceName = 'Arial',
            this._ptSize = 12,
            this._lineHeightOffset = 0,
            this._isBold = !1,
            this._isItalic = !1,
            this._color = C3.New(C3.Color),
            this._horizontalAlign = 0,
            this._verticalAlign = 0,
            this._wrapByWord = !0,
            this._typewriterStartTime = -1,
            this._typewriterEndTime = -1,
            this._typewriterLength = 0,
            this._webglText = C3.New(C3.Gfx.WebGLText, this._runtime.GetWebGLRenderer(), {
                timeout: 5
            }),
            this._webglText.ontextureupdate = ()=>this._runtime.UpdateRender(),
            this._webglText.SetIsAsync(!1),
            t) {
                this._text = t[0],
                this._enableBBcode = !!t[1],
                this._faceName = t[2],
                this._ptSize = t[3],
                this._lineHeightOffset = t[4],
                this._isBold = !!t[5],
                this._isItalic = !!t[6],
                this._horizontalAlign = t[8],
                this._verticalAlign = t[9],
                this._wrapByWord = 0 === t[10];
                const e = t[7];
                this._color.setRgb(e[0], e[1], e[2]),
                this.GetWorldInfo().SetVisible(t[11])
            }
            this._UpdateTextSettings()
        }
        Release() {
            this._CancelTypewriter(),
            this._webglText.Release(),
            this._webglText = null,
            super.Release()
        }
        _UpdateTextSettings() {
            const e = this._webglText;
            e.SetText(this._text),
            e.SetBBCodeEnabled(this._enableBBcode),
            e.SetFontName(this._faceName),
            e.SetFontSize(this._ptSize),
            e.SetLineHeight(this._lineHeightOffset),
            e.SetBold(this._isBold),
            e.SetItalic(this._isItalic),
            e.SetColor(this._color),
            e.SetHorizontalAlignment(n[this._horizontalAlign]),
            e.SetVerticalAlignment(r[this._verticalAlign]),
            e.SetWordWrapMode(this._wrapByWord ? 'word' : 'character')
        }
        _UpdateTextSize() {
            const e = this.GetWorldInfo()
              , t = e.GetLayer()
              , a = t.GetRenderScale() * t.Get2DScaleFactorToZ(e.GetTotalZElevation());
            this._webglText.SetSize(e.GetWidth(), e.GetHeight(), a)
        }
        Draw(e) {
            var t = Math.round;
            const a = this.GetWorldInfo();
            this._UpdateTextSize();
            const r = this._webglText.GetTexture();
            if (!r)
                return;
            const d = a.GetLayer();
            let g = a.GetBoundingQuad();
            if (0 === a.GetAngle() && 0 === a.GetLayer().GetAngle() && 0 === a.GetTotalZElevation()) {
                const [a,c] = d.LayerToDrawSurface(g.getTlx(), g.getTly())
                  , [i,p] = d.LayerToDrawSurface(g.getBrx(), g.getBry())
                  , h = a - t(a)
                  , l = c - t(c);
                _.set(a, c, i, p),
                _.offset(-h, -l),
                u.setFromRect(_);
                const [m,n] = e.GetRenderTargetSize(e.GetRenderTarget());
                this._runtime.GetCanvasManager().SetDeviceTransform(e, m, n),
                e.SetTexture(r),
                e.Quad3(u, this._webglText.GetTexRect()),
                d._SetTransform(e)
            } else {
                let a = 0
                  , n = 0;
                this._runtime.IsPixelRoundingEnabled() && (a = g.getTlx() - t(g.getTlx()),
                n = g.getTly() - t(g.getTly())),
                (0 != a || 0 != n) && (u.copy(g),
                u.offset(-a, -n),
                g = u),
                e.SetTexture(r),
                e.Quad3(g, this._webglText.GetTexRect())
            }
        }
        SaveToJson() {
            const e = {
                t: this._text,
                c: this._color.toJSON(),
                fn: this._faceName,
                ps: this._ptSize
            };
            return this._enableBBcode && (e.bbc = this._enableBBcode),
            0 !== this._horizontalAlign && (e.ha = this._horizontalAlign),
            0 !== this._verticalAlign && (e.va = this._verticalAlign),
            this._wrapByWord || (e.wr = this._wrapByWord),
            0 !== this._lineHeightOffset && (e.lho = this._lineHeightOffset),
            this._isBold && (e.b = this._isBold),
            this._isItalic && (e.i = this._isItalic),
            -1 !== this._typewriterEndTime && (e.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            }),
            e
        }
        LoadFromJson(e) {
            if (this._CancelTypewriter(),
            this._text = e.t,
            this._color.setFromJSON(e.c),
            this._faceName = e.fn,
            this._ptSize = e.ps,
            this._enableBBcode = !!e.hasOwnProperty('bbc') && e.bbc,
            this._horizontalAlign = e.hasOwnProperty('ha') ? e.ha : 0,
            this._verticalAlign = e.hasOwnProperty('va') ? e.va : 0,
            this._wrapByWord = !e.hasOwnProperty('wr') || e.wr,
            this._lineHeightOffset = e.hasOwnProperty('lho') ? e.lho : 0,
            this._isBold = !!e.hasOwnProperty('b') && e.b,
            this._isItalic = !!e.hasOwnProperty('i') && e.i,
            e.hasOwnProperty('tw')) {
                const t = e.tw;
                this._typewriterStartTime = t.st,
                this._typewriterEndTime = t.en,
                this._typewriterLength = t.l
            }
            this._UpdateTextSettings(),
            -1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this._text : 1 === e ? this._enableBBcode : 2 === e ? this._faceName : 3 === e ? this._ptSize : 4 === e ? this._lineHeightOffset : 5 === e ? this._isBold : 6 === e ? this._isItalic : 7 === e ? (t[0] = this._color.getR(),
            t[1] = this._color.getG(),
            t[2] = this._color.getB(),
            t) : 8 === e ? this._horizontalAlign : 9 === e ? this._verticalAlign : 10 === e ? this._wrapByWord ? 1 : 0 : void 0
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
            case 0:
                if (this._text === t)
                    return;
                this._text = t,
                this._UpdateTextSettings();
                break;
            case 1:
                if (this._enableBBcode === !!t)
                    return;
                this._enableBBcode = !!t,
                this._UpdateTextSettings();
                break;
            case 2:
                if (this._faceName === t)
                    return;
                this._faceName = t,
                this._UpdateTextSettings();
                break;
            case 3:
                if (this._ptSize === t)
                    return;
                this._ptSize = t,
                this._UpdateTextSettings();
                break;
            case 4:
                if (this._lineHeightOffset === t)
                    return;
                this._lineHeightOffset = t,
                this._UpdateTextSettings();
                break;
            case 5:
                if (this._isBold === !!t)
                    return;
                this._isBold = !!t,
                this._UpdateTextSettings();
                break;
            case 6:
                if (this._isItalic === !!t)
                    return;
                this._isItalic = !!t,
                this._UpdateTextSettings();
                break;
            case 7:
                const a = this._color
                  , n = t;
                if (a.getR() === n[0] && a.getG() === n[1] && a.getB() === n[2])
                    return;
                this._color.setRgb(n[0], n[1], n[2]),
                this._UpdateTextSettings();
                break;
            case 8:
                if (this._horizontalAlign === t)
                    return;
                this._horizontalAlign = t,
                this._UpdateTextSettings();
                break;
            case 9:
                if (this._verticalAlign === t)
                    return;
                this._verticalAlign = t,
                this._UpdateTextSettings();
                break;
            case 10:
                if (this._wrapByWord === (0 === t))
                    return;
                this._wrapByWord = 0 === t,
                this._UpdateTextSettings();
            }
        }
        SetPropertyColorOffsetValueByIndex(t, a, n, r) {
            (0 !== a || 0 !== n || 0 !== r) && (7 === t ? (this._color.addRgb(a, n, r),
            this._UpdateTextSettings()) : void 0)
        }
        _SetText(e) {
            this._text === e || (this._text = e,
            this._webglText.SetText(e),
            this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(e, t) {
            this._SetText(e),
            this._typewriterStartTime = this._runtime.GetGameTime(),
            this._typewriterEndTime = this._typewriterStartTime + t,
            this._typewriterLength = C3.BBString.StripAnyTags(e).length,
            this._webglText.SetDrawMaxCharacterCount(0),
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterStartTime = -1,
            this._typewriterEndTime = -1,
            this._typewriterLength = 0,
            this._webglText.SetDrawMaxCharacterCount(-1),
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 === this._typewriterEndTime || (this._CancelTypewriter(),
            this.Trigger(C3.Plugins.Text.Cnds.OnTypewriterTextFinished),
            this._runtime.UpdateRender())
        }
        _SetFontFace(e) {
            this._faceName === e || (this._faceName = e,
            this._webglText.SetFontName(e),
            this._runtime.UpdateRender())
        }
        _GetFontFace() {
            return this._faceName
        }
        _SetBold(e) {
            e = !!e,
            this._isBold === e || (this._isBold = e,
            this._webglText.SetBold(e),
            this._runtime.UpdateRender())
        }
        _IsBold() {
            return this._isBold
        }
        _SetItalic(e) {
            e = !!e,
            this._isItalic === e || (this._isItalic = e,
            this._webglText.SetItalic(e),
            this._runtime.UpdateRender())
        }
        _IsItalic() {
            return this._isItalic
        }
        _SetFontSize(e) {
            this._ptSize === e || (this._ptSize = e,
            this._webglText.SetFontSize(this._ptSize),
            this._runtime.UpdateRender())
        }
        _GetFontSize() {
            return this._ptSize
        }
        _SetLineHeight(e) {
            this._lineHeightOffset === e || (this._lineHeightOffset = e,
            this._UpdateTextSettings(),
            this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeightOffset
        }
        _SetHAlign(e) {
            this._horizontalAlign === e || (this._horizontalAlign = e,
            this._UpdateTextSettings(),
            this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(e) {
            this._verticalAlign === e || (this._verticalAlign = e,
            this._UpdateTextSettings(),
            this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(e) {
            e = !!e,
            this._wrapByWord === e || (this._wrapByWord = e,
            this._UpdateTextSettings(),
            this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            const e = this._runtime.GetGameTime();
            if (e >= this._typewriterEndTime)
                this._CancelTypewriter(),
                this.Trigger(C3.Plugins.Text.Cnds.OnTypewriterTextFinished),
                this._runtime.UpdateRender();
            else {
                let t = C3.relerp(this._typewriterStartTime, this._typewriterEndTime, e, 0, this._typewriterLength);
                t = Math.floor(t),
                t !== this._webglText.GetDrawMaxCharacterCount() && (this._webglText.SetDrawMaxCharacterCount(t),
                this._runtime.UpdateRender())
            }
        }
        GetDebuggerProperties() {
            return [{
                title: 'plugins.text.name',
                properties: [{
                    name: 'plugins.text.properties.text.name',
                    value: this._text,
                    onedit: e=>this._SetText(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return ITextInstance
        }
    }
    ;
    const e = new WeakMap
      , l = new Map([['left', 0], ['center', 1], ['right', 2]])
      , d = new Map([['top', 0], ['center', 1], ['bottom', 2]])
      , c = new Map([['word', !0], ['character', !1]]);
    self.ITextInstance = class extends IWorldInstance {
        constructor() {
            super(),
            e.set(this, IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return e.get(this).GetText()
        }
        set text(t) {
            const a = e.get(this);
            a._CancelTypewriter(),
            a._SetText(t)
        }
        typewriterText(t, a) {
            const n = e.get(this);
            n._CancelTypewriter(),
            n._StartTypewriter(t, a)
        }
        typewriterFinish() {
            e.get(this)._FinishTypewriter()
        }
        set fontFace(t) {
            e.get(this)._SetFontFace(t)
        }
        get fontFace() {
            return e.get(this)._GetFontFace()
        }
        set isBold(t) {
            e.get(this)._SetBold(t)
        }
        get isBold() {
            return e.get(this)._IsBold()
        }
        set isItalic(t) {
            e.get(this)._SetItalic(t)
        }
        get isItalic() {
            return e.get(this)._IsItalic()
        }
        set sizePt(t) {
            e.get(this)._SetFontSize(t)
        }
        get sizePt() {
            return e.get(this)._GetFontSize()
        }
        set lineHeight(t) {
            e.get(this)._SetLineHeight(t)
        }
        get lineHeight() {
            return e.get(this)._GetLineHeight()
        }
        set horizontalAlign(t) {
            const a = l.get(t);
            if ('undefined' == typeof a)
                throw new Error('invalid mode');
            e.get(this)._SetHAlign(a)
        }
        get horizontalAlign() {
            return n[e.get(this)._GetHAlign()]
        }
        set verticalAlign(t) {
            const a = d.get(t);
            if ('undefined' == typeof a)
                throw new Error('invalid mode');
            e.get(this)._SetVAlign(a)
        }
        get verticalAlign() {
            return r[e.get(this)._GetVAlign()]
        }
        set wordWrapMode(t) {
            const a = c.get(t);
            if ('undefined' == typeof a)
                throw new Error('invalid mode');
            e.get(this)._SetWrapByWord(a)
        }
        get wordWrapMode() {
            return e.get(this)._IsWrapByWord() ? 'word' : 'character'
        }
    }
}
'use strict',
C3.Plugins.Text.Cnds = {
    CompareText(e, t) {
        return t ? this._text === e : C3.equalsNoCase(this._text, e)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    }
},
'use strict';
{
    const e = C3.New(C3.Color);
    C3.Plugins.Text.Acts = {
        SetText(e) {
            this._CancelTypewriter(),
            'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
            this._SetText(e.toString())
        },
        AppendText(e) {
            this._CancelTypewriter(),
            'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
            e = e.toString(),
            e && this._SetText(this._text + e)
        },
        TypewriterText(e, t) {
            this._CancelTypewriter(),
            'number' == typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10),
            this._StartTypewriter(e.toString(), t)
        },
        SetFontFace(e, t) {
            let a = !1
              , n = !1;
            1 === t ? a = !0 : 2 === t ? n = !0 : 3 === t ? (a = !0,
            n = !0) : void 0,
            e === this._faceName && a === this._isBold && n === this._isItalic || (this._SetFontFace(e),
            this._SetBold(a),
            this._SetItalic(n))
        },
        SetFontSize(e) {
            this._SetFontSize(e)
        },
        SetFontColor(t) {
            e.setFromRgbValue(t),
            e.clamp(),
            this._color.equalsIgnoringAlpha(e) || (this._color.copyRgb(e),
            this._webglText.SetColor(this._color),
            this._runtime.UpdateRender())
        },
        SetWebFont() {
            console.warn('[Text] \'Set web font\' action is deprecated and no longer has any effect')
        },
        SetEffect(e) {
            this.GetWorldInfo().SetBlendMode(e),
            this._runtime.UpdateRender()
        },
        TypewriterFinish() {
            this._FinishTypewriter()
        },
        SetLineHeight(e) {
            this._SetLineHeight(e)
        },
        SetHAlign(e) {
            this._SetHAlign(e)
        },
        SetVAlign(e) {
            this._SetVAlign(e)
        },
        SetWrapping(e) {
            this._SetWrapByWord(0 === e)
        }
    }
}
'use strict',
C3.Plugins.Text.Exps = {
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3.BBString.StripAnyTags(this._text) : this._text
    },
    FaceName() {
        return this._faceName
    },
    FaceSize() {
        return this._ptSize
    },
    TextWidth() {
        return this._UpdateTextSize(),
        this._webglText.GetTextWidth()
    },
    TextHeight() {
        return this._UpdateTextSize(),
        this._webglText.GetTextHeight()
    },
    LineHeight() {
        return this._lineHeightOffset
    }
},
'use strict',
C3.Plugins.Touch = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict';
{
    function e() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    C3.Plugins.Touch.Type = class extends C3.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return ITouchObjectType
        }
    }
    ;
    let t = null;
    self.ITouchObjectType = class extends IObjectClass {
        constructor(e) {
            super(e),
            t = e,
            e.GetRuntime()._GetCommonScriptInterfaces().touch = this
        }
        requestPermission(t) {
            const a = e();
            if ('orientation' === t)
                return a._RequestPermission(0);
            if ('motion' === t)
                return a._RequestPermission(1);
            throw new Error('invalid type')
        }
    }
}
'use strict',
C3.Plugins.Touch.Instance = class extends C3.SDKInstanceBase {
    constructor(e, t) {
        super(e, 'touch'),
        this._touches = new Map,
        this._useMouseInput = !1,
        this._isMouseDown = !1,
        this._orientAlpha = 0,
        this._orientBeta = 0,
        this._orientGamma = 0,
        this._accX = 0,
        this._accY = 0,
        this._accZ = 0,
        this._accWithGX = 0,
        this._accWithGY = 0,
        this._accWithGZ = 0,
        this._triggerIndex = 0,
        this._triggerId = 0,
        this._triggerPermission = 0,
        this._curTouchX = 0,
        this._curTouchY = 0,
        this._getTouchIndex = 0,
        this._permissionPromises = [],
        t && (this._useMouseInput = t[0]),
        this.AddDOMMessageHandler('permission-result', e=>this._OnPermissionResult(e));
        const a = this.GetRuntime().Dispatcher();
        this._disposables = new C3.CompositeDisposable(C3.Disposable.From(a, 'pointerdown', e=>this._OnPointerDown(e.data)),C3.Disposable.From(a, 'pointermove', e=>this._OnPointerMove(e.data)),C3.Disposable.From(a, 'pointerup', e=>this._OnPointerUp(e.data, !1)),C3.Disposable.From(a, 'pointercancel', e=>this._OnPointerUp(e.data, !0)),C3.Disposable.From(a, 'deviceorientation', e=>this._OnDeviceOrientation(e.data)),C3.Disposable.From(a, 'devicemotion', e=>this._OnDeviceMotion(e.data)),C3.Disposable.From(a, 'tick2', ()=>this._OnTick2()))
    }
    Release() {
        this._touches.clear(),
        super.Release()
    }
    _OnPointerDown(t) {
        if ('mouse' === t.pointerType)
            if (this._useMouseInput)
                this._isMouseDown = !0;
            else
                return;
        const a = t.pointerId;
        if (!this._touches.has(a)) {
            const n = t.clientX - this._runtime.GetCanvasClientX()
              , r = t.clientY - this._runtime.GetCanvasClientY()
              , i = t.timeStamp
              , e = this._touches.size;
            this._triggerIndex = e,
            this._triggerId = a;
            const l = C3.New(C3.Plugins.Touch.TouchInfo);
            l.Init(i, n, r, a, e),
            this._touches.set(a, l),
            this.Trigger(C3.Plugins.Touch.Cnds.OnNthTouchStart),
            this.Trigger(C3.Plugins.Touch.Cnds.OnTouchStart),
            this._curTouchX = n,
            this._curTouchY = r,
            this.Trigger(C3.Plugins.Touch.Cnds.OnTouchObject);
        }
    }
    _OnPointerMove(t) {
        if ('mouse' !== t.pointerType || this._isMouseDown) {
            const a = this._touches.get(t.pointerId);
            if (a) {
                const n = t.timeStamp;
                if (!(2 > n - a.GetTime())) {
                    const r = t.clientX - this._runtime.GetCanvasClientX()
                      , i = t.clientY - this._runtime.GetCanvasClientY();
                    a.Update(n, r, i, t.width, t.height, t.pressure)
                }
            }
        }
    }
    _OnPointerUp(t, a) {
        if ('mouse' === t.pointerType)
            if (this._isMouseDown)
                this._isMouseDown = !1;
            else
                return;
        const n = t.timeStamp
          , r = t.pointerId
          , i = this._touches.get(r);
        if (i) {
            if (this._triggerIndex = i.GetStartIndex(),
            this._triggerId = i.GetId(), 
            this.Trigger(C3.Plugins.Touch.Cnds.OnNthTouchEnd), 
            this.Trigger(C3.Plugins.Touch.Cnds.OnTouchEnd), 
            !a) {
                const e = i.ShouldTriggerTap(n);
				'single-tap' === e ? (
					this.Trigger(C3.Plugins.Touch.Cnds.OnTapGesture),
					this._curTouchX = i.GetX(),
					this._curTouchY = i.GetY(),
					this.Trigger(C3.Plugins.Touch.Cnds.OnTapGestureObject)
				) : 'double-tap' === e && (
					this.Trigger(C3.Plugins.Touch.Cnds.OnDoubleTapGesture),
					this._curTouchX = i.GetX(),
					this._curTouchY = i.GetY(),
					this.Trigger(C3.Plugins.Touch.Cnds.OnDoubleTapGestureObject)
				)
            }
            i.Release(),
            this._touches.delete(r);
        }
    }
    _RequestPermission(e) {
        return this._PostToDOMMaybeSync('request-permission', {
            type: e
        }),
        new Promise((t,a)=>{
            this._permissionPromises.push({
                type: e,
                resolve: t,
                reject: a
            })
        }
        )
    }
    _OnPermissionResult(e) {
        const t = e.result
          , n = e.type;
        this._triggerPermission = n;
        const a = this._permissionPromises.filter(e=>e.type === n);
        for (const n of a)
            n.resolve(t ? 'granted' : 'denied');
        this._permissionPromises = this._permissionPromises.filter(e=>e.type !== n),
        t ? (this.Trigger(C3.Plugins.Touch.Cnds.OnPermissionGranted),
        0 === n ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(C3.Plugins.Touch.Cnds.OnPermissionDenied)
    }
    _OnDeviceOrientation(e) {
        this._orientAlpha = e.alpha,
        this._orientBeta = e.beta,
        this._orientGamma = e.gamma
    }
    _OnDeviceMotion(e) {
        const t = e.acceleration;
        t && (this._accX = t.x,
        this._accY = t.y,
        this._accZ = t.z);
        const a = e.accelerationIncludingGravity;
        a && (this._accWithGX = a.x,
        this._accWithGY = a.y,
        this._accWithGZ = a.z)
    }
    _OnTick2() {
        const e = performance.now();
        let t = 0;
        for (const a of this._touches.values())
            a.GetTime() <= e - 50 && a._SetLastTime(e),
            a.ShouldTriggerHold(e) && (this._triggerIndex = a.GetStartIndex(),
            this._triggerId = a.GetId(),
            this._getTouchIndex = t,
            this.Trigger(C3.Plugins.Touch.Cnds.OnHoldGesture),
            this._curTouchX = a.GetX(),
            this._curTouchY = a.GetY(),
            this.Trigger(C3.Plugins.Touch.Cnds.OnHoldGestureObject),
            this._getTouchIndex = 0),
            ++t
    }
    _GetTouchByIndex(e) {
        e = Math.floor(e);
        for (const t of this._touches.values()) {
            if (0 === e)
                return t;
            --e
        }
        return null
    }
    _IsClientPosOnCanvas(e, t) {
        return 0 <= e && 0 <= t && e < this._runtime.GetCanvasCssWidth() && t < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
        return [{
            title: 'plugins.touch.debugger.touches',
            properties: [...this._touches.values()].map(e=>({
                name: '$' + e.GetId(),
                value: e.GetX() + ', ' + e.GetY()
            }))
        }]
    }
}
,
'use strict';
{
    const e = [];
    C3.Plugins.Touch.Cnds = {
        OnTouchStart() {
            return !0
        },
        OnTouchEnd() {
            return !0
        },
        IsInTouch() {
            return 0 < this._touches.size
        },
        OnTouchObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        IsTouchingObject(t) {
            if (!t)
                return !1;
            const a = t.GetCurrentSol()
              , n = a.GetInstances();
            for (const a of n) {
                const t = a.GetWorldInfo()
                  , n = t.GetLayer();
                for (const r of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(r.GetX(), r.GetY()))
                        continue;
                    const [i,l] = n.CanvasCssToLayer(r.GetX(), r.GetY(), t.GetTotalZElevation());
                    if (t.ContainsPoint(i, l)) {
                        e.push(a);
                        break
                    }
                }
            }
            return !!e.length && (a.SetArrayPicked(e),
            t.ApplySolToContainer(),
            C3.clearArray(e),
            !0)
        },
        CompareTouchSpeed(e, t, a) {
            const n = this._GetTouchByIndex(e);
            return !!n && C3.compare(n.GetSpeed(), t, a)
        },
        OrientationSupported() {
            return !0
        },
        MotionSupported() {
            return !0
        },
        CompareOrientation(e, t, n) {
            this._runtime.RequestDeviceOrientationEvent();
            let r = 0;
            return r = 0 === e ? this._orientAlpha : 1 === e ? this._orientBeta : this._orientGamma,
            C3.compare(r, t, n)
        },
        CompareAcceleration(e, t, a) {
            this._runtime.RequestDeviceMotionEvent();
            let n = 0;
            return n = 0 === e ? this._accWithGX : 1 === e ? this._accWithGY : 2 === e ? this._accWithGZ : 3 === e ? this._accX : 4 === e ? this._accY : this._accZ,
            C3.compare(n, t, a)
        },
        OnNthTouchStart(e) {
            return e = Math.floor(e),
            e === this._triggerIndex
        },
        OnNthTouchEnd(e) {
            return e = Math.floor(e),
            e === this._triggerIndex
        },
        HasNthTouch(e) {
            return e = Math.floor(e),
            this._touches.size >= e + 1
        },
        OnHoldGesture() {
            return !0
        },
        OnTapGesture() {
            return !0
        },
        OnDoubleTapGesture() {
            return !0
        },
        OnHoldGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnTapGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnDoubleTapGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnPermissionGranted(e) {
            return this._triggerPermission === e
        },
        OnPermissionDenied(e) {
            return this._triggerPermission === e
        }
    }
}
'use strict',
C3.Plugins.Touch.Acts = {
    RequestPermission(e) {
        this._RequestPermission(e)
    }
},
'use strict',
C3.Plugins.Touch.Exps = {
    TouchCount() {
        return this._touches.size
    },
    X(e) {
        const t = this._GetTouchByIndex(this._getTouchIndex);
        return t ? t.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, !0) : 0
    },
    Y(e) {
        const t = this._GetTouchByIndex(this._getTouchIndex);
        return t ? t.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, !1) : 0
    },
    XAt(e, t) {
        const a = this._GetTouchByIndex(e);
        return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !0) : 0
    },
    YAt(e, t) {
        const a = this._GetTouchByIndex(e);
        return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !1) : 0
    },
    XForID(e, t) {
        const a = this._touches.get(e);
        return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !0) : 0
    },
    YForID(e, t) {
        const a = this._touches.get(e);
        return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !1) : 0
    },
    AbsoluteX() {
        const e = this._GetTouchByIndex(0);
        return e ? e.GetX() : 0
    },
    AbsoluteY() {
        const e = this._GetTouchByIndex(0);
        return e ? e.GetY() : 0
    },
    AbsoluteXAt(e) {
        const t = this._GetTouchByIndex(e);
        return t ? t.GetX() : 0
    },
    AbsoluteYAt(e) {
        const t = this._GetTouchByIndex(e);
        return t ? t.GetY() : 0
    },
    AbsoluteXForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetX() : 0
    },
    AbsoluteYForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetY() : 0
    },
    SpeedAt(e) {
        const t = this._GetTouchByIndex(e);
        return t ? t.GetSpeed() : 0
    },
    SpeedForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetSpeed() : 0
    },
    AngleAt(e) {
        const t = this._GetTouchByIndex(e);
        return t ? C3.toDegrees(t.GetAngle()) : 0
    },
    AngleForID(e) {
        const t = this._touches.get(e);
        return t ? C3.toDegrees(t.GetAngle()) : 0
    },
    Alpha() {
        return this._runtime.RequestDeviceOrientationEvent(),
        this._orientAlpha
    },
    Beta() {
        return this._runtime.RequestDeviceOrientationEvent(),
        this._orientBeta
    },
    Gamma() {
        return this._runtime.RequestDeviceOrientationEvent(),
        this._orientGamma
    },
    AccelerationXWithG() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accWithGX
    },
    AccelerationYWithG() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accWithGY
    },
    AccelerationZWithG() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accWithGZ
    },
    AccelerationX() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accX
    },
    AccelerationY() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accY
    },
    AccelerationZ() {
        return this._runtime.RequestDeviceMotionEvent(),
        this._accZ
    },
    TouchIndex() {
        return this._triggerIndex
    },
    TouchID() {
        return this._triggerId
    },
    WidthForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetWidth() : 0
    },
    HeightForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetHeight() : 0
    },
    PressureForID(e) {
        const t = this._touches.get(e);
        return t ? t.GetPressure() : 0
    }
},
'use strict';
{
    const t = 15;
    let a = -1e3
      , n = -1e3
      , r = -1e4;
    C3.Plugins.Touch.TouchInfo = class extends C3.DefendedBase {
        constructor() {
            super(),
            this._pointerId = 0,
            this._startIndex = 0,
            this._startTime = 0,
            this._time = 0,
            this._lastTime = 0,
            this._startX = 0,
            this._startY = 0,
            this._x = 0,
            this._y = 0,
            this._lastX = 0,
            this._lastY = 0,
            this._width = 0,
            this._height = 0,
            this._pressure = 0,
            this._hasTriggeredHold = !1,
            this._isTooFarForHold = !1
        }
        Release() {}
        Init(t, a, n, r, i) {
            this._pointerId = r,
            this._startIndex = i,
            this._time = t,
            this._lastTime = t,
            this._startTime = t,
            this._startX = a,
            this._startY = n,
            this._x = a,
            this._y = n,
            this._lastX = a,
            this._lastY = n
        }
        Update(a, n, r, i, e, l) {
            this._lastTime = this._time,
            this._time = a,
            this._lastX = this._x,
            this._lastY = this._y,
            this._x = n,
            this._y = r,
            this._width = i,
            this._height = e,
            this._pressure = l,
            !this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) >= t && (this._isTooFarForHold = !0)
        }
        GetId() {
            return this._pointerId
        }
        GetStartIndex() {
            return this._startIndex
        }
        GetTime() {
            return this._time
        }
        _SetLastTime(e) {
            this._lastTime = e
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSpeed() {
            const e = C3.distanceTo(this._x, this._y, this._lastX, this._lastY)
              , t = (this._time - this._lastTime) / 1e3;
            return 0 < t ? e / t : 0
        }
        GetAngle() {
            return C3.angleTo(this._lastX, this._lastY, this._x, this._y)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetPressure() {
            return this._pressure
        }
        ShouldTriggerHold(e) {
            return !this._hasTriggeredHold && !!(500 <= e - this._startTime && !this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) < t) && (this._hasTriggeredHold = !0,
            !0)
        }
        ShouldTriggerTap(i) {
            return this._hasTriggeredHold ? '' : 
				333 >= i - this._startTime && !this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) < t ? 
					666 >= i - r && 25 > C3.distanceTo(a, n, this._x, this._y) ? (
						a = -1e3,
						n = -1e3,
						r = -1e4,
						'double-tap'
						) : (
						a = this._x,
						n = this._y,
						r = i,
						'single-tap'
					) : ''
        }
        GetPositionForLayer(e, t, a) {
            if ('undefined' == typeof t) {
                const t = e.GetLayerByIndex(0);
                return t.CanvasCssToLayer_DefaultTransform(this._x, this._y)[a ? 0 : 1]
            } else {
                const n = e.GetLayer(t);
                return n ? n.CanvasCssToLayer(this._x, this._y)[a ? 0 : 1] : 0
            }
        }
    }
}
'use strict',
C3.Plugins.Audio = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict';
{
    function e() {
        if (self.C3Audio_DOMInterface)
            return self.C3Audio_DOMInterface;
        throw new Error('audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode')
    }
    C3.Plugins.Audio.Type = class extends C3.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return IAudioObjectType
        }
    }
    ,
    self.IAudioObjectType = class extends IObjectClass {
        constructor(e) {
            super(e)
        }
        get audioContext() {
            return e().GetAudioContext()
        }
        get destinationNode() {
            return e().GetDestinationNode()
        }
    }
}
{
    const t = ['interactive', 'balanced', 'playback'];
    C3.Plugins.Audio.Instance = class extends C3.SDKInstanceBase {
        constructor(a, n) {
            super(a, 'audio'),
            this._nextPlayTime = 0,
            this._triggerTag = '',
            this._timeScaleMode = 0,
            this._saveLoadMode = 0,
            this._playInBackground = !1,
            this._panningModel = 1,
            this._distanceModel = 1,
            this._listenerX = this._runtime.GetViewportWidth() / 2,
            this._listenerY = this._runtime.GetViewportHeight() / 2,
            this._listenerZ = -600,
            this._referenceDistance = 600,
            this._maxDistance = 1e4,
            this._rolloffFactor = 1,
            this._listenerInst = null,
            this._loadListenerUid = -1,
            this._masterVolume = 1,
            this._isSilent = !1,
            this._sampleRate = 0,
            this._effectCount = new Map,
            this._preloadTotal = 0,
            this._preloadCount = 0;
            let r = 'interactive';
            n && (this._timeScaleMode = n[0],
            this._saveLoadMode = n[1],
            this._playInBackground = n[2],
            r = t[n[3]],
            this._panningModel = n[4],
            this._distanceModel = n[5],
            this._listenerZ = -n[6],
            this._referenceDistance = n[7],
            this._maxDistance = n[8],
            this._rolloffFactor = n[9]),
            this._lastAIState = [],
            this._lastFxState = [],
            this._lastAnalysersData = [],
            this.AddDOMMessageHandlers([['state', e=>this._OnUpdateState(e)], ['fxstate', e=>this._OnUpdateFxState(e)], ['trigger', e=>this._OnTrigger(e)]]);
            const i = this.GetRuntime().Dispatcher();
            this._disposables = new C3.CompositeDisposable(C3.Disposable.From(i, 'instancedestroy', e=>this._OnInstanceDestroyed(e.instance)),C3.Disposable.From(i, 'afterload', ()=>this._OnAfterLoad()),C3.Disposable.From(i, 'suspend', ()=>this._OnSuspend()),C3.Disposable.From(i, 'resume', ()=>this._OnResume())),
            this._runtime.AddLoadPromise(this.PostToDOMAsync('create-audio-context', {
                preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(e=>({
                    originalUrl: e.originalUrl,
                    url: e.url,
                    type: e.type,
                    fileSize: e.fileSize
                })),
                isiOSCordova: this._runtime.IsiOSCordova(),
                timeScaleMode: this._timeScaleMode,
                latencyHint: r,
                panningModel: this._panningModel,
                distanceModel: this._distanceModel,
                refDistance: this._referenceDistance,
                maxDistance: this._maxDistance,
                rolloffFactor: this._rolloffFactor,
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ]
            }).then(e=>{
                this._sampleRate = e.sampleRate
            }
            )),
            this._StartTicking()
        }
        Release() {
            this._listenerInst = null,
            super.Release()
        }
        _OnInstanceDestroyed(e) {
            this._listenerInst === e && (this._listenerInst = null)
        }
        DbToLinearNoCap(e) {
            return Math.pow(10, e / 20)
        }
        DbToLinear(e) {
            const t = this.DbToLinearNoCap(e);
            return isFinite(t) ? Math.max(Math.min(t, 1), 0) : 0
        }
        LinearToDbNoCap(e) {
            return 20 * (Math.log(e) / 2.302585092994046)
        }
        LinearToDb(e) {
            return this.LinearToDbNoCap(Math.max(Math.min(e, 1), 0))
        }
        _OnSuspend() {
            this._playInBackground || this.PostToDOM('set-suspended', {
                isSuspended: !0
            })
        }
        _OnResume() {
            this._playInBackground || this.PostToDOM('set-suspended', {
                isSuspended: !1
            })
        }
        _OnUpdateState(e) {
            const t = e.tickCount
              , a = this._lastAIState.filter(e=>e.hasOwnProperty('placeholder') && (e.placeholder > t || -1 === e.placeholder));
            this._lastAIState = e.audioInstances,
            this._lastAnalysersData = e.analysers,
            0 < a.length && C3.appendArray(this._lastAIState, a)
        }
        _OnUpdateFxState(e) {
            this._lastFxState = e.fxstate
        }
        _GetFirstAudioStateByTag(e) {
            for (const t of this._lastAIState)
                if (C3.equalsNoCase(t.tag, e))
                    return t;
            return null
        }
        _IsTagPlaying(e) {
            return this._lastAIState.some(t=>C3.equalsNoCase(e, t.tag) && t.isPlaying)
        }
        _MaybeMarkAsPlaying(t, a, n, r) {
            if (this._IsTagPlaying(t))
                return null;
            const i = {
                tag: t,
                duration: 0,
                volume: r,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: '',
                bufferUrl: '',
                bufferType: '',
                isMusic: a,
                isLooping: n,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            return this._lastAIState.push(i),
            i
        }
        async _OnTrigger(e) {
            const t = e.type;
            this._triggerTag = e.tag;
            const n = e.aiid;
            if ('ended' === t) {
                for (const e of this._lastAIState)
                    if (e.aiid === n) {
                        e.isPlaying = !1;
                        break
                    }
                await this.TriggerAsync(C3.Plugins.Audio.Cnds.OnEnded)
            } else
                'fade-ended' === t && (await this.TriggerAsync(C3.Plugins.Audio.Cnds.OnFadeEnded))
        }
        Tick() {
            const e = {
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                instPans: this.GetInstancePans(),
                tickCount: this._runtime.GetTickCountNoSave()
            };
            if (this._listenerInst) {
                const t = this._listenerInst.GetWorldInfo();
                this._listenerX = t.GetX(),
                this._listenerY = t.GetY(),
                e.listenerPos = [this._listenerX, this._listenerY, this._listenerZ]
            }
            this.PostToDOM('tick', e)
        }
        rotatePtAround(t, n, r, l, a) {
            if (0 === r)
                return [t, n];
            const e = Math.sin(r)
              , _ = Math.cos(r);
            t -= l,
            n -= a;
            const d = t * e
              , u = n * e
              , i = t * _
              , g = n * _;
            return t = i - u,
            n = g + d,
            t += l,
            n += a,
            [t, n]
        }
        GetInstancePans() {
            return this._lastAIState.filter(e=>-1 !== e.uid).map(e=>this._runtime.GetInstanceByUID(e.uid)).filter(e=>e).map(t=>{
                const a = t.GetWorldInfo()
                  , n = a.GetLayer().GetAngle()
                  , [r,i] = this.rotatePtAround(a.GetX(), a.GetY(), -n, this._listenerX, this._listenerY);
                return {
                    uid: t.GetUID(),
                    x: r,
                    y: i,
                    angle: a.GetAngle() - n
                }
            }
            )
        }
        GetAnalyserData(e, t) {
            for (const a of this._lastAnalysersData)
                if (a.index === t && C3.equalsNoCase(a.tag, e))
                    return a;
            return null
        }
        _IncrementEffectCount(e) {
            this._effectCount.set(e, (this._effectCount.get(e) || 0) + 1)
        }
        _ShouldSave(e) {
            return !e.hasOwnProperty('placeholder') && 3 !== this._saveLoadMode && !(e.isMusic && 1 === this._saveLoadMode) && !!(e.isMusic || 2 !== this._saveLoadMode)
        }
        SaveToJson() {
            return {
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                listenerZ: this._listenerZ,
                listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
                playing: this._lastAIState.filter(e=>this._ShouldSave(e)),
                effects: this._lastFxState,
                analysers: this._lastAnalysersData
            }
        }
        LoadFromJson(e) {
            this._isSilent = e.isSilent,
            this._masterVolume = e.masterVolume,
            this._listenerZ = e.listenerZ,
            this._listenerInst = null,
            this._loadListenerUid = e.listenerUid,
            this._lastAIState = e.playing,
            this._lastFxState = e.effects,
            this._lastAnalysersData = e.analysers
        }
        _OnAfterLoad() {
            if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid),
            this._loadListenerUid = -1,
            this._listenerInst)) {
                const e = this._listenerInst.GetWorldInfo();
                this._listenerX = e.GetX(),
                this._listenerY = e.GetY()
            }
            for (const e of this._lastAIState) {
                const t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e.bufferOriginalUrl);
                t ? (e.bufferUrl = t.url,
                e.bufferType = t.type) : e.bufferUrl = null
            }
            for (const e of Object.values(this._lastFxState))
                for (const t of e)
                    if (t.hasOwnProperty('bufferOriginalUrl')) {
                        const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t.bufferOriginalUrl);
                        e && (t.bufferUrl = e.url,
                        t.bufferType = e.type)
                    }
            this.PostToDOM('load-state', {
                saveLoadMode: this._saveLoadMode,
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                playing: this._lastAIState.filter(e=>null !== e.bufferUrl),
                effects: this._lastFxState
            })
        }
        GetDebuggerProperties() {
            var e = Math.round;
            const t = [];
            for (const [e,a] of Object.entries(this._lastFxState))
                t.push({
                    name: '$' + e,
                    value: a.map(e=>e.type).join(', ')
                });
            return [{
                title: 'plugins.audio.debugger.tag-effects',
                properties: t
            }, {
                title: 'plugins.audio.debugger.currently-playing',
                properties: [{
                    name: 'plugins.audio.debugger.currently-playing-count',
                    value: this._lastAIState.length
                }, ...this._lastAIState.map((t,a)=>({
                    name: '$#' + a,
                    value: `${t.bufferOriginalUrl} ("${t.tag}") ${e(10 * t.playbackTime) / 10} / ${e(10 * t.duration) / 10}`
                }))]
            }]
        }
    }
}
'use strict',
C3.Plugins.Audio.Cnds = {
    OnEnded(e) {
        return C3.equalsNoCase(this._triggerTag, e)
    },
    OnFadeEnded(e) {
        return C3.equalsNoCase(this._triggerTag, e)
    },
    PreloadsComplete() {
        return this._preloadCount === this._preloadTotal
    },
    AdvancedAudioSupported() {
        return !0
    },
    IsSilent() {
        return this._isSilent
    },
    IsAnyPlaying() {
        for (const e of this._lastAIState)
            if (e.isPlaying)
                return !0;
        return !1
    },
    IsTagPlaying(e) {
        return this._IsTagPlaying(e)
    }
},
'use strict';
{
    const t = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'];
    C3.Plugins.Audio.Acts = {
        async Play(t, a, n, r) {
            if (!this._isSilent) {
                const i = t[1]
                  , e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
                if (e) {
                    const l = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    const _ = this._MaybeMarkAsPlaying(r.toLowerCase(), i, 0 !== a, this.DbToLinear(n));
                    try {
                        await this.PostToDOMAsync('play', {
                            originalUrl: t[0],
                            url: e.url,
                            type: e.type,
                            isMusic: i,
                            tag: r.toLowerCase(),
                            isLooping: 0 !== a,
                            vol: this.DbToLinear(n),
                            pos: 0,
                            off: l,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        _ && (_.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPosition(t, a, r, n, _, e, d, u, c, i) {
            if (!this._isSilent) {
                const g = t[1]
                  , p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
                if (p) {
                    const l = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    const m = this._MaybeMarkAsPlaying(i.toLowerCase(), g, 0 !== a, this.DbToLinear(r));
                    try {
                        await this.PostToDOMAsync('play', {
                            originalUrl: t[0],
                            url: p.url,
                            type: p.type,
                            isMusic: g,
                            tag: i.toLowerCase(),
                            isLooping: 0 !== a,
                            vol: this.DbToLinear(r),
                            pos: 0,
                            off: l,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: n,
                                y: _,
                                angle: C3.toRadians(e),
                                innerAngle: C3.toRadians(d),
                                outerAngle: C3.toRadians(u),
                                outerGain: this.DbToLinear(c)
                            }
                        })
                    } finally {
                        m && (m.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObject(t, a, r, n, _, e, u, c) {
            if (!this._isSilent && n) {
                const g = n.GetFirstPicked();
                if (g && g.GetWorldInfo()) {
                    const i = g.GetWorldInfo()
                      , d = i.GetLayer().GetAngle()
                      , [p,h] = this.rotatePtAround(i.GetX(), i.GetY(), -d, this._listenerX, this._listenerY)
                      , l = t[1]
                      , m = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
                    if (m) {
                        const n = this._nextPlayTime;
                        this._nextPlayTime = 0;
                        const f = this._MaybeMarkAsPlaying(c.toLowerCase(), l, 0 !== a, this.DbToLinear(r));
                        try {
                            await this.PostToDOMAsync('play', {
                                originalUrl: t[0],
                                url: m.url,
                                type: m.type,
                                isMusic: l,
                                tag: c.toLowerCase(),
                                isLooping: 0 !== a,
                                vol: this.DbToLinear(r),
                                pos: 0,
                                off: n,
                                trueClock: !!self.C3_GetAudioContextCurrentTime,
                                panning: {
                                    x: p,
                                    y: h,
                                    angle: i.GetAngle() - d,
                                    innerAngle: C3.toRadians(_),
                                    outerAngle: C3.toRadians(e),
                                    outerGain: this.DbToLinear(u),
                                    uid: g.GetUID()
                                }
                            })
                        } finally {
                            f && (f.placeholder = this._runtime.GetTickCountNoSave())
                        }
                    }
                }
            }
        },
        async PlayByName(t, n, r, i, l) {
            if (!this._isSilent) {
                const e = 1 === t
                  , _ = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n);
                if (_) {
                    const t = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    const a = this._MaybeMarkAsPlaying(l.toLowerCase(), e, 0 !== r, this.DbToLinear(i));
                    try {
                        await this.PostToDOMAsync('play', {
                            originalUrl: n,
                            url: _.url,
                            type: _.type,
                            isMusic: e,
                            tag: l.toLowerCase(),
                            isLooping: 0 !== r,
                            vol: this.DbToLinear(i),
                            pos: 0,
                            off: t,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        a && (a.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPositionByName(t, n, r, _, d, e, u, c, g, i, p) {
            if (!this._isSilent) {
                const h = 1 === t
                  , l = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n);
                if (l) {
                    const t = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    const a = this._MaybeMarkAsPlaying(p.toLowerCase(), h, 0 !== r, this.DbToLinear(_));
                    try {
                        await this.PostToDOMAsync('play', {
                            originalUrl: n,
                            url: l.url,
                            type: l.type,
                            isMusic: h,
                            tag: p.toLowerCase(),
                            isLooping: 0 !== r,
                            vol: this.DbToLinear(_),
                            pos: 0,
                            off: t,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: d,
                                y: e,
                                angle: C3.toRadians(u),
                                innerAngle: C3.toRadians(c),
                                outerAngle: C3.toRadians(g),
                                outerGain: this.DbToLinear(i)
                            }
                        })
                    } finally {
                        a && (a.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObjectByName(t, r, _, u, a, d, c, g, h) {
            if (!this._isSilent && !this._isSilent && a) {
                const i = a.GetFirstPicked();
                if (i && i.GetWorldInfo()) {
                    const p = i.GetWorldInfo()
                      , e = p.GetLayer().GetAngle()
                      , [f,l] = this.rotatePtAround(p.GetX(), p.GetY(), -e, this._listenerX, this._listenerY)
                      , m = 1 === t
                      , n = this._runtime.GetAssetManager().GetProjectAudioFileUrl(r);
                    if (n) {
                        const t = this._nextPlayTime;
                        this._nextPlayTime = 0;
                        const a = this._MaybeMarkAsPlaying(h.toLowerCase(), m, 0 !== _, this.DbToLinear(u));
                        try {
                            await this.PostToDOMAsync('play', {
                                originalUrl: r,
                                url: n.url,
                                type: n.type,
                                isMusic: m,
                                tag: h.toLowerCase(),
                                isLooping: 0 !== _,
                                vol: this.DbToLinear(u),
                                pos: 0,
                                off: t,
                                trueClock: !!self.C3_GetAudioContextCurrentTime,
                                panning: {
                                    x: f,
                                    y: l,
                                    angle: p.GetAngle() - e,
                                    innerAngle: C3.toRadians(d),
                                    outerAngle: C3.toRadians(c),
                                    outerGain: this.DbToLinear(g),
                                    uid: i.GetUID()
                                }
                            })
                        } finally {
                            a && (a.placeholder = this._runtime.GetTickCountNoSave())
                        }
                    }
                }
            }
        },
        SetLooping(e, t) {
            this.PostToDOM('set-looping', {
                tag: e.toLowerCase(),
                isLooping: 0 === t
            })
        },
        SetMuted(e, t) {
            this.PostToDOM('set-muted', {
                tag: e.toLowerCase(),
                isMuted: 0 === t
            })
        },
        SetVolume(e, t) {
            this.PostToDOM('set-volume', {
                tag: e.toLowerCase(),
                vol: this.DbToLinear(t)
            })
        },
        FadeVolume(e, t, a, n) {
            this.PostToDOM('fade-volume', {
                tag: e.toLowerCase(),
                vol: this.DbToLinear(t),
                duration: a,
                stopOnEnd: 0 === n
            })
        },
        async Preload(e) {
            const t = e[1]
              , a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
            a && (this._preloadTotal++,
            await this.PostToDOMAsync('preload', {
                originalUrl: e[0],
                url: a.url,
                type: a.type,
                isMusic: t
            }),
            this._preloadCount++)
        },
        async PreloadByName(e, t) {
            const a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t);
            a && (this._preloadTotal++,
            await this.PostToDOMAsync('preload', {
                originalUrl: t,
                url: a.url,
                type: a.type,
                isMusic: 1 === e
            }),
            this._preloadCount++)
        },
        SetPlaybackRate(e, t) {
            this.PostToDOM('set-playback-rate', {
                tag: e.toLowerCase(),
                rate: Math.max(t, 0)
            })
        },
        Stop(e) {
            this.PostToDOM('stop', {
                tag: e.toLowerCase()
            })
        },
        StopAll() {
            this.PostToDOM('stop-all')
        },
        SetPaused(e, t) {
            this.PostToDOM('set-paused', {
                tag: e.toLowerCase(),
                paused: 0 === t
            })
        },
        Seek(e, t) {
            this.PostToDOM('seek', {
                tag: e.toLowerCase(),
                pos: t
            })
        },
        SetSilent(e) {
            2 === e && (e = this._isSilent ? 1 : 0),
            e = 0 === e,
            this._isSilent === e || (this._isSilent = e,
            this.PostToDOM('set-silent', {
                isSilent: e
            }))
        },
        SetMasterVolume(e) {
            const t = this.DbToLinear(e);
            this._masterVolume === t || (this._masterVolume = t,
            this.PostToDOM('set-master-volume', {
                vol: t
            }))
        },
        AddFilterEffect(a, n, r, l, e, _, d) {
            a = a.toLowerCase();
            const u = t[n];
            this._IncrementEffectCount(a),
            this.PostToDOM('add-effect', {
                type: 'filter',
                tag: a,
                params: [u, r, l, e, _, C3.clamp(d / 100, 0, 1)]
            })
        },
        AddDelayEffect(e, t, n, r) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'delay',
                tag: e,
                params: [t, this.DbToLinear(n), C3.clamp(r / 100, 0, 1)]
            })
        },
        AddFlangerEffect(t, n, r, i, l, e) {
            t = t.toLowerCase(),
            this._IncrementEffectCount(t),
            this.PostToDOM('add-effect', {
                type: 'flanger',
                tag: t,
                params: [n / 1e3, r / 1e3, i, l / 100, C3.clamp(e / 100, 0, 1)]
            })
        },
        AddPhaserEffect(t, n, r, i, l, e, _) {
            t = t.toLowerCase(),
            this._IncrementEffectCount(t),
            this.PostToDOM('add-effect', {
                type: 'phaser',
                tag: t,
                params: [n, r, i, l, e, C3.clamp(_ / 100, 0, 1)]
            })
        },
        AddConvolutionEffect(t, n, r, i) {
            t = t.toLowerCase();
            const l = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n[0]);
            l && (this._IncrementEffectCount(t),
            this.PostToDOM('add-effect', {
                type: 'convolution',
                tag: t,
                bufferOriginalUrl: n[0],
                bufferUrl: l.url,
                bufferType: l.type,
                params: [0 === r, C3.clamp(i / 100, 0, 1)]
            }))
        },
        AddGainEffect(e, t) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'gain',
                tag: e,
                params: [this.DbToLinear(t)]
            })
        },
        AddMuteEffect(e) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'gain',
                tag: e,
                params: [0]
            })
        },
        AddTremoloEffect(e, t, n) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'tremolo',
                tag: e,
                params: [t, C3.clamp(n / 100, 0, 1)]
            })
        },
        AddRingModEffect(e, t, n) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'ringmod',
                tag: e,
                params: [t, C3.clamp(n / 100, 0, 1)]
            })
        },
        AddDistortionEffect(t, n, r, i, l, e) {
            t = t.toLowerCase(),
            this._IncrementEffectCount(t),
            this.PostToDOM('add-effect', {
                type: 'distortion',
                tag: t,
                params: [this.DbToLinearNoCap(n), this.DbToLinearNoCap(r), i, this.DbToLinearNoCap(l), C3.clamp(e / 100, 0, 1)]
            })
        },
        AddCompressorEffect(t, n, r, i, l, e) {
            t = t.toLowerCase(),
            this._IncrementEffectCount(t),
            this.PostToDOM('add-effect', {
                type: 'compressor',
                tag: t,
                params: [n, r, i, l / 1e3, e / 1e3]
            })
        },
        AddAnalyserEffect(e, t, n) {
            e = e.toLowerCase(),
            this._IncrementEffectCount(e),
            this.PostToDOM('add-effect', {
                type: 'analyser',
                tag: e,
                params: [t, n]
            })
        },
        RemoveEffects(e) {
            e = e.toLowerCase(),
            this._effectCount.set(e, 0),
            this.PostToDOM('remove-effects', {
                tag: e
            }),
            this._lastFxState = {}
        },
        SetEffectParameter(t, a, n, r, i, e) {
            this.PostToDOM('set-effect-param', {
                tag: t.toLowerCase(),
                index: Math.floor(a),
                param: n,
                value: r,
                ramp: i,
                time: e
            })
        },
        SetListenerObject(e) {
            if (e) {
                const t = e.GetFirstPicked();
                t && t.GetWorldInfo() && (this._listenerInst = t)
            }
        },
        SetListenerZ(e) {
            this._listenerZ = e
        },
        ScheduleNextPlay(e) {
            this._nextPlayTime = Math.max(e, 0)
        },
        UnloadAudio(e) {
            const t = e[1]
              , a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
            a && this.PostToDOM('unload', {
                url: a.url,
                type: a.type,
                isMusic: t
            })
        },
        UnloadAudioByName(e, t) {
            const a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t);
            a && this.PostToDOM('unload', {
                url: a.url,
                type: a.type,
                isMusic: 1 === e
            })
        },
        UnloadAll() {
            this.PostToDOM('unload-all')
        }
    }
}
'use strict',
C3.Plugins.Audio.Exps = {
    Duration(e) {
        const t = this._GetFirstAudioStateByTag(e);
        return t ? t.duration : 0
    },
    PlaybackTime(e) {
        const t = this._GetFirstAudioStateByTag(e);
        return t ? t.playbackTime : 0
    },
    PlaybackRate(e) {
        const t = this._GetFirstAudioStateByTag(e);
        return t ? t.playbackRate : 0
    },
    Volume(e) {
        const t = this._GetFirstAudioStateByTag(e);
        return t ? this.LinearToDb(t.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._masterVolume)
    },
    EffectCount(e) {
        return this._effectCount.get(e.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(e, t) {
        const a = this.GetAnalyserData(e, Math.floor(t));
        return a ? a.binCount : 0
    },
    AnalyserFreqBinAt(t, a, n) {
        var r = Math.floor;
        const i = this.GetAnalyserData(t, r(a));
        return i ? (n = r(n),
        0 > n || n >= i.binCount ? 0 : i.freqBins[n]) : 0
    },
    AnalyserPeakLevel(e, t) {
        const a = this.GetAnalyserData(e, Math.floor(t));
        return a ? a.peak : 0
    },
    AnalyserRMSLevel(e, t) {
        const a = this.GetAnalyserData(e, Math.floor(t));
        return a ? a.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3
    }
},
'use strict',
C3.Plugins.Keyboard = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict';
{
    function e() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    C3.Plugins.Keyboard.Type = class extends C3.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return IKeyboardObjectType
        }
    }
    ;
    let t = null;
    self.IKeyboardObjectType = class extends IObjectClass {
        constructor(e) {
            super(e),
            t = e,
            e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
        }
        isKeyDown(t) {
            const a = e();
            if ('string' == typeof t)
                return a.IsKeyDown(t);
            if ('number' == typeof t)
                return a.IsKeyCodeDown(t);
            throw new TypeError('expected string or number')
        }
    }
}
'use strict',
C3.Plugins.Keyboard.Instance = class extends C3.SDKInstanceBase {
    constructor(e) {
        super(e),
        this._keysDownByString = new Set,
        this._keysDownByWhich = new Set,
        this._triggerWhich = 0,
        this._triggerString = '',
        this._triggerTypedKey = '';
        const t = this.GetRuntime().Dispatcher();
        this._disposables = new C3.CompositeDisposable(C3.Disposable.From(t, 'keydown', e=>this._OnKeyDown(e.data)),C3.Disposable.From(t, 'keyup', e=>this._OnKeyUp(e.data)),C3.Disposable.From(t, 'window-blur', ()=>this._OnWindowBlur()))
    }
    Release() {
        super.Release()
    }
    _OnKeyDown(e) {
        const t = e.which
          , a = e.code || t.toString()
          , n = e.key;
        this._keysDownByString.has(a) || (this._keysDownByString.add(a),
        this._keysDownByWhich.add(t),
        this._triggerString = a,
        this._triggerWhich = t,
        this._triggerTypedKey = n,
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnAnyKey),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnKey),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnKeyCode))
    }
    _OnKeyUp(e) {
        const t = e.which
          , a = e.code || t.toString()
          , n = e.key;
        this._keysDownByString.delete(a),
        this._keysDownByWhich.delete(t),
        this._triggerString = a,
        this._triggerWhich = t,
        this._triggerTypedKey = n,
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnKeyReleased),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased),
        this.Trigger(C3.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
    }
    _OnWindowBlur() {
        for (const e of this._keysDownByWhich)
            this._keysDownByWhich.delete(e),
            this._triggerWhich = e,
            this.Trigger(C3.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
            this.Trigger(C3.Plugins.Keyboard.Cnds.OnKeyReleased),
            this.Trigger(C3.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear()
    }
    IsKeyDown(e) {
        return this._keysDownByString.has(e)
    }
    IsKeyCodeDown(e) {
        return this._keysDownByWhich.has(e)
    }
    SaveToJson() {
        return {
            tk: this._triggerWhich,
            tkk: this._triggerTypedKey
        }
    }
    LoadFromJson(e) {
        this._triggerWhich = e.tk,
        e.hasOwnProperty('tkk') && (this._triggerTypedKey = e.tkk)
    }
    GetDebuggerProperties() {
        return [{
            title: 'plugins.keyboard.name',
            properties: [{
                name: 'plugins.keyboard.debugger.last-key-code',
                value: this._triggerWhich
            }, {
                name: 'plugins.keyboard.debugger.last-key-string',
                value: C3.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
            }, {
                name: 'plugins.keyboard.debugger.last-typed-key',
                value: this._triggerTypedKey
            }]
        }]
    }
}
,
'use strict';
{
    const e = ['ShiftLeft', 'ShiftRight', 'ControlLeft', 'ControlRight', 'AltLeft', 'AltRight', 'MetaLeft', 'MetaRight'];
    C3.Plugins.Keyboard.Cnds = {
        IsKeyDown(e) {
            return this._keysDownByWhich.has(e)
        },
        OnKey(e) {
            return this._triggerWhich === e
        },
        OnAnyKey() {
            return !0
        },
        OnAnyKeyReleased() {
            return !0
        },
        OnKeyReleased(e) {
            return this._triggerWhich === e
        },
        IsKeyCodeDown(e) {
            return e = Math.floor(e),
            this._keysDownByWhich.has(e)
        },
        OnKeyCode(e) {
            return this._triggerWhich === e
        },
        OnKeyCodeReleased(e) {
            return this._triggerWhich === e
        },
        OnLeftRightKeyPressed(t) {
            const a = e[t];
            return this._triggerString === a
        },
        OnLeftRightKeyReleased(t) {
            const a = e[t];
            return this._triggerString === a
        },
        IsLeftRightKeyDown(t) {
            const a = e[t];
            return this._keysDownByString.has(a)
        }
    }
}
'use strict',
C3.Plugins.Keyboard.Acts = {},
'use strict';
{
    function e(e) {
        return e = Math.floor(e),
        8 === e ? 'backspace' : 9 === e ? 'tab' : 13 === e ? 'enter' : 16 === e ? 'shift' : 17 === e ? 'control' : 18 === e ? 'alt' : 19 === e ? 'pause' : 20 === e ? 'capslock' : 27 === e ? 'esc' : 33 === e ? 'pageup' : 34 === e ? 'pagedown' : 35 === e ? 'end' : 36 === e ? 'home' : 37 === e ? '\u2190' : 38 === e ? '\u2191' : 39 === e ? '\u2192' : 40 === e ? '\u2193' : 45 === e ? 'insert' : 46 === e ? 'del' : 91 === e ? 'left window key' : 92 === e ? 'right window key' : 93 === e ? 'select' : 96 === e ? 'numpad 0' : 97 === e ? 'numpad 1' : 98 === e ? 'numpad 2' : 99 === e ? 'numpad 3' : 100 === e ? 'numpad 4' : 101 === e ? 'numpad 5' : 102 === e ? 'numpad 6' : 103 === e ? 'numpad 7' : 104 === e ? 'numpad 8' : 105 === e ? 'numpad 9' : 106 === e ? 'numpad *' : 107 === e ? 'numpad +' : 109 === e ? 'numpad -' : 110 === e ? 'numpad .' : 111 === e ? 'numpad /' : 112 === e ? 'F1' : 113 === e ? 'F2' : 114 === e ? 'F3' : 115 === e ? 'F4' : 116 === e ? 'F5' : 117 === e ? 'F6' : 118 === e ? 'F7' : 119 === e ? 'F8' : 120 === e ? 'F9' : 121 === e ? 'F10' : 122 === e ? 'F11' : 123 === e ? 'F12' : 144 === e ? 'numlock' : 145 === e ? 'scroll lock' : 186 === e ? ';' : 187 === e ? '=' : 188 === e ? ',' : 189 === e ? '-' : 190 === e ? '.' : 191 === e ? '/' : 192 === e ? '\'' : 219 === e ? '[' : 220 === e ? '\\' : 221 === e ? ']' : 222 === e ? '#' : 223 === e ? '`' : String.fromCharCode(e)
    }
    C3.Plugins.Keyboard.Exps = {
        LastKeyCode() {
            return this._triggerWhich
        },
        StringFromKeyCode(t) {
            return e(t)
        },
        TypedKey() {
            return this._triggerTypedKey
        }
    }
}
'use strict',
C3.Plugins.Tilemap = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
C3.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL = -2147483648,
C3.Plugins.Tilemap.TILE_FLIPPED_VERTICAL = 1073741824,
C3.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL = 536870912,
C3.Plugins.Tilemap.TILE_FLAGS_MASK = 3758096384,
C3.Plugins.Tilemap.TILE_ID_MASK = 536870911,
'use strict';
{
    const t = C3.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL
      , a = C3.Plugins.Tilemap.TILE_FLIPPED_VERTICAL
      , n = C3.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL
      , r = C3.Plugins.Tilemap.TILE_ID_MASK;
    C3.Plugins.Tilemap.Type = class extends C3.SDKTypeBase {
        constructor(e) {
            super(e),
            this._tilePolys = [],
            this._areTilePolysCached = !1
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(e) {
            return this.GetImageInfo().LoadStaticTexture(e, {
                sampling: this._runtime.GetSampling()
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
        OnDynamicTextureLoadComplete() {
            for (const e of this.GetObjectClass().instancesIncludingPendingCreate())
                e.GetSdkInstance()._OnDynamicTextureLoadComplete()
        }
        LoadTilePolyData(e) {
            for (const t of e)
                if (t) {
                    const e = t[0]
                      , a = !!t[1];
                    this._tilePolys.push({
                        poly: e,
                        use: a,
                        flipmap: [[[null, null], [null, null]], [[null, null], [null, null]]]
                    })
                } else
                    this._tilePolys.push(null)
        }
        _ForceCacheOfTileCollisionPolys(e, t) {
            this._areTilePolysCached = !1,
            this._MaybeCacheTileCollisionPolys(e, t)
        }
        _MaybeCacheTileCollisionPolys(e, t) {
            if (!this._areTilePolysCached) {
                this._areTilePolysCached = !0;
                for (let a = 0, n = this._tilePolys.length; a < n; ++a)
                    this._tilePolys[a] && (this._CacheTilePoly(a, e, t, !1, !1, !1),
                    this._CacheTilePoly(a, e, t, !1, !1, !0),
                    this._CacheTilePoly(a, e, t, !1, !0, !1),
                    this._CacheTilePoly(a, e, t, !1, !0, !0),
                    this._CacheTilePoly(a, e, t, !0, !1, !1),
                    this._CacheTilePoly(a, e, t, !0, !1, !0),
                    this._CacheTilePoly(a, e, t, !0, !0, !1),
                    this._CacheTilePoly(a, e, t, !0, !0, !0))
            }
        }
        _CacheTilePoly(t, n, r, i, l, e) {
            if (!(0 > t || t >= this._tilePolys.length)) {
                const _ = this._tilePolys[t];
                if (_) {
                    const t = C3.New(C3.CollisionPoly, _.poly, _.use);
                    t.transform(n, r, 0),
                    e && t.diag(),
                    i && t.mirror(n / 2),
                    l && t.flip(r / 2),
                    _.flipmap[i ? 1 : 0][l ? 1 : 0][e ? 1 : 0] = null,
                    _.flipmap[i ? 1 : 0][l ? 1 : 0][e ? 1 : 0] = t
                }
            }
        }
        GetTilePoly(l) {
            if (-1 === l)
                return null;
            const e = l & r;
            if (0 > e || e >= this._tilePolys.length)
                return null;
            const _ = this._tilePolys[e];
            if (!_)
                return null;
            const d = l & t ? 1 : 0
              , u = l & a ? 1 : 0
              , i = l & n ? 1 : 0;
            return _.flipmap[d][u][i]
        }
        IsTilePolyEnabled(e) {
            return !e || e.IsEnabled()
        }
    }
}
{
    function t(t) {
        const n = []
          , e = t.split(',');
        for (let r = 0, a = e.length; r < a; ++r) {
            const t = e[r]
              , a = t.indexOf('x');
            if (-1 < a) {
                let e = parseInt(t.substring(0, a), 10);
                const r = t.substring(a + 1);
                let l = parseInt(r, 10);
                for (r.includes('h') && (l |= _),
                r.includes('v') && (l |= S),
                r.includes('d') && (l |= c); 0 < e; --e)
                    n.push(l)
            } else {
                let e = parseInt(t, 10);
                t.includes('h') && (e |= _),
                t.includes('v') && (e |= S),
                t.includes('d') && (e |= c),
                n.push(e)
            }
        }
        return n
    }
    const _ = C3.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL
      , S = C3.Plugins.Tilemap.TILE_FLIPPED_VERTICAL
      , c = C3.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL
      , a = C3.Plugins.Tilemap.TILE_FLAGS_MASK
      , d = C3.Plugins.Tilemap.TILE_ID_MASK
      , y = C3.New(C3.Rect)
      , r = C3.New(C3.Rect);
    C3.Plugins.Tilemap.Instance = class extends C3.SDKWorldInstanceBase {
        constructor(t, a) {
            var n = Math.ceil
              , r = Math.max;
            super(t);
            const i = this.GetWorldInfo();
            this._tileWidth = 32,
            this._tileHeight = 32,
            this._tileXoffset = 0,
            this._tileYoffset = 0,
            this._tileXspacing = 0,
            this._tileYspacing = 0,
            this._mapWidth = 0,
            this._mapHeight = 0,
            this._lastWidth = i.GetWidth(),
            this._lastHeight = i.GetHeight(),
            this._cellWidth = 0,
            this._cellHeight = 0,
            this._tileCells = [],
            this._tileTexQuads = new Map,
            this._isAnyQuadMapChanged = !0,
            this._ownImageInfo = null,
            a && (i.SetVisible(a[0]),
            this._tileWidth = r(a[1], 1),
            this._tileHeight = r(a[2], 1),
            this._tileXoffset = a[3],
            this._tileYoffset = a[4],
            this._tileXspacing = a[5],
            this._tileYspacing = a[6]),
            this._cellWidth = n(this._runtime.GetOriginalViewportWidth() / this._tileWidth),
            this._cellHeight = n(this._runtime.GetOriginalViewportHeight() / this._tileHeight),
            this._sdkType._MaybeCacheTileCollisionPolys(this._tileWidth, this._tileHeight)
        }
        Release() {
            this._ReleaseOwnImage(),
            C3.clearArray(this._tileCells),
            this._tileCells = null,
            this._tileTexQuads.clear(),
            this._tileTexQuads = null,
            super.Release()
        }
        _ReleaseOwnImage() {
            this._ownImageInfo && (this._ownImageInfo.Release(),
            this._ownImageInfo = null)
        }
        LoadTilemapData(e, t, a) {
            this._mapWidth = t,
            this._mapHeight = a,
            this._MaybeResizeTilemap(!0),
            this.SetTilesFromRLECSV(e),
            this._MaybeBuildAllQuadMap()
        }
        _MaybeResizeTilemap(t) {
            var a = Math.floor
              , n = Math.ceil;
            const r = this.GetWorldInfo()
              , i = a(r.GetWidth() / this._tileWidth)
              , e = a(r.GetHeight() / this._tileHeight);
            if (i <= this._mapWidth && e <= this._mapHeight && !t)
                return;
            let l = 0
              , _ = 0;
            t ? (l = n(this._mapHeight / this._cellHeight),
            _ = n(this._mapWidth / this._cellWidth)) : (l = this._tileCells.length,
            _ = n(this._mapWidth / this._cellWidth),
            e > this._mapHeight && (this._mapHeight = e,
            l = n(this._mapHeight / this._cellHeight)),
            i > this._mapWidth && (this._mapWidth = i,
            _ = n(this._mapWidth / this._cellWidth)),
            this._SetAllQuadMapChanged(),
            this._SetPhysicsChanged(),
            this._runtime.UpdateRender());
            const d = this._tileCells;
            if (d.length < l)
                for (let e = d.length; e < l; ++e)
                    d.push([]);
            for (let e = 0; e < l; ++e) {
                const t = d[e];
                for (let a = t.length; a < _; ++a)
                    t.push(C3.New(C3.Plugins.Tilemap.TileCell, this, a, e))
            }
        }
        SetTilesFromRLECSV(a) {
            const n = t(a);
            let r = 0;
            const i = this._mapWidth
              , l = this._cellWidth
              , _ = this._cellHeight;
            for (let t = 0, e = this._mapHeight; t < e; ++t)
                for (let a = 0; a < i; ++a) {
                    const i = n[r++]
                      , e = this.GetCellAt(a, t);
                    e && e.SetTileAt(a % l, t % _, i)
                }
        }
        GetTilesAsRLECSV() {
            var t = Math.floor;
            let r = '';
            if (0 >= this._mapWidth || 0 >= this._mapHeight)
                return r;
            let u = 1
              , p = this.GetTileAt(0, 0);
            const a = this.GetWorldInfo()
              , f = t(a.GetWidth() / this._tileWidth)
              , i = t(a.GetHeight() / this._tileHeight);
            let y = -1
              , G = !1
              , b = !1
              , T = !1;
            for (let e = 0; e < i; ++e)
                for (let t = 0 === e ? 1 : 0; t < f; ++t) {
                    const a = this.GetTileAt(t, e);
                    a === p ? ++u : (-1 === p ? (y = -1,
                    G = !1,
                    b = !1,
                    T = !1) : (y = p & d,
                    G = 0 != (p & _),
                    b = 0 != (p & S),
                    T = 0 != (p & c)),
                    r += 1 == u ? '' + y : '' + u + 'x' + y,
                    G && (r += 'h'),
                    b && (r += 'v'),
                    T && (r += 'd'),
                    r += ',',
                    u = 1,
                    p = a)
                }
            return -1 === p ? (y = -1,
            G = !1,
            b = !1,
            T = !1) : (y = p & d,
            G = 0 != (p & _),
            b = 0 != (p & S),
            T = 0 != (p & c)),
            r += 1 == u ? '' + y : '' + u + 'x' + y,
            G && (r += 'h'),
            b && (r += 'v'),
            T && (r += 'd'),
            r
        }
        _SetAllQuadMapChanged() {
            const e = this._tileCells;
            for (let t = 0, a = e.length; t < a; ++t) {
                const n = e[t];
                for (let e = 0, t = n.length; e < t; ++e)
                    n[e]._SetQuadMapChanged()
            }
            this._isAnyQuadMapChanged = !0
        }
        _MaybeBuildAllQuadMap() {
            if (this._isAnyQuadMapChanged) {
                this._isAnyQuadMapChanged = !1;
                const e = this._tileCells;
                for (let t = 0, a = e.length; t < a; ++t) {
                    const n = e[t];
                    for (let e = 0, t = n.length; e < t; ++e)
                        n[e].MaybeBuildQuadMap()
                }
            }
        }
        SetTileChanged() {
            this._isAnyQuadMapChanged = !0,
            this._SetPhysicsChanged(),
            this._runtime.UpdateRender()
        }
        _SetPhysicsChanged() {
            this._inst.GetUnsavedDataMap().set('PhysicsChanged', !0)
        }
        GetCellAt(t, a) {
            var n = Math.floor;
            if (0 > t || 0 > a)
                return null;
            const r = n(a / this._cellHeight);
            if (r >= this._tileCells.length)
                return null;
            const i = this._tileCells[r]
              , e = n(t / this._cellWidth);
            return e >= i.length ? null : i[e]
        }
        GetCellAtIndex(e, t) {
            if (0 > e || 0 > t || t >= this._tileCells.length)
                return null;
            const a = this._tileCells[t];
            return e >= a.length ? null : a[e]
        }
        GetTileAt(e, t) {
            var n = Math.floor;
            if (e = n(e),
            t = n(t),
            0 > e || 0 > t || e >= this._mapWidth || t >= this._mapHeight)
                return -1;
            const r = this.GetCellAt(e, t);
            return r ? r.GetTilesArr()[t % this._cellHeight][e % this._cellWidth] : -1
        }
        SetTileAt(e, t, n) {
            var r = Math.floor;
            if (e = r(e),
            t = r(t),
            !(0 > e || 0 > t || e >= this._mapWidth || t >= this._mapHeight)) {
                const a = this.GetCellAt(e, t);
                a && a.SetTileAt(e % this._cellWidth, t % this._cellHeight, n)
            }
        }
        WorldToCellX(e) {
            return Math.floor((e - this.GetWorldInfo().GetX()) / (this._cellWidth * this._tileWidth))
        }
        WorldToCellY(e) {
            return Math.floor((e - this.GetWorldInfo().GetY()) / (this._cellHeight * this._tileHeight))
        }
        WorldToTileX(e) {
            return Math.floor((e - this.GetWorldInfo().GetX()) / this._tileWidth)
        }
        WorldToTileY(e) {
            return Math.floor((e - this.GetWorldInfo().GetY()) / this._tileHeight)
        }
        GetMapWidth() {
            return this._mapWidth
        }
        GetMapHeight() {
            return this._mapHeight
        }
        GetTileWidth() {
            return this._tileWidth
        }
        GetTileHeight() {
            return this._tileHeight
        }
        GetCellWidth() {
            return this._cellWidth
        }
        GetCellHeight() {
            return this._cellHeight
        }
        GetCollisionRectCandidates(t, n) {
            const a = this.WorldToCellX(t.getLeft())
              , r = this.WorldToCellY(t.getTop())
              , i = this.WorldToCellX(t.getRight())
              , e = this.WorldToCellY(t.getBottom());
            for (let l = a; l <= i; ++l)
                for (let t = r; t <= e; ++t) {
                    const e = this.GetCellAtIndex(l, t);
                    e && (e.MaybeBuildQuadMap(),
                    C3.appendArray(n, e.GetCollisionRects()))
                }
        }
        TestPointOverlapTile(t, n) {
            var r = Math.floor;
            const l = this.WorldToTileX(t)
              , _ = this.WorldToTileY(n)
              , e = this.GetTileAt(l, _);
            if (-1 === e)
                return !1;
            const d = this._sdkType.GetTilePoly(e);
            if (!d)
                return !0;
            if (!this._sdkType.IsTilePolyEnabled(d))
                return !1;
            const u = this.GetWorldInfo()
              , c = r((t - u.GetX()) / this._tileWidth) * this._tileWidth + u.GetX()
              , i = r((n - u.GetY()) / this._tileHeight) * this._tileHeight + u.GetY();
            return t -= c,
            n -= i,
            d.containsPoint(t, n)
        }
        GetAllCollisionRects(e) {
            const t = this._tileCells;
            for (let a = 0, n = t.length; a < n; ++a) {
                const n = t[a];
                for (let t = 0, a = n.length; t < a; ++t) {
                    const a = n[t];
                    a.MaybeBuildQuadMap(),
                    C3.appendArray(e, a.GetCollisionRects())
                }
            }
        }
        GetCurrentImageInfo() {
            return this._ownImageInfo || this._objectClass.GetImageInfo()
        }
        GetTileUvQuad(g) {
            var e = Math.floor;
            const h = this._tileTexQuads
              , i = h.get(g);
            if (i)
                return i;
            const f = g & d
              , G = this.GetCurrentImageInfo()
              , l = G.GetWidth()
              , m = this._tileWidth
              , n = this._tileXoffset
              , b = this._tileXspacing
              , p = e((l - n) / (m + b) * m) + b
              , T = e(p / m)
              , a = f % T
              , r = e(f / T)
              , I = G.GetOffsetX() + this._tileXoffset + (this._tileWidth + this._tileXspacing) * a
              , t = G.GetOffsetY() + this._tileYoffset + (this._tileHeight + this._tileYspacing) * r;
            y.setWH(I, t, this._tileWidth, this._tileHeight),
            y.divide(G.GetSheetWidth(), G.GetSheetHeight());
            const u = C3.New(C3.Quad);
            return u.setFromRect(y),
            0 != (g & c) && u.diag(),
            0 != (g & _) && u.mirror(),
            0 != (g & S) && u.flip(),
            u.offset(a, r),
            h.set(g, u),
            u
        }
        _OnDynamicTextureLoadComplete() {
            this._tileTexQuads.clear(),
            this._SetAllQuadMapChanged()
        }
        Draw(t) {
            var a = Math.round
              , _ = Math.floor;
            const u = this.GetCurrentImageInfo()
              , d = u.GetTexture();
            if (!d)
                return;
            y.copy(u.GetTexRect()),
            y.offsetLeft(this._tileXoffset / d.GetWidth()),
            y.offsetTop(this._tileYoffset / d.GetHeight()),
            t.SetTilemapFillMode(),
            t.SetTilemapInfo(y, d.GetWidth(), d.GetHeight(), this._tileWidth, this._tileHeight, this._tileXspacing, this._tileYspacing),
            t.SetTexture(d);
            const e = this.GetWorldInfo();
            (e.GetWidth() !== this._lastWidth || e.GetHeight() !== this._lastHeight) && (this._SetPhysicsChanged(),
            this._SetAllQuadMapChanged(),
            this._lastWidth = e.GetWidth(),
            this._lastHeight = e.GetHeight());
            const g = r;
            e.GetLayer().GetViewportForZ(e.GetTotalZElevation(), g);
            let i = e.GetX()
              , h = e.GetY();
            this._runtime.IsPixelRoundingEnabled() && (i = a(i),
            h = a(h));
            const c = this._cellWidth * this._tileWidth
              , l = this._cellHeight * this._tileHeight
              , m = _((g.getLeft() - i) / c)
              , n = _((g.getRight() - i) / c)
              , f = _((g.getTop() - h) / l)
              , p = _((g.getBottom() - h) / l);
            for (let e = m; e <= n; ++e)
                for (let a = f; a <= p; ++a) {
                    const n = this.GetCellAtIndex(e, a);
                    n && (n.MaybeBuildQuadMap(),
                    n.Draw(t, g, i, h))
                }
        }
        SaveToJson() {
            var e = Math.floor;
            this._MaybeResizeTilemap();
            const t = this.GetWorldInfo()
              , a = e(t.GetWidth() / this._tileWidth)
              , n = e(t.GetHeight() / this._tileHeight);
            return {
                tw: this._tileWidth,
                th: this._tileHeight,
                tox: this._tileXoffset,
                toy: this._tileYoffset,
                tsx: this._tileXspacing,
                tsy: this._tileYspacing,
                w: a,
                h: n,
                d: this.GetTilesAsRLECSV()
            }
        }
        LoadFromJson(e) {
            this._tileWidth = e.tw,
            this._tileHeight = e.th,
            this._tileXoffset = e.tox,
            this._tileYoffset = e.toy,
            this._tileXspacing = e.tsx,
            this._tileYspacing = e.tsy,
            this._mapWidth = e.w,
            this._mapHeight = e.h,
            this._MaybeResizeTilemap(!0),
            this.SetTilesFromRLECSV(e.d),
            this._SetPhysicsChanged(),
            this._SetAllQuadMapChanged()
        }
        GetAsJsonString() {
            var e = Math.floor;
            this._MaybeResizeTilemap();
            const t = this.GetWorldInfo()
              , a = e(t.GetWidth() / this._tileWidth)
              , n = e(t.GetHeight() / this._tileHeight);
            return JSON.stringify({
                c2tilemap: !0,
                width: a,
                height: n,
                data: this.GetTilesAsRLECSV()
            })
        }
        StateComboToFlags(e) {
            return 0 === e ? 0 : 1 === e ? _ : 2 === e ? S : 3 === e ? _ | c : 4 === e ? _ | S : 5 === e ? S | c : 6 === e ? _ | S | c : 7 === e ? c : 0
        }
        GetPropertyValueByIndex(e) {
            return 1 === e ? this._tileWidth : 2 === e ? this._tileHeight : 3 === e ? this._tileXoffset : 4 === e ? this._tileYoffset : 5 === e ? this._tileXspacing : 6 === e ? this._tileYspacing : void 0
        }
        SetPropertyValueByIndex(e, t) {
            var a = Math.ceil
              , n = Math.max;
            switch (e) {
            case 1:
                if (this._tileWidth === t)
                    return;
                this._tileWidth = n(t, 1),
                this._cellWidth = a(this._runtime.GetOriginalViewportWidth() / this._tileWidth),
                this._sdkType._ForceCacheOfTileCollisionPolys(),
                this._UpdateQuadMaps();
                break;
            case 2:
                if (this._tileHeight === t)
                    return;
                this._tileHeight = n(t, 1),
                this._cellHeight = a(this._runtime.GetOriginalViewportHeight() / this._tileHeight),
                this._sdkType._ForceCacheOfTileCollisionPolys(),
                this._UpdateQuadMaps();
                break;
            case 3:
                if (this._tileXoffset === t)
                    return;
                this._tileXoffset = t,
                this._UpdateQuadMaps();
                break;
            case 4:
                if (this._tileYoffset === t)
                    return;
                this._tileYoffset = t,
                this._UpdateQuadMaps();
                break;
            case 5:
                if (this._tileXspacing === t)
                    return;
                this._tileXspacing = t,
                this._UpdateQuadMaps();
                break;
            case 6:
                if (this._tileYspacing === t)
                    return;
                this._tileYspacing = t,
                this._UpdateQuadMaps();
            }
        }
        _UpdateQuadMaps() {
            this._tileTexQuads.clear(),
            this._SetAllQuadMapChanged(),
            this._MaybeBuildAllQuadMap()
        }
        GetScriptInterfaceClass() {
            return ITilemapInstance
        }
    }
    ;
    const e = new WeakMap;
    self.ITilemapInstance = class extends IWorldInstance {
        constructor() {
            super(),
            e.set(this, IInstance._GetInitInst().GetSdkInstance())
        }
        get mapWidth() {
            return e.get(this).GetMapWidth()
        }
        get mapHeight() {
            return e.get(this).GetMapHeight()
        }
        get tileWidth() {
            return e.get(this).GetTileWidth()
        }
        get tileHeight() {
            return e.get(this).GetTileHeight()
        }
        getTileAt(t, a) {
            return e.get(this).GetTileAt(t, a)
        }
        setTileAt(t, a, n) {
            return e.get(this).SetTileAt(t, a, n)
        }
    }
    ,
    ITilemapInstance.TILE_FLIPPED_HORIZONTAL = _,
    ITilemapInstance.TILE_FLIPPED_VERTICAL = S,
    ITilemapInstance.TILE_FLIPPED_DIAGONAL = c,
    ITilemapInstance.TILE_FLAGS_MASK = a,
    ITilemapInstance.TILE_ID_MASK = d
}
{
    const t = C3.Plugins.Tilemap.TILE_FLAGS_MASK
      , n = C3.Plugins.Tilemap.TILE_ID_MASK;
    C3.Plugins.Tilemap.Cnds = {
        CompareTileAt(t, a, r, i) {
            let e = this.GetTileAt(t, a);
            return -1 !== e && (e &= n),
            C3.compare(e, r, i)
        },
        CompareTileStateAt(a, n, r) {
            const i = this.GetTileAt(a, n);
            let e = 0;
            return -1 !== i && (e = i & t),
            e === this.StateComboToFlags(r)
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        }
    }
}
{
    const t = C3.Plugins.Tilemap.TILE_ID_MASK;
    C3.Plugins.Tilemap.Acts = {
        EraseTile(e, t) {
            this._MaybeResizeTilemap(),
            this.SetTileAt(e, t, -1)
        },
        SetTile(a, n, r, i) {
            this._MaybeResizeTilemap(),
            this.SetTileAt(a, n, r & t | this.StateComboToFlags(i))
        },
        SetTileState(a, n, r) {
            const i = this.GetTileAt(a, n);
            -1 !== i && (this._MaybeResizeTilemap(),
            this.SetTileAt(a, n, i & t | this.StateComboToFlags(r)))
        },
        EraseTileRange(t, a, n, r) {
            var l = Math.min
              , e = Math.floor
              , _ = Math.max;
            const d = e(_(t, 0))
              , u = e(_(a, 0))
              , i = e(l(t + n, this._mapWidth))
              , c = e(l(a + r, this._mapHeight));
            for (let l = u; l < c; ++l)
                for (let e = d; e < i; ++e)
                    this.SetTileAt(e, l, -1)
        },
        SetTileRange(a, r, _, d, e, u) {
            var c = Math.min
              , g = Math.floor
              , i = Math.max;
            this._MaybeResizeTilemap();
            const p = g(i(a, 0))
              , h = g(i(r, 0))
              , l = g(c(a + _, this._mapWidth))
              , m = g(c(r + d, this._mapHeight))
              , n = e & t | this.StateComboToFlags(u);
            for (let t = h; t < m; ++t)
                for (let e = p; e < l; ++e)
                    this.SetTileAt(e, t, n)
        },
        SetTileStateRange(a, r, _, d, e) {
            var u = Math.min
              , c = Math.floor
              , g = Math.max;
            this._MaybeResizeTilemap();
            const i = c(g(a, 0))
              , p = c(g(r, 0))
              , h = c(u(a + _, this._mapWidth))
              , l = c(u(r + d, this._mapHeight))
              , m = this.StateComboToFlags(e);
            for (let n = p; n < l; ++n)
                for (let e = i; e < h; ++e) {
                    const a = this.GetTileAt(e, n);
                    -1 !== a && this.SetTileAt(e, n, a & t | m)
                }
        },
        LoadFromJSON(e) {
            let t = null;
            try {
                t = JSON.parse(e)
            } catch (e) {
                return void console.error('[Construct 3] Failed to parse tilemap JSON: ', e)
            }
            return t.c2tilemap ? void (this._mapWidth = t.width,
            this._mapHeight = t.height,
            this._MaybeResizeTilemap(!0),
            this.SetTilesFromRLECSV(t.data),
            this._SetAllQuadMapChanged(),
            this._SetPhysicsChanged()) : void console.error('[Construct 3] Unrecognized JSON data format')
        },
        JSONDownload(e) {
            const t = URL.createObjectURL(new Blob([this.GetAsJsonString()],{
                type: 'application/json'
            }));
            this._runtime.InvokeDownload(t, e)
        },
        async LoadURL(e) {
            if (!(this._ownImageInfo && this._ownImageInfo.GetURL() === e)) {
                const t = this._runtime
                  , a = C3.New(C3.ImageInfo);
                if (await a.LoadDynamicAsset(t, e),
                !a.IsLoaded())
                    return void this.Trigger(C3.Plugins.Tilemap.Cnds.OnURLFailed);
                if (this.WasReleased())
                    return a.Release(),
                    null;
                const n = await a.LoadStaticTexture(t.GetWebGLRenderer(), {
                    sampling: this._runtime.GetSampling()
                });
                return n ? this.WasReleased() ? void a.Release() : void (this._ReleaseOwnImage(),
                this._ownImageInfo = a,
                t.UpdateRender(),
                this._tileTexQuads.clear(),
                this._SetAllQuadMapChanged(),
                await this.TriggerAsync(C3.Plugins.Tilemap.Cnds.OnURLLoaded)) : void 0
            }
        }
    }
}
{
    const e = C3.Plugins.Tilemap.TILE_ID_MASK;
    C3.Plugins.Tilemap.Exps = {
        TileAt(t, a) {
            const n = this.GetTileAt(t, a);
            return -1 === n ? -1 : n & e
        },
        PositionToTileX(e) {
            return this.WorldToTileX(e)
        },
        PositionToTileY(e) {
            return this.WorldToTileY(e)
        },
        TileToPositionX(e) {
            return e * this._tileWidth + this.GetWorldInfo().GetX() + this._tileWidth / 2
        },
        TileToPositionY(e) {
            return e * this._tileHeight + this.GetWorldInfo().GetY() + this._tileHeight / 2
        },
        SnapX(e) {
            const t = this.GetWorldInfo().GetX();
            return Math.floor((e - t) / this._tileWidth) * this._tileWidth + t + this._tileWidth / 2
        },
        SnapY(e) {
            const t = this.GetWorldInfo().GetY();
            return Math.floor((e - t) / this._tileHeight) * this._tileHeight + t + this._tileHeight / 2
        },
        TilesJSON() {
            return this.GetAsJsonString()
        }
    }
}
{
    const t = C3.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL
      , a = C3.Plugins.Tilemap.TILE_FLIPPED_VERTICAL
      , n = C3.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL
      , r = C3.Plugins.Tilemap.TILE_ID_MASK
      , i = C3.New(C3.Rect)
      , e = C3.New(C3.Quad);
    C3.Plugins.Tilemap.TileQuad = class extends C3.DefendedBase {
        constructor() {
            super(),
            this._id = -1,
            this._tileId = -1,
            this._isHorizFlip = !1,
            this._isVertFlip = !1,
            this._isDiagFlip = !1,
            this._rc = C3.New(C3.Rect),
            this._uv = null
        }
        Update(_, e, d, u, c, i, g, m) {
            this._id = _,
            this._tileId = _ & r,
            this._isHorizFlip = 0 != (_ & t),
            this._isVertFlip = 0 != (_ & a),
            this._isDiagFlip = 0 != (_ & n),
            this._rc.setWH(u * e + i, c * d + g, e, d),
            this._uv = m.GetTileUvQuad(this._id)
        }
        Draw(t, a, n, r) {
            i.copy(this._rc),
            i.offset(n, r),
            i.intersectsRect(a) && (e.setFromRect(i),
            t.Quad4(e, this._uv))
        }
    }
}
'use strict',
C3.Plugins.Tilemap.TileCollisionRect = class extends C3.DefendedBase {
    constructor() {
        super(),
        this._id = -1,
        this._poly = null,
        this._rc = C3.New(C3.Rect)
    }
    Update(t, a, n, r, i, e, l, _) {
        this._id = t,
        this._poly = a,
        this._rc.setWH(i * n + l, e * r + _, n, r)
    }
    ExtendRight(e) {
        this._rc.setRight(this._rc.getRight() + e)
    }
    GetTileId() {
        return this._id
    }
    HasPoly() {
        return !!this._poly
    }
    GetPoly() {
        return this._poly
    }
    GetRect() {
        return this._rc
    }
}
,
'use strict';
{
    C3.Plugins.Tilemap.TILE_ID_MASK;
    C3.Plugins.Tilemap.TileCell = class extends C3.DefendedBase {
        constructor(t, a, n) {
            super();
            const r = t.GetCellWidth()
              , i = t.GetCellHeight();
            this._sdkInst = t,
            this._x = a,
            this._y = n,
            this._left = this._x * r * t.GetTileWidth(),
            this._top = this._y * i * t.GetTileHeight(),
            this._tiles = [],
            this._quads = [],
            this._collisionRects = [],
            this._isQuadMapValid = !1;
            for (let e = 0; e < i; ++e) {
                const e = new Int32Array(r);
                e.fill(-1),
                this._tiles.push(e)
            }
        }
        Clear() {
            const t = this._sdkInst.GetCellWidth()
              , e = this._sdkInst.GetCellHeight()
              , a = this._tiles;
            if (a.length < e)
                for (let n = a.length; n < e; ++n)
                    a.push(new Int32Array(t));
            else
                a.length > e && C3.truncateArray(a, e);
            for (let n = 0, r = a.length, e; n < r; ++n)
                e = a[n],
                e.length !== t && (e = new Int32Array(t),
                a[n] = e),
                e.fill(-1)
        }
        _SetQuadMapChanged() {
            this._isQuadMapValid = !1
        }
        MaybeBuildQuadMap() {
            var _ = Math.min
              , a = Math.floor;
            if (this._isQuadMapValid)
                return;
            const u = this._sdkInst
              , S = u.GetSdkType()
              , d = u.GetWorldInfo()
              , y = u.GetTileWidth()
              , f = u.GetTileHeight()
              , e = u.GetCellWidth()
              , c = u.GetCellHeight()
              , g = this._left
              , G = this._top;
            if (0 >= y || 0 >= f)
                return;
            let i = _(u.GetMapWidth(), a(d.GetWidth() / y))
              , h = _(u.GetMapHeight(), a(d.GetHeight() / f));
            i -= g / y,
            h -= G / f,
            i > e && (i = e),
            h > c && (h = c);
            const T = this._tiles
              , n = this._quads;
            let I = 0;
            for (let t = 0; t < h; ++t) {
                const a = T[t];
                for (let r = 0; r < i; ++r) {
                    const i = a[r];
                    if (-1 === i)
                        continue;
                    let e = null;
                    I < n.length ? e = n[I] : (e = C3.New(C3.Plugins.Tilemap.TileQuad),
                    n.push(e)),
                    e.Update(i, y, f, r, t, g, G, u),
                    ++I
                }
            }
            I < n.length && C3.truncateArray(n, I);
            let C = null
              , v = !1;
            const x = this._collisionRects;
            C3.clearArray(x);
            for (let t = 0; t < h; ++t) {
                const a = T[t];
                for (let n = 0; n < i; ++n) {
                    const r = a[n]
                      , e = S.GetTilePoly(r)
                      , l = S.IsTilePolyEnabled(e);
                    if (-1 === r || !l) {
                        C && (x.push(C),
                        C = null,
                        v = !1);
                        continue
                    }
                    !C || e || v ? (C && x.push(C),
                    C = C3.New(C3.Plugins.Tilemap.TileCollisionRect),
                    C.Update(r, e, y, f, n, t, g, G),
                    v = !!e) : C.ExtendRight(y)
                }
                C && (x.push(C),
                C = null,
                v = !1)
            }
            let P = x.length;
            for (let e = 0; e < P; ++e) {
                const t = x[e];
                if (t.HasPoly())
                    continue;
                const n = t.GetRect();
                for (let t = e + 1; t < P; ++t) {
                    const e = x[t]
                      , a = e.GetRect();
                    a.getTop() < n.getBottom() || a.getTop() > n.getBottom() || a.getRight() > n.getRight() || a.getLeft() > n.getLeft() || e.HasPoly() || a.getLeft() !== n.getLeft() || a.getRight() !== n.getRight() || (x.splice(t, 1),
                    --P,
                    n.setBottom(n.getBottom() + f),
                    --t)
                }
            }
            this._isQuadMapValid = !0
        }
        SetTileAt(e, t, a) {
            this._tiles[t][e] === a || (this._tiles[t][e] = a,
            this._isQuadMapValid = !1,
            this._sdkInst.SetTileChanged())
        }
        GetTilesArr() {
            return this._tiles
        }
        GetCollisionRects() {
            return this._collisionRects
        }
        Draw(t, a, n, r) {
            const i = this._sdkInst
              , e = this._quads;
            for (let l = 0, _ = e.length; l < _; ++l)
                e[l].Draw(t, a, n, r, i)
        }
    }
}
'use strict',
C3.Plugins.GD_SDK = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.GD_SDK.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Plugins.GD_SDK.Instance = class extends C3.SDKInstanceBase {
    constructor(e, t) {
        super(e),
        this._gameID = '',
        this._sdkReady = !1,
        this._adPlaying = !1,
        this._adViewed = !1,
        this._preloadedAd = !1,
        this._available_adtypes = ['interstitial', 'rewarded'],
        t && (this._gameID = t[0]),
        window.GD_OPTIONS = {
            gameId: this._gameID,
            advertisementSettings: {},
            onEvent: e=>{
                switch (e.name) {
                case 'SDK_GAME_START':
                    this._adPlaying = !1;
                    break;
                case 'SDK_GAME_PAUSE':
                    this._adPlaying = !0;
                    break;
                case 'SDK_GDPR_TRACKING':
                    break;
                case 'SDK_GDPR_TARGETING':
                    break;
                case 'COMPLETE':
                    this._adViewed = !0,
                    setTimeout(()=>{
                        this._adViewed = !1
                    }
                    , 5e3);
                    break;
                case 'SDK_READY':
                    this._sdkReady = !0;
                }
            }
        }
		/*-ouley
        function(e, t, a) {
            var n = e.getElementsByTagName(t)[0], r;
            e.getElementById(a) || (r = e.createElement(t),
            r.id = a,
            r.src = '//html5.api.gamedistribution.com/main.min.js',
            n.parentNode.insertBefore(r, n))
        }(document, 'script', 'gamedistribution-jssdk')*/
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {}
    }
    LoadFromJson() {}
    PreloadRewardedAd() {
        this._preloadedAd = !1;
        var e = window.gdsdk;
        'undefined' !== e && 'undefined' !== e.preloadAd && e.preloadAd('rewarded').then(()=>{
            this._preloadedAd = !0
        }
        ).catch(()=>{
            this._preloadedAd = !1
        }
        )
    }
    ShowAd(e) {
		/*-ouley
        var t = window.gdsdk;
        'undefined' !== t && 'undefined' !== t.showAd && (t.showAd(e),
        'rewarded' === e && (this._preloadedAd = !1))
		*/
    }
}
,
'use strict',
C3.Plugins.GD_SDK.Cnds = {
    ResumeGame() {
        return !this._adPlaying
    },
    PauseGame() {
        return this._adPlaying
    },
    PreloadedAd() {
        return this._preloadedAd
    },
    AdViewed() {
        return this._adViewed
    }
},
'use strict',
C3.Plugins.GD_SDK.Acts = {
    ShowAd() {
        this.ShowAd()
    },
    PreloadRewardedAd() {
        this.PreloadRewardedAd()
    },
    ShowRewardedAd() {
        this.ShowAd('rewarded')
    }
},
'use strict',
C3.Plugins.GD_SDK.Exps = {},
'use strict',
C3.Plugins.GameAnalytics = class extends C3.SDKPluginBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Plugins.GameAnalytics.Type = class extends C3.SDKTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Plugins.GameAnalytics.Instance = class extends C3.SDKInstanceBase {
    constructor(e, t) {
        super(e),
        this._build = '',
        this._customUserId = '',
        this._enableManualSessionHandling = !1,
        this._enableInfoLog = !1,
        this._enableVerboseLog = !1,
        this._autoDetectAppVersion = !1,
        this._gameKeyBrowser = '',
        this._secretKeyBrowser = '',
        this._gameKeyAndroid = '',
        this._secretKeyAndroid = '',
        this._gameKeyIOS = '',
        this._secretKeyIOS = '',
        this._customDimensions01 = [],
        this._customDimensions02 = [],
        this._customDimensions03 = [],
        this._resourceCurrencies = [],
        this._resourceItemTypes = [],
        t && (this._build = t[0],
        this._customUserId = t[1],
        this._enableManualSessionHandling = t[2],
        this._enableInfoLog = t[3],
        this._enableVerboseLog = t[4],
        this._autoDetectAppVersion = t[5],
        this._gameKeyBrowser = t[6],
        this._secretKeyBrowser = t[7],
        this._gameKeyAndroid = t[8],
        this._secretKeyAndroid = t[9],
        this._gameKeyIOS = t[10],
        this._secretKeyIOS = t[11])
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {}
    }
    LoadFromJson() {}
}
,
'use strict',
C3.Plugins.GameAnalytics.Cnds = {
    isRemoteConfigsReady(e) {
        return 'function' == typeof window.GameAnalytics.isRemoteConfigsReady ? (window.GameAnalytics.isRemoteConfigsReady(t=>{
            e && window.c2_callFunction && window.c2_callFunction(e, [t ? 1 : 0])
        }
        ),
        !1) : 'undefined' == typeof window.gameanalytics.GameAnalytics ? (console.log('isRemoteConfigsReady: GameAnalytics object not found'),
        !1) : window.gameanalytics.GameAnalytics.isRemoteConfigsReady()
    }
},
'use strict',
C3.Plugins.GameAnalytics.Acts = {
    addAvailableCustomDimension01(e) {
        this._customDimensions01.push(e)
    },
    addAvailableCustomDimension02(e) {
        this._customDimensions02.push(e)
    },
    addAvailableCustomDimension03(e) {
        this._customDimensions03.push(e)
    },
    addAvailableResourceCurrency(e) {
        this._resourceCurrencies.push(e)
    },
    addAvailableResourceItemType(e) {
        this._resourceItemTypes.push(e)
    },
    initialize() {
		return;  //+ouley

        if ('function' == typeof window.GameAnalytics.initialize) {
            var e = window.GameAnalytics;
            this._enableInfoLog && e.setEnabledInfoLog(!0),
            this._enableVerboseLog && e.setEnabledVerboseLog(!0),
            this._enableManualSessionHandling && e.setEnabledManualSessionHandling(!0),
            0 < this._customDimensions01.length && e.configureAvailableCustomDimensions01(this._customDimensions01),
            0 < this._customDimensions02.length && e.configureAvailableCustomDimensions02(this._customDimensions02),
            0 < this._customDimensions03.length && e.configureAvailableCustomDimensions03(this._customDimensions03),
            0 < this._resourceCurrencies.length && e.configureAvailableResourceCurrencies(this._resourceCurrencies),
            0 < this._resourceItemTypes.length && e.configureAvailableResourceItemTypes(this._resourceItemTypes),
            e.configureBuild(this._build),
            this._autoDetectAppVersion && e.configureAutoDetectAppVersion(!0);
            var t = 'Android' === window.device.platform ? this._gameKeyAndroid : this._gameKeyIOS
              , a = 'Android' === window.device.platform ? this._secretKeyAndroid : this._secretKeyIOS;
            e.initialize({
                gameKey: t,
                secretKey: a,
                sdkVersion: 'construct 3.0.8'
            })
        } else if ('undefined' != typeof window.gameanalytics.GameAnalytics) {
            var e = window.gameanalytics.GameAnalytics;
            this._enableInfoLog && e.setEnabledInfoLog(!0),
            this._enableVerboseLog && e.setEnabledVerboseLog(!0),
            this._enableManualSessionHandling && e.setEnabledManualSessionHandling(!0),
            0 < this._customDimensions01.length && e.configureAvailableCustomDimensions01(this._customDimensions01),
            0 < this._customDimensions02.length && e.configureAvailableCustomDimensions02(this._customDimensions02),
            0 < this._customDimensions03.length && e.configureAvailableCustomDimensions03(this._customDimensions03),
            0 < this._resourceCurrencies.length && e.configureAvailableResourceCurrencies(this._resourceCurrencies),
            0 < this._resourceItemTypes.length && e.configureAvailableResourceItemTypes(this._resourceItemTypes),
            e.configureBuild(this._build),
            e.configureSdkGameEngineVersion('construct 3.0.8'),
            e.initialize(this._gameKeyBrowser, this._secretKeyBrowser)
        } else
            return void console.log('initialize: GameAnalytics object not found')
    },
    addBusinessEvent(e, t, a, n, r) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addBusinessEvent)
            window.GameAnalytics.addBusinessEvent({
                currency: e,
                amount: t,
                itemType: a,
                itemId: n,
                cartType: r
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addBusinessEvent(e, t, a, n, r);
        else
            return void console.log('addBusinessEvent: GameAnalytics object not found')
		*/
    },
    addResourceEvent(e, t, a, n, r) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addResourceEvent)
            window.GameAnalytics.addResourceEvent({
                flowType: e,
                currency: t,
                amount: a,
                itemType: n,
                itemId: r
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addResourceEvent(e, t, a, n, r);
        else
            return void console.log('addResourceEvent: GameAnalytics object not found')
		*/
    },
    addProgressionEvent(e, t, a, n) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addProgressionEvent)
            window.GameAnalytics.addProgressionEvent({
                progressionStatus: e,
                progression01: t,
                progression02: a,
                progression03: n
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addProgressionEvent(e, t, a, n);
        else
            return void console.log('addProgressionEvent: GameAnalytics object not found')
		*/
    },
    addProgressionEventWithScore(e, t, a, n, r) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addProgressionEvent)
            window.GameAnalytics.addProgressionEvent({
                progressionStatus: e,
                progression01: t,
                progression02: a,
                progression03: n,
                score: r
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addProgressionEvent(e, t, a, n, r);
        else
            return void console.log('addProgressionEventWithScore: GameAnalytics object not found')
		*/
    },
    addDesignEvent(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addDesignEvent)
            window.GameAnalytics.addDesignEvent({
                eventId: e
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addDesignEvent(e);
        else
            return void console.log('addDesignEvent: GameAnalytics object not found') 
		*/
    },
    addDesignEventWithValue(e, t) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addDesignEvent)
            window.GameAnalytics.addDesignEvent({
                eventId: e,
                value: t
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addDesignEvent(e, t);
        else
            return void console.log('addDesignEventWithValue: GameAnalytics object not found')
		*/
    },
    addErrorEvent(e, t) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.addErrorEvent)
            window.GameAnalytics.addErrorEvent({
                severity: e,
                message: t
            });
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.addErrorEvent(e, t);
        else
            return void console.log('addErrorEvent: GameAnalytics object not found')
		*/
    },
    setEnabledEventSubmission(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.setEnabledEventSubmission)
            window.GameAnalytics.setEnabledEventSubmission(!!e);
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.setEnabledEventSubmission(!!e);
        else
            return void console.log('setEnabledEventSubmission: GameAnalytics object not found')
		*/
    },
    setEnabledManualSessionHandling(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.setEnabledManualSessionHandling)
            window.GameAnalytics.setEnabledManualSessionHandling(!!e);
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.setEnabledManualSessionHandling(!!e);
        else
            return void console.log('setEnabledManualSessionHandling: GameAnalytics object not found')
		*/
    },
    setCustomDimension01(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.setCustomDimension01)
            window.GameAnalytics.setCustomDimension01(e);
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.setCustomDimension01(e);
        else
            return void console.log('setCustomDimension01: GameAnalytics object not found')
		*/
    },
    setCustomDimension02(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.setCustomDimension02)
            window.GameAnalytics.setCustomDimension02(e);
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.setCustomDimension02(e);
        else
            return void console.log('setCustomDimension02: GameAnalytics object not found')
		*/
    },
    setCustomDimension03(e) {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.setCustomDimension03)
            window.GameAnalytics.setCustomDimension03(e);
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.setCustomDimension03(e);
        else
            return void console.log('setCustomDimension03: GameAnalytics object not found')
		*/
    },
    startSession() {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.startSession)
            window.GameAnalytics.startSession();
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.startSession();
        else
            return void console.log('startSession: GameAnalytics object not found')
		*/
    },
    endSession() {
		/*-ouley
        if ('function' == typeof window.GameAnalytics.endSession)
            window.GameAnalytics.endSession();
        else if ('undefined' != typeof window.gameanalytics.GameAnalytics)
            window.gameanalytics.GameAnalytics.endSession();
        else
            return void console.log('endSession: GameAnalytics object not found')
		*/
    },
    configureBuild(e) {
        this._build = e
    }
},
'use strict',
C3.Plugins.GameAnalytics.Exps = {
    getRemoteConfigsValueAsString(e, t, a) {
		/*-ouley
        return 'function' == typeof window.GameAnalytics.getRemoteConfigsValueAsString ? (window.GameAnalytics.getRemoteConfigsValueAsString({
            key: e,
            defaultValue: t
        }, e=>{
            a && window.c2_callFunction && window.c2_callFunction(a, [e])
        }
        ),
        '') : 'undefined' == typeof window.gameanalytics.GameAnalytics ? (console.log('getRemoteConfigsValueAsString: GameAnalytics object not found'),
        '') : window.gameanalytics.GameAnalytics.getRemoteConfigsValueAsString(e, t)
		*/
		return {};   //+ouley
    },
    getRemoteConfigsContentAsString(e) {
		/*-ouley
        return 'function' == typeof window.GameAnalytics.getRemoteConfigsContentAsString ? (window.GameAnalytics.getRemoteConfigsContentAsString(t=>{
            e && window.c2_callFunction && window.c2_callFunction(e, [t])
        }
        ),
        '') : 'undefined' == typeof window.gameanalytics.GameAnalytics ? (console.log('endSession: GameAnalytics object not found'),
        '') : window.gameanalytics.GameAnalytics.getRemoteConfigsContentAsString()
		*/
		return {};  //+ouley
    }
},
'use strict',
C3.Behaviors.solid = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.solid.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict';
{
    const e = new Set;
    C3.Behaviors.solid.Instance = class extends C3.SDKBehaviorInstanceBase {
        constructor(e, t) {
            super(e),
            this.SetEnabled(!0),
            t && (this.SetEnabled(t[0]),
            this.SetTags(t[1]))
        }
        Release() {
            super.Release()
        }
        SetEnabled(e) {
            this._inst._SetSolidEnabled(!!e)
        }
        IsEnabled() {
            return this._inst._IsSolidEnabled()
        }
        SetTags(e) {
            const t = this._inst.GetSavedDataMap();
            if (!e.trim())
                return void t.delete('solidTags');
            let a = t.get('solidTags');
            a || (a = new Set,
            t.set('solidTags', a)),
            a.clear();
            for (const t of e.split(' '))
                t && a.add(t.toLowerCase())
        }
        GetTags() {
            return this._inst.GetSavedDataMap().get('solidTags') || e
        }
        SaveToJson() {
            return {
                e: this.IsEnabled()
            }
        }
        LoadFromJson(e) {
            this.SetEnabled(e.e)
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this.IsEnabled() : void 0
        }
        SetPropertyValueByIndex(e, t) {
            0 === e ? this.SetEnabled(t) : void 0
        }
        GetDebuggerProperties() {
            return [{
                title: '$' + this.GetBehaviorType().GetName(),
                properties: [{
                    name: 'behaviors.solid.properties.enabled.name',
                    value: this.IsEnabled(),
                    onedit: e=>this.SetEnabled(e)
                }]
            }]
        }
    }
}
'use strict',
C3.Behaviors.solid.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
},
'use strict',
C3.Behaviors.solid.Acts = {
    SetEnabled(e) {
        this.SetEnabled(e)
    },
    SetTags(e) {
        this.SetTags(e)
    }
},
'use strict',
C3.Behaviors.solid.Exps = {},
'use strict',
C3.Behaviors.MoveTo = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.MoveTo.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Behaviors.MoveTo.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(e, t) {
        super(e),
        this._maxSpeed = 200,
        this._acc = 600,
        this._dec = 600,
        this._rotateSpeed = 0,
        this._setAngle = !0,
        this._stopOnSolids = !1,
        this._isEnabled = !0,
        this._speed = 0,
        this._movingAngle = this.GetWorldInfo().GetAngle(),
        this._waypoints = [],
        t && (this._maxSpeed = t[0],
        this._acc = t[1],
        this._dec = t[2],
        this._rotateSpeed = C3.toRadians(t[3]),
        this._setAngle = t[4],
        this._stopOnSolids = t[5],
        this._isEnabled = t[6])
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            ms: this._maxSpeed,
            acc: this._acc,
            dec: this._dec,
            rs: this._rotateSpeed,
            sa: this._setAngle,
            sos: this._stopOnSolids,
            s: this._speed,
            ma: this._movingAngle,
            wp: this._waypoints.map(e=>({
                x: e.x,
                y: e.y
            })),
            e: this._isEnabled
        }
    }
    LoadFromJson(e) {
        this._maxSpeed = e.ms,
        this._acc = e.acc,
        this._dec = e.dec,
        this._rotateSpeed = e.rs,
        this._setAngle = e.sa,
        this._stopOnSolids = e.sos,
        this._speed = e.s,
        this._movingAngle = e.ma,
        this._waypoints = e.wp.map(e=>({
            x: e.x,
            y: e.y
        })),
        this._SetEnabled(e.e),
        this._isEnabled && 0 < this._waypoints.length && this._StartTicking()
    }
    _AddWaypoint(e, t, a) {
        a && C3.clearArray(this._waypoints),
        this._waypoints.push({
            x: e,
            y: t
        }),
        this._isEnabled && this._StartTicking()
    }
    _IsMoving() {
        return 0 < this._waypoints.length
    }
    _Stop() {
        C3.clearArray(this._waypoints),
        this._speed = 0,
        this._StopTicking()
    }
    _GetTargetX() {
        return 0 < this._waypoints.length ? this._waypoints[0].x : 0
    }
    _GetTargetY() {
        return 0 < this._waypoints.length ? this._waypoints[0].y : 0
    }
    _SetSpeed(e) {
        this._IsMoving() && (this._speed = Math.min(e, this._maxSpeed))
    }
    _IsRotationEnabled() {
        return 0 !== this._rotateSpeed
    }
    Tick() {
        var t = Math.sin
          , a = Math.min;
        if (!this._isEnabled || !this._IsMoving())
            return;
        const r = this._runtime.GetDt(this._inst)
          , _ = this._inst.GetWorldInfo()
          , d = _.GetX()
          , e = _.GetY()
          , u = _.GetAngle();
        let c = this._speed
          , S = this._maxSpeed;
        const g = this._acc
          , f = this._dec
          , y = this._GetTargetX()
          , l = this._GetTargetY()
          , m = C3.angleTo(d, e, y, l);
        let n = !1;
        if (0 < f && 1 === this._waypoints.length) {
            const t = 1.0001 * (.5 * c * c / f);
            if (n = C3.distanceSquared(d, e, y, l) <= t * t,
            n) {
                const t = C3.distanceTo(d, e, y, l);
                c = Math.sqrt(2 * f * t),
                S = c,
                this._speed = c
            }
        }
        if (this._IsRotationEnabled()) {
            const n = C3.angleDiff(this._movingAngle, m);
            if (n > Number.EPSILON) {
                const r = n / this._rotateSpeed
                  , e = C3.distanceTo(_.GetX(), _.GetY(), y, l)
                  , i = e / (2 * t(n));
                S = a(S, C3.clamp(i * n / r, 0, this._maxSpeed))
            }
        }
        let G = n ? -f : g;
        const p = a(c * r + .5 * G * r * r, S * r);
        if (!n)
            this._speed = 0 === g ? S : a(this._speed + g * r, S);
        else if (0 < f && (this._speed = Math.max(this._speed - f * r, 0),
        0 === this._speed))
            return void this._OnArrived(_, y, l);
        return C3.distanceSquared(_.GetX(), _.GetY(), y, l) <= p * p ? void this._OnArrived(_, y, l) : void (this._movingAngle = this._IsRotationEnabled() ? C3.angleRotate(this._movingAngle, m, this._rotateSpeed * r) : m,
        _.OffsetXY(Math.cos(this._movingAngle) * p, t(this._movingAngle) * p),
        this._setAngle && _.SetAngle(this._movingAngle),
        _.SetBboxChanged(),
        this._CheckSolidCollision(d, e, u))
    }
    _OnArrived(e, t, a) {
        e.SetXY(t, a),
        e.SetBboxChanged(),
        this._waypoints.shift(),
        0 === this._waypoints.length && (this._speed = 0,
        this._StopTicking()),
        this.Trigger(C3.Behaviors.MoveTo.Cnds.OnArrived)
    }
    _CheckSolidCollision(e, t, a) {
        if (this._stopOnSolids && this._runtime.GetCollisionEngine().TestOverlapSolid(this._inst)) {
            this._Stop();
            const n = this._inst.GetWorldInfo();
            n.SetXY(e, t),
            n.SetAngle(a),
            n.SetBboxChanged(),
            this.Trigger(C3.Behaviors.MoveTo.Cnds.OnHitSolid)
        }
    }
    GetPropertyValueByIndex(e) {
        return 0 === e ? this._maxSpeed : 1 === e ? this._acc : 2 === e ? this._dec : 3 === e ? C3.toDegrees(this._rotateSpeed) : 4 === e ? this._setAngle : 5 === e ? this._stopOnSolids : 6 === e ? this._isEnabled : void 0
    }
    SetPropertyValueByIndex(e, t) {
        0 === e ? this._maxSpeed = t : 1 === e ? this._acc = t : 2 === e ? this._dec = t : 3 === e ? this._rotateSpeed = C3.toRadians(t) : 4 === e ? this._setAngle = t : 5 === e ? this._stopOnSolids = t : 6 === e ? this._SetEnabled(t) : void 0
    }
    _SetEnabled(e) {
        e = !!e,
        this._isEnabled === e || (this._isEnabled = e,
        this._isEnabled && this._IsMoving() ? this._StartTicking() : this._StopTicking())
    }
    GetDebuggerProperties() {
        return [{
            title: '$' + this.GetBehaviorType().GetName(),
            properties: [{
                name: 'behaviors.moveto.debugger.speed',
                value: this._speed,
                onedit: e=>this._SetSpeed(e)
            }, {
                name: 'behaviors.moveto.debugger.angle-of-motion',
                value: C3.toDegrees(this._movingAngle),
                onedit: e=>this._movingAngle = C3.toRadians(e)
            }, {
                name: 'behaviors.moveto.debugger.target-x',
                value: this._GetTargetX()
            }, {
                name: 'behaviors.moveto.debugger.target-y',
                value: this._GetTargetY()
            }, {
                name: 'behaviors.moveto.debugger.waypoint-count',
                value: this._waypoints.length
            }, {
                name: 'behaviors.moveto.properties.max-speed.name',
                value: this._maxSpeed,
                onedit: e=>this._maxSpeed = e
            }, {
                name: 'behaviors.moveto.properties.acceleration.name',
                value: this._acc,
                onedit: e=>this._acc = e
            }, {
                name: 'behaviors.moveto.properties.deceleration.name',
                value: this._dec,
                onedit: e=>this._dec = e
            }, {
                name: 'behaviors.moveto.properties.rotate-speed.name',
                value: C3.toDegrees(this._rotateSpeed),
                onedit: e=>this._rotateSpeed = C3.toRadians(e)
            }, {
                name: 'behaviors.moveto.properties.enabled.name',
                value: this._isEnabled,
                onedit: e=>this._SetEnabled(e)
            }]
        }]
    }
}
,
'use strict',
C3.Behaviors.MoveTo.Cnds = {
    IsMoving() {
        return this._IsMoving()
    },
    CompareSpeed(e, t) {
        return C3.compare(this._speed, e, t)
    },
    IsEnabled() {
        return this._isEnabled
    },
    OnArrived() {
        return !0
    },
    OnHitSolid() {
        return !0
    }
},
'use strict',
C3.Behaviors.MoveTo.Acts = {
    MoveToPosition(e, t, a) {
        this._AddWaypoint(e, t, 0 === a)
    },
    MoveToObject(e, t) {
        if (e) {
            const n = e.GetPairedInstance(this._inst);
            if (n) {
                const e = n.GetWorldInfo();
                e && this._AddWaypoint(e.GetX(), e.GetY(), 0 === t)
            }
        }
    },
    MoveAlongPathfindingPath(e) {
        const t = this._inst.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.Pathfinding);
        if (t) {
            const a = t._GetPath();
            if (0 !== a.length)
                for (let t = 0, n = a.length; t < n; ++t) {
                    const n = a[t];
                    this._AddWaypoint(n.x, n.y, 0 === t && 0 === e)
                }
        }
    },
    MoveAlongTimeline(t, a, n) {
        let r = null;
        if (r = a ? t.GetTrackById(a) : C3.first(t.GetTracks()),
        !r)
            return;
        const l = r.GetPropertyTrack('offsetX')
          , e = r.GetPropertyTrack('offsetY');
        if (!l || !e)
            return;
        const _ = [...l.GetPropertyKeyframeValues()]
          , u = [...e.GetPropertyKeyframeValues()];
        if (0 === _.length || 0 === u.length)
            return;
        let c = 0
          , g = 0;
        const m = this._inst.GetWorldInfo();
        'relative' === l.GetResultMode() && (c = m.GetX()),
        'relative' === e.GetResultMode() && (g = m.GetY());
        for (let r = 0, i = Math.min(_.length, u.length); r < i; ++r) {
            const e = _[r] + c
              , t = u[r] + g;
            this._AddWaypoint(e, t, 0 === r && 0 === n)
        }
    },
    MoveAlongTimelineByName(e, t, a) {
        const n = this._runtime.GetTimelineManager().GetTimelineByName(e);
        n && C3.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, n, t, a)
    },
    Stop() {
        this._Stop()
    },
    SetMovingAngle(e) {
        if (this._movingAngle = C3.toRadians(e),
        this._isEnabled && this._setAngle && !this._IsMoving()) {
            const e = this.GetWorldInfo();
            e.SetAngle(this._movingAngle),
            e.SetBboxChanged()
        }
    },
    SetSpeed(e) {
        this._SetSpeed(e)
    },
    SetMaxSpeed(e) {
        this._maxSpeed = Math.max(e, 0),
        this._SetSpeed(this._speed)
    },
    SetAcceleration(e) {
        this._acc = Math.max(e, 0)
    },
    SetDeceleration(e) {
        this._dec = Math.max(e, 0)
    },
    SetRotateSpeed(e) {
        this._rotateSpeed = Math.max(C3.toRadians(e), 0)
    },
    SetStopOnSolids(e) {
        this._stopOnSolids = !!e
    },
    SetEnabled(e) {
        this._SetEnabled(e)
    }
},
'use strict',
C3.Behaviors.MoveTo.Exps = {
    Speed() {
        return this._speed
    },
    MaxSpeed() {
        return this._maxSpeed
    },
    Acceleration() {
        return this._acc
    },
    Deceleration() {
        return this._dec
    },
    MovingAngle() {
        return C3.toDegrees(this._movingAngle)
    },
    RotateSpeed() {
        return C3.toDegrees(this._rotateSpeed)
    },
    TargetX() {
        return this._GetTargetX()
    },
    TargetY() {
        return this._GetTargetY()
    },
    WaypointCount() {
        return this._waypoints.length
    },
    WaypointXAt(e) {
        return e = Math.floor(e),
        0 > e || e >= this._waypoints.length ? 0 : this._waypoints[e].x
    },
    WaypointYAt(e) {
        return e = Math.floor(e),
        0 > e || e >= this._waypoints.length ? 0 : this._waypoints[e].y
    }
},
'use strict',
C3.Behaviors.Sin = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.Sin.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict';
{
    const t = 2 * Math.PI
      , a = Math.PI / 2
      , n = 3 * Math.PI / 2
      , e = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
    C3.Behaviors.Sin.Instance = class extends C3.SDKBehaviorInstanceBase {
        constructor(a, n) {
            super(a),
            this._i = 0,
            this._movement = 0,
            this._wave = 0,
            this._period = 0,
            this._mag = 0,
            this._isEnabled = !0,
            this._basePeriod = 0,
            this._basePeriodOffset = 0,
            this._baseMag = 0,
            this._periodRandom = 0,
            this._periodOffsetRandom = 0,
            this._magnitudeRandom = 0,
            this._initialValue = 0,
            this._initialValue2 = 0,
            this._lastKnownValue = 0,
            this._lastKnownValue2 = 0,
            this._ratio = 0,
            n && (this._movement = e[n[0]],
            this._wave = n[1],
            this._periodRandom = this._runtime.Random() * n[3],
            this._basePeriod = n[2],
            this._period = n[2],
            this._period += this._periodRandom,
            this._basePeriodOffset = n[4],
            0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * n[5],
            this._i = n[4] / this._period * t,
            this._i += this._periodOffsetRandom / this._period * t),
            this._magnitudeRandom = this._runtime.Random() * n[7],
            this._baseMag = n[6],
            this._mag = n[6],
            this._mag += this._magnitudeRandom,
            this._isEnabled = !!n[8]),
            5 === this._movement && (this._mag = C3.toRadians(this._mag)),
            this.Init(),
            this._isEnabled && this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                i: this._i,
                e: this._isEnabled,
                mv: this._movement,
                w: this._wave,
                p: this._period,
                mag: this._mag,
                iv: this._initialValue,
                iv2: this._initialValue2,
                r: this._ratio,
                lkv: this._lastKnownValue,
                lkv2: this._lastKnownValue2
            }
        }
        LoadFromJson(e) {
            this._i = e.i,
            this._SetEnabled(e.e),
            this._movement = e.mv,
            this._wave = e.w,
            this._period = e.p,
            this._mag = e.mag,
            this._initialValue = e.iv,
            this._initialValue2 = e.iv2,
            this._ratio = e.r,
            this._lastKnownValue = e.lkv,
            this._lastKnownValue2 = e.lkv2
        }
        Init() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
            case 0:
                this._initialValue = e.GetX();
                break;
            case 1:
                this._initialValue = e.GetY();
                break;
            case 2:
                this._initialValue = e.GetWidth(),
                this._ratio = e.GetHeight() / e.GetWidth();
                break;
            case 3:
                this._initialValue = e.GetWidth();
                break;
            case 4:
                this._initialValue = e.GetHeight();
                break;
            case 5:
                this._initialValue = e.GetAngle();
                break;
            case 6:
                this._initialValue = e.GetOpacity();
                break;
            case 7:
                this._initialValue = 0;
                break;
            case 8:
                this._initialValue = e.GetX(),
                this._initialValue2 = e.GetY();
                break;
            case 9:
                this._initialValue = e.GetZElevation();
                break;
            default:
                ;
            }
            this._lastKnownValue = this._initialValue,
            this._lastKnownValue2 = this._initialValue2
        }
        WaveFunc(r) {
            var i = Math.PI;
            switch (r %= t,
            this._wave) {
            case 0:
                return Math.sin(r);
            case 1:
                return r <= a ? r / a : r <= n ? 1 - 2 * (r - a) / i : (r - n) / a - 1;
            case 2:
                return 2 * r / t - 1;
            case 3:
                return -2 * r / t + 1;
            case 4:
                return r < i ? -1 : 1;
            }
            return 0
        }
        Tick() {
            const e = this._runtime.GetDt(this._inst);
            this._isEnabled && 0 !== e && (this._i = 0 === this._period ? 0 : (this._i + e / this._period * t) % t,
            this._UpdateFromPhase())
        }
        _UpdateFromPhase() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
            case 0:
                e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue),
                e.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag),
                this._lastKnownValue = e.GetX();
                break;
            case 1:
                e.GetY() !== this._lastKnownValue && (this._initialValue += e.GetY() - this._lastKnownValue),
                e.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag),
                this._lastKnownValue = e.GetY();
                break;
            case 2:
                e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag),
                e.SetHeight(e.GetWidth() * this._ratio);
                break;
            case 3:
                e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
            case 4:
                e.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
                break;
            case 5:
                e.GetAngle() !== this._lastKnownValue && (this._initialValue = C3.clampAngle(this._initialValue + (e.GetAngle() - this._lastKnownValue))),
                e.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag),
                this._lastKnownValue = e.GetAngle();
                break;
            case 6:
                e.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
                break;
            case 8:
                e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue),
                e.GetY() !== this._lastKnownValue2 && (this._initialValue2 += e.GetY() - this._lastKnownValue2),
                e.SetX(this._initialValue + Math.cos(e.GetAngle()) * this.WaveFunc(this._i) * this._mag),
                e.SetY(this._initialValue2 + Math.sin(e.GetAngle()) * this.WaveFunc(this._i) * this._mag),
                this._lastKnownValue = e.GetX(),
                this._lastKnownValue2 = e.GetY();
                break;
            case 9:
                e.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
            }
            e.SetBboxChanged()
        }
        _OnSpriteFrameChanged() {}
        _SetEnabled(e) {
            this._isEnabled = !!e,
            this._isEnabled ? this._StartTicking() : this._StopTicking()
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this._movement : 1 === e ? this._wave : 2 === e ? this._basePeriod : 6 === e ? this._baseMag : 8 === e ? this._isEnabled : void 0
        }
        SetPropertyValueByIndex(a, n) {
            0 === a ? (this._movement = e[n],
            this.Init()) : 1 === a ? this._wave = n : 2 === a ? (this._basePeriod = n,
            this._period = this._basePeriod + this._periodRandom,
            this._isEnabled || (0 === this._period ? this._i = 0 : (this._i = this._basePeriodOffset / this._period * t,
            this._i += this._periodOffsetRandom / this._period * t))) : 6 === a ? (this._baseMag = n,
            this._mag = this._baseMag + this._magnitudeRandom,
            5 === this._movement && (this._mag = C3.toRadians(this._mag))) : 8 === a ? this._isEnabled = !!n : void 0
        }
        GetDebuggerProperties() {
            return [{
                title: '$' + this.GetBehaviorType().GetName(),
                properties: [{
                    name: 'behaviors.sin.properties.enabled.name',
                    value: this._isEnabled,
                    onedit: e=>this._SetEnabled(e)
                }, {
                    name: 'behaviors.sin.properties.period.name',
                    value: this._period,
                    onedit: e=>this._period = e
                }, {
                    name: 'behaviors.sin.properties.magnitude.name',
                    value: this._mag,
                    onedit: e=>this._mag = e
                }, {
                    name: 'behaviors.sin.debugger.value',
                    value: this.WaveFunc(this._i) * this._mag
                }]
            }]
        }
    }
}
'use strict',
C3.Behaviors.Sin.Cnds = {
    IsEnabled() {
        return this._isEnabled
    },
    CompareMovement(e) {
        return this._movement === e
    },
    ComparePeriod(e, t) {
        return C3.compare(this._period, e, t)
    },
    CompareMagnitude(e, t) {
        return 5 === this._movement ? C3.compare(this._mag, e, C3.toRadians(t)) : C3.compare(this._mag, e, t)
    },
    CompareWave(e) {
        return this._wave === e
    }
},
'use strict',
C3.Behaviors.Sin.Acts = {
    SetEnabled(e) {
        this._SetEnabled(0 !== e)
    },
    SetPeriod(e) {
        this._period = e
    },
    SetMagnitude(e) {
        this._mag = e,
        5 === this._movement && (this._mag = C3.toRadians(this._mag))
    },
    SetMovement(e) {
        5 === this._movement && 5 !== e && (this._mag = C3.toDegrees(this._mag)),
        this._movement = e,
        this.Init()
    },
    SetWave(e) {
        this._wave = e
    },
    SetPhase(e) {
        const t = 2 * Math.PI;
        this._i = e * t % t,
        this._UpdateFromPhase()
    },
    UpdateInitialState() {
        this.Init()
    }
},
'use strict',
C3.Behaviors.Sin.Exps = {
    CyclePosition() {
        return this._i / (2 * Math.PI)
    },
    Period() {
        return this._period
    },
    Magnitude() {
        return 5 === this._movement ? C3.toDegrees(this._mag) : this._mag
    },
    Value() {
        return this.WaveFunc(this._i) * this._mag
    }
},
'use strict',
C3.Behaviors.Rotate = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.Rotate.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Behaviors.Rotate.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(e, t) {
        super(e),
        this._speed = 0,
        this._acceleration = 0,
        this._isEnabled = !0,
        t && (this._speed = C3.toRadians(t[0]),
        this._acceleration = C3.toRadians(t[1]),
        this._isEnabled = t[2]),
        this._isEnabled && this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            s: this._speed,
            a: this._acceleration,
            e: this._isEnabled
        }
    }
    LoadFromJson(e) {
        this._speed = e.s,
        this._acceleration = e.a,
        this._SetEnabled(e.e)
    }
    Tick() {
        if (this._isEnabled) {
            const e = this._runtime.GetDt(this._inst);
            if (0 !== e && (0 !== this._acceleration && (this._speed += this._acceleration * e),
            0 !== this._speed)) {
                const t = this._inst.GetWorldInfo();
                t.SetAngle(t.GetAngle() + this._speed * e),
                t.SetBboxChanged()
            }
        }
    }
    GetPropertyValueByIndex(e) {
        return 0 === e ? C3.toDegrees(this._speed) : 1 === e ? C3.toDegrees(this._acceleration) : 2 === e ? this._isEnabled : void 0
    }
    SetPropertyValueByIndex(e, t) {
        0 === e ? this._speed = C3.toRadians(t) : 1 === e ? this._acceleration = C3.toRadians(t) : 2 === e ? this._SetEnabled(t) : void 0
    }
    _SetEnabled(e) {
        this._isEnabled = !!e,
        this._isEnabled ? this._StartTicking() : this._StopTicking()
    }
    GetDebuggerProperties() {
        return [{
            title: '$' + this.GetBehaviorType().GetName(),
            properties: [{
                name: 'behaviors.rotate.properties.speed.name',
                value: C3.toDegrees(this._speed),
                onedit: e=>this._speed = C3.toRadians(e)
            }, {
                name: 'behaviors.rotate.properties.acceleration.name',
                value: C3.toDegrees(this._acceleration),
                onedit: e=>this._acceleration = C3.toRadians(e)
            }, {
                name: 'behaviors.rotate.properties.enabled.name',
                value: this._isEnabled,
                onedit: e=>this._SetEnabled(e)
            }]
        }]
    }
}
,
'use strict',
C3.Behaviors.Rotate.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
},
'use strict',
C3.Behaviors.Rotate.Acts = {
    SetSpeed(e) {
        this._speed = C3.toRadians(e)
    },
    SetAcceleration(e) {
        this._acceleration = C3.toRadians(e)
    },
    SetEnabled(e) {
        this._SetEnabled(e)
    }
},
'use strict',
C3.Behaviors.Rotate.Exps = {
    Speed() {
        return C3.toDegrees(this._speed)
    },
    Acceleration() {
        return C3.toDegrees(this._acceleration)
    }
},
'use strict',
C3.Behaviors.Fade = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.Fade.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Behaviors.Fade.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(e, t) {
        super(e),
        this._fadeInTime = 0,
        this._waitTime = 0,
        this._fadeOutTime = 0,
        this._destroy = !0,
        this._activeAtStart = !0,
        this._setMaxOpacity = !1,
        this._stage = 0,
        this._stageTime = C3.New(C3.KahanSum),
        this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1,
        t && (this._fadeInTime = t[0],
        this._waitTime = t[1],
        this._fadeOutTime = t[2],
        this._destroy = !!t[3],
        this._activeAtStart = !!t[4],
        this._stage = this._activeAtStart ? 0 : 3),
        this._activeAtStart && (0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender())),
        this._StartTicking()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        return {
            fit: this._fadeInTime,
            wt: this._waitTime,
            fot: this._fadeOutTime,
            d: this._destroy,
            s: this._stage,
            st: this._stageTime.Get(),
            mo: this._maxOpacity
        }
    }
    LoadFromJson(e) {
        this._fadeInTime = e.fit,
        this._waitTime = e.wt,
        this._fadeOutTime = e.fot,
        this._destroy = e.d,
        this._stage = e.s,
        this._stageTime.Set(e.st),
        this._maxOpacity = e.mo
    }
    Tick() {
        const e = this._runtime.GetDt(this._inst);
        this._stageTime.Add(e);
        const t = this._inst.GetWorldInfo();
        0 === this._stage && (t.SetOpacity(this._stageTime.Get() / this._fadeInTime) * this._maxOpacity,
        this._runtime.UpdateRender(),
        t.GetOpacity() >= this._maxOpacity && (t.SetOpacity(this._maxOpacity),
        this._stage = 1,
        this._stageTime.Reset(),
        this.Trigger(C3.Behaviors.Fade.Cnds.OnFadeInEnd))),
        1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2,
        this._stageTime.Reset(),
        this.Trigger(C3.Behaviors.Fade.Cnds.OnWaitEnd)),
        2 === this._stage && 0 !== this._fadeOutTime && (t.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity),
        this._runtime.UpdateRender(),
        0 >= t.GetOpacity() && (this._stage = 3,
        this._stageTime.Reset(),
        this.Trigger(C3.Behaviors.Fade.Cnds.OnFadeOutEnd),
        this._destroy && this._runtime.DestroyInstance(this._inst)))
    }
    Start() {
        this._stage = 0,
        this._stageTime.Reset(),
        0 === this._fadeInTime ? (this._stage = 1,
        0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0),
        this._runtime.UpdateRender())
    }
    GetPropertyValueByIndex(e) {
        return 0 === e ? this._fadeInTime : 1 === e ? this._waitTime : 2 === e ? this._fadeOutTime : 3 === e ? this._destroy : void 0
    }
    SetPropertyValueByIndex(e, t) {
        0 === e ? this._fadeInTime = t : 1 === e ? this._waitTime = t : 2 === e ? this._fadeOutTime = t : 3 === e ? this._destroy = !!t : void 0
    }
    GetDebuggerProperties() {
        return [{
            title: '$' + this.GetBehaviorType().GetName(),
            properties: [{
                name: 'behaviors.fade.properties.fade-in-time.name',
                value: this._fadeInTime,
                onedit: e=>this._fadeInTime = e
            }, {
                name: 'behaviors.fade.properties.wait-time.name',
                value: this._waitTime,
                onedit: e=>this._waitTime = e
            }, {
                name: 'behaviors.fade.properties.fade-out-time.name',
                value: this._fadeOutTime,
                onedit: e=>this._fadeOutTime = e
            }, {
                name: 'behaviors.fade.debugger.stage',
                value: ['behaviors.fade.debugger.' + ['fade-in', 'wait', 'fade-out', 'done'][this._stage]]
            }]
        }]
    }
}
,
'use strict',
C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
},
'use strict',
C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1,
        this._setMaxOpacity = !0),
        3 === this._stage && this.Start()
    },
    RestartFade() {
        this.Start()
    },
    SetFadeInTime(e) {
        0 > e && (e = 0),
        this._fadeInTime = e
    },
    SetWaitTime(e) {
        0 > e && (e = 0),
        this._waitTime = e
    },
    SetFadeOutTime(e) {
        0 > e && (e = 0),
        this._fadeOutTime = e
    }
},
'use strict',
C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._fadeInTime
    },
    WaitTime() {
        return this._waitTime
    },
    FadeOutTime() {
        return this._fadeOutTime
    }
},
'use strict',
C3.Behaviors.scrollto = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e),
        this._shakeMag = 0,
        this._shakeStart = 0,
        this._shakeEnd = 0,
        this._shakeMode = 0
    }
    Release() {
        super.Release()
    }
    SetShakeMagnitude(e) {
        this._shakeMag = e
    }
    GetShakeMagnitude() {
        return this._shakeMag
    }
    SetShakeStart(e) {
        this._shakeStart = e
    }
    GetShakeStart() {
        return this._shakeStart
    }
    SetShakeEnd(e) {
        this._shakeEnd = e
    }
    GetShakeEnd() {
        return this._shakeEnd
    }
    SetShakeMode(e) {
        this._shakeMode = e
    }
    GetShakeMode() {
        return this._shakeMode
    }
}
,
'use strict',
C3.Behaviors.scrollto.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Behaviors.scrollto.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(e, t) {
        super(e),
        this._isEnabled = !0,
        t && (this._isEnabled = t[0]),
        this._isEnabled && this._StartTicking2()
    }
    Release() {
        super.Release()
    }
    SaveToJson() {
        const e = this.GetBehavior();
        return {
            e: this._isEnabled,
            smg: e.GetShakeMagnitude(),
            ss: e.GetShakeStart(),
            se: e.GetShakeEnd(),
            smd: e.GetShakeMode()
        }
    }
    LoadFromJson(e) {
        const t = this.GetBehavior();
        t.SetShakeMagnitude(e.smg),
        t.SetShakeStart(e.ss),
        t.SetShakeEnd(e.se),
        t.SetShakeMode(e.smd),
        this._isEnabled = e.e,
        this._isEnabled ? this._StartTicking2() : this._StopTicking2()
    }
    IsEnabled() {
        return this._isEnabled
    }
    Tick2() {
        if (!this.IsEnabled())
            return;
        const t = this._runtime.GetDt(this._inst)
          , n = this.GetBehavior()
          , r = n.GetInstances();
        let l = 0
          , _ = 0
          , u = 0;
        for (const e of r) {
            const t = e.GetBehaviorInstanceFromCtor(C3.Behaviors.scrollto);
            if (!t || !t.GetSdkInstance().IsEnabled())
                continue;
            const a = e.GetWorldInfo();
            l += a.GetX(),
            _ += a.GetY(),
            ++u
        }
        const a = this._inst.GetWorldInfo().GetLayout()
          , g = this._runtime.GetGameTime();
        let m = 0
          , p = 0;
        if (g >= n.GetShakeStart() && g < n.GetShakeEnd()) {
            let t = n.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1);
            0 === n.GetShakeMode() && (t *= 1 - (g - n.GetShakeStart()) / (n.GetShakeEnd() - n.GetShakeStart()));
            const r = 2 * (this._runtime.Random() * Math.PI)
              , e = this._runtime.Random() * t;
            m = Math.cos(r) * e,
            p = Math.sin(r) * e
        }
        a.SetScrollX(l / u + m),
        a.SetScrollY(_ / u + p)
    }
    GetPropertyValueByIndex(e) {
        return 0 === e ? this._isEnabled : void 0
    }
    SetPropertyValueByIndex(e, t) {
        0 === e ? (this._isEnabled = !!t,
        this._isEnabled ? this._StartTicking2() : this._StopTicking2()) : void 0
    }
}
,
'use strict',
C3.Behaviors.scrollto.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
},
'use strict',
C3.Behaviors.scrollto.Acts = {
    Shake(e, t, a) {
        const n = this.GetBehavior();
        n.SetShakeMagnitude(e),
        n.SetShakeStart(this._runtime.GetGameTime()),
        n.SetShakeEnd(this._runtime.GetGameTime() + t),
        n.SetShakeMode(a)
    },
    SetEnabled(e) {
        this._isEnabled = 0 !== e,
        this._isEnabled ? this._StartTicking2() : this._StopTicking2()
    }
},
'use strict',
C3.Behaviors.scrollto.Exps = {},
'use strict',
C3.Behaviors.jumpthru = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.jumpthru.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict',
C3.Behaviors.jumpthru.Instance = class extends C3.SDKBehaviorInstanceBase {
    constructor(e, t) {
        super(e),
        this.SetEnabled(!0),
        t && this.SetEnabled(t[0])
    }
    Release() {
        super.Release()
    }
    SetEnabled(e) {
        this._inst._SetJumpthruEnabled(!!e)
    }
    IsEnabled() {
        return this._inst._IsJumpthruEnabled()
    }
    SaveToJson() {
        return {
            e: this.IsEnabled()
        }
    }
    LoadFromJson(e) {
        this.SetEnabled(e.e)
    }
    GetPropertyValueByIndex(e) {
        return 0 === e ? this.IsEnabled() : void 0
    }
    SetPropertyValueByIndex(e, t) {
        0 === e ? this.SetEnabled(t) : void 0
    }
    GetDebuggerProperties() {
        return [{
            title: '$' + this.GetBehaviorType().GetName(),
            properties: [{
                name: 'behaviors.jumpthru.properties.enabled.name',
                value: this.IsEnabled(),
                onedit: e=>this.SetEnabled(e)
            }]
        }]
    }
}
,
'use strict',
C3.Behaviors.jumpthru.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
},
'use strict',
C3.Behaviors.jumpthru.Acts = {
    SetEnabled(e) {
        this.SetEnabled(e)
    }
},
'use strict',
C3.Behaviors.jumpthru.Exps = {},
'use strict',
C3.Behaviors.Platform = class extends C3.SDKBehaviorBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
}
,
'use strict',
C3.Behaviors.Platform.Type = class extends C3.SDKBehaviorTypeBase {
    constructor(e) {
        super(e)
    }
    Release() {
        super.Release()
    }
    OnCreate() {}
}
,
'use strict';
{
    function _(t, a, n, r, i) {
        return C3.clamp(t * i + .5 * r * i * i, a * i, n * i)
    }
    C3.Behaviors.Platform.Instance = class extends C3.SDKBehaviorInstanceBase {
        constructor(e, t) {
            super(e),
            this._keyboardDisposables = null,
            this._leftKey = !1,
            this._rightKey = !1,
            this._jumpKey = !1,
            this._jumped = !1,
            this._doubleJumped = !1,
            this._canDoubleJump = !1,
            this._ignoreInput = !1,
            this._simLeft = !1,
            this._simRight = !1,
            this._simJump = !1,
            this._lastFloorObject = null,
            this._loadFloorUid = -1,
            this._lastFloorX = 0,
            this._lastFloorY = 0,
            this._floorIsJumpthru = !1,
            this._wasOnFloor = !1,
            this._wasOverJumpthru = !!this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst),
            this._loadJumpthruUid = -1,
            this._animMode = 'stopped',
            this._fallThrough = 0,
            this._isFirstTick = !0,
            this._dx = 0,
            this._dy = 0,
            this._downX = 0,
            this._downY = 0,
            this._rightX = 0,
            this._rightY = 0,
            this._g = 0,
            this._g1 = 0,
            this._ga = C3.toRadians(90),
            this._maxSpeed = 330,
            this._acc = 1500,
            this._dec = 1500,
            this._jumpStrength = 650,
            this._maxFall = 1e3,
            this._enableDoubleJump = !1,
            this._jumpSustain = 0,
            this._sustainTime = 0,
            this._defaultControls = !0,
            this._ceilingCollisionMode = 0,
            this._isEnabled = !0,
            t && (this._maxSpeed = t[0],
            this._acc = t[1],
            this._dec = t[2],
            this._jumpStrength = t[3],
            this._g = t[4],
            this._maxFall = t[5],
            this._enableDoubleJump = !!t[6],
            this._jumpSustain = t[7] / 1e3,
            this._defaultControls = !!t[8],
            this._isEnabled = !!t[9]);
            const a = this._runtime.Dispatcher();
            this._disposables = new C3.CompositeDisposable(C3.Disposable.From(a, 'instancedestroy', e=>this._OnInstanceDestroyed(e.instance)),C3.Disposable.From(a, 'afterload', ()=>this._OnAfterLoad())),
            this._defaultControls && this._BindEvents(),
            this._isEnabled && this._StartPostTicking(),
            this._UpdateGravity(),
            this._inst.GetUnsavedDataMap().set('isPlatformBehavior', !0)
        }
        Release() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(),
            this._keyboardDisposables = null),
            this._lastFloorObject = null,
            this._wasOverJumpthru = null,
            super.Release()
        }
        _BindEvents() {
            if (!this._keyboardDisposables) {
                const e = this._runtime.Dispatcher();
                this._keyboardDisposables = new C3.CompositeDisposable(C3.Disposable.From(e, 'keydown', e=>this._OnKeyDown(e.data)),C3.Disposable.From(e, 'keyup', e=>this._OnKeyUp(e.data)),C3.Disposable.From(e, 'window-blur', ()=>this._OnWindowBlur()))
            }
        }
        _UnBindEvents() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(),
            this._keyboardDisposables = null)
        }
        _OnInstanceDestroyed(e) {
            this._lastFloorObject === e && (this._lastFloorObject = null),
            this._wasOverJumpthru === e && (this._wasOverJumpthru = null)
        }
        _OnKeyDown(e) {
            switch (e.key) {
            case 'ArrowLeft':
                this._leftKey = !0;
                break;
            case 'ArrowRight':
                this._rightKey = !0;
                break;
            case 'ArrowUp':
                this._jumpKey = !0;
            }
        }
        _OnKeyUp(e) {
            switch (e.key) {
            case 'ArrowLeft':
                this._leftKey = !1;
                break;
            case 'ArrowRight':
                this._rightKey = !1;
                break;
            case 'ArrowUp':
                this._jumpKey = !1,
                this._jumped = !1;
            }
        }
        _OnWindowBlur() {
            this._leftKey = !1,
            this._rightKey = !1,
            this._jumpKey = !1,
            this._jumped = !1
        }
        SaveToJson() {
            return {
                ii: this._ignoreInput,
                lfx: this._lastFloorX,
                lfy: this._lastFloorY,
                lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
                am: this._animMode,
                en: this._isEnabled,
                fall: this._fallThrough,
                ft: this._isFirstTick,
                dx: this._dx,
                dy: this._dy,
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                js: this._jumpStrength,
                g: this._g,
                g1: this._g1,
                mf: this._maxFall,
                wof: this._wasOnFloor,
                woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
                ga: this._ga,
                edj: this._enableDoubleJump,
                cdj: this._canDoubleJump,
                dj: this._doubleJumped,
                sus: this._jumpSustain,
                dc: this._defaultControls,
                cc: this._ceilingCollisionMode
            }
        }
        LoadFromJson(e) {
            this._ignoreInput = e.ii,
            this._lastFloorX = e.lfx,
            this._lastFloorY = e.lfy,
            this._loadFloorUid = e.lfo,
            this._animMode = e.am;
            const t = e.en;
            this._fallThrough = e.fall,
            this._isFirstTick = e.ft,
            this._dx = e.dx,
            this._dy = e.dy,
            this._maxSpeed = e.ms,
            this._acc = e.acc,
            this._dec = e.dec,
            this._jumpStrength = e.js,
            this._g = e.g,
            this._g1 = e.g1,
            this._maxFall = e.mf,
            this._wasOnFloor = e.wof,
            this._loadJumpthruUid = e.woj,
            this._ga = e.ga,
            this._enableDoubleJump = e.edj,
            this._canDoubleJump = e.cdj,
            this._doubleJumped = e.dj,
            this._jumpSustain = e.sus,
            this._defaultControls = e.dc,
            this._ceilingCollisionMode = e.cc || 0,
            this._leftKey = !1,
            this._rightKey = !1,
            this._jumpKey = !1,
            this._jumped = !1,
            this._simLeft = !1,
            this._simRight = !1,
            this._simJump = !1,
            this._sustainTime = 0,
            this._defaultControls ? this._BindEvents() : this._UnBindEvents(),
            this._SetEnabled(t),
            this._UpdateGravity()
        }
        _OnAfterLoad() {
            this._lastFloorObject = -1 === this._loadFloorUid ? null : this._runtime.GetInstanceByUID(this._loadFloorUid),
            this._wasOverJumpthru = -1 === this._loadJumpthruUid ? null : this._runtime.GetInstanceByUID(this._loadJumpthruUid)
        }
        _UpdateGravity() {
            var e = Math.PI
              , t = Math.sin
              , a = Math.cos;
            this._downX = a(this._ga),
            this._downY = t(this._ga),
            this._rightX = a(this._ga - e / 2),
            this._rightY = t(this._ga - e / 2),
            this._downX = C3.round6dp(this._downX),
            this._downY = C3.round6dp(this._downY),
            this._rightX = C3.round6dp(this._rightX),
            this._rightY = C3.round6dp(this._rightY),
            this._g1 = this._g,
            0 > this._g && (this._downX *= -1,
            this._downY *= -1,
            this._g = Math.abs(this._g))
        }
        _GetGDir() {
            return 0 > this._g ? -1 : 1
        }
        _IsOnFloor() {
            const t = this._inst.GetWorldInfo()
              , n = this._runtime.GetCollisionEngine()
              , r = this._inst
              , a = this._lastFloorObject
              , i = t.GetX()
              , e = t.GetY();
            if (t.OffsetXY(this._downX, this._downY),
            t.SetBboxChanged(),
            a && n.TestOverlap(r, a) && (!a.GetObjectClass().HasSolidBehavior() || n.IsSolidCollisionAllowed(a, r)))
                return t.SetXY(i, e),
                t.SetBboxChanged(),
                a;
            else {
                let a = n.TestOverlapSolid(r)
                  , l = null;
                if (a || 0 !== this._fallThrough || (l = n.TestOverlapJumpthru(r, !0)),
                t.SetXY(i, e),
                t.SetBboxChanged(),
                a)
                    return n.TestOverlap(r, a) ? null : (this._floorIsJumpthru = !1,
                    a);
                if (l && l.length) {
                    let t = 0;
                    for (let a = 0, i = l.length; a < i; ++a)
                        l[t] = l[a],
                        n.TestOverlap(r, l[a]) || ++t;
                    if (1 <= t)
                        return this._floorIsJumpthru = !0,
                        l[0]
                }
                return null
            }
        }
        PostTick() {
            if (!this._isEnabled)
                return;
            const t = this._runtime.GetDt(this._inst);
            this._jumpKey || this._simJump || (this._jumped = !1);
            let a = this._leftKey || this._simLeft
              , r = this._rightKey || this._simRight
              , _ = this._jumpKey || this._simJump
              , u = _ && !this._jumped;
            this._simLeft = !1,
            this._simRight = !1,
            this._simJump = !1,
            this._ignoreInput && (a = !1,
            r = !1,
            _ = !1,
            u = !1),
            _ || (this._sustainTime = 0),
            this._HandleFirstTick();
            const [p,f,g] = this._TrackMovingPlatform()
              , h = this._IsOnFloor()
              , i = h && !this._wasOnFloor
              , S = this._MaybePushOutSolid();
            if (S)
                return;
            this._TrackFloor(h, g, p, _),
            u = this._HandleJump(h, u, _),
            h || this._ApplyJumpGravity(u, _, t),
            this._wasOnFloor = !!h;
            const y = this._ApplyHorizontalAcceleration(a, r, t);
            let l = !1
              , G = 0;
            if (0 !== this._dx && (l = this._HandleHorizontalMovement(t, y, h, u)),
            0 !== this._dy) {
                const [e,a] = this._HandleVerticalMovement(t, h);
                l = l || e,
                G = a
            }
            !l && i && 0 > this._dy && 0 < G && (this._dy = 0,
            l = !0),
            this._HandleAnimationTriggers(h, l, u),
            0 < this._fallThrough && this._fallThrough--,
            this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
        }
        _HandleFirstTick() {
            if (this._isFirstTick) {
                const e = this._inst
                  , t = this._runtime.GetCollisionEngine();
                (t.TestOverlapSolid(e) || t.TestOverlapJumpthru(e)) && t.PushOutSolid(e, -this._downX, -this._downY, 4, !0),
                this._isFirstTick = !1
            }
        }
        _TrackMovingPlatform() {
            const t = this._lastFloorObject
              , n = t ? t.GetWorldInfo() : null;
            let r = 0
              , l = 0
              , _ = !1;
            if (t && 0 === this._dy && (n.GetY() !== this._lastFloorY || n.GetX() !== this._lastFloorX)) {
                const e = this._inst
                  , t = e.GetWorldInfo()
                  , a = this._runtime.GetCollisionEngine()
                  , d = n.GetX()
                  , u = n.GetY();
                r = d - this._lastFloorX,
                l = u - this._lastFloorY,
                t.OffsetXY(r, l),
                t.SetBboxChanged(),
                this._lastFloorX = d,
                this._lastFloorY = u,
                _ = !0,
                a.TestOverlapSolid(e) && a.PushOutSolid(e, -r, -l, 2.5 * Math.hypot(r, l))
            }
            return [r, l, _]
        }
        _MaybePushOutSolid() {
            var t = Math.abs;
            const a = this._inst
              , n = a.GetWorldInfo()
              , r = this._runtime.GetCollisionEngine()
              , i = r.TestOverlapSolid(a);
            if (!i)
                return !1;
            const e = t(n.GetWidth())
              , l = t(n.GetHeight());
            return a.GetSavedDataMap().get('inputPredicted') ? (r.PushOutSolid(a, -this._downX, -this._downY, 10, !1),
            !1) : r.PushOutSolidAxis(a, -this._downX, -this._downY, l / 8) ? (r.RegisterCollision(a, i),
            !1) : r.PushOutSolidAxis(a, this._rightX, this._rightY, e / 2) ? (r.RegisterCollision(a, i),
            !1) : r.PushOutSolidAxis(a, this._downX, this._downY, l / 2) ? (r.RegisterCollision(a, i),
            !1) : !r.PushOutSolidNearest(a, Math.max(e, l) / 2) || (r.RegisterCollision(a, i),
            !1)
        }
        _TrackFloor(t, a, n, r) {
            const l = this._inst
              , e = this._runtime.GetCollisionEngine();
            if (t) {
                const r = this._downX
                  , _ = this._downY
                  , d = this._rightX
                  , u = this._rightY;
                if (this._doubleJumped = !1,
                this._canDoubleJump = !1,
                0 < this._dy && (!this._wasOnFloor && (e.PushInFractional(l, -r, -_, t, 16),
                this._wasOnFloor = !0),
                this._dy = 0),
                this._lastFloorObject !== t) {
                    this._lastFloorObject = t;
                    const a = t.GetWorldInfo();
                    this._lastFloorX = a.GetX(),
                    this._lastFloorY = a.GetY(),
                    e.RegisterCollision(l, t)
                } else if (a) {
                    const t = e.TestOverlapSolid(l);
                    t && (e.RegisterCollision(l, t),
                    0 !== n && (0 < n ? e.PushOutSolid(l, -d, -u) : e.PushOutSolid(l, d, u)),
                    e.PushOutSolid(l, -r, -_))
                }
            } else
                r || (this._canDoubleJump = !0)
        }
        _HandleJump(t, a, e) {
            if (t && a || !t && this._enableDoubleJump && e && this._canDoubleJump && !this._doubleJumped) {
                const n = this._inst
                  , r = n.GetWorldInfo()
                  , i = this._runtime.GetCollisionEngine()
                  , e = r.GetX()
                  , l = r.GetY();
                r.OffsetXY(-this._downX, -this._downY),
                r.SetBboxChanged(),
                i.TestOverlapSolid(n) ? a = !1 : (this._sustainTime = this._jumpSustain,
                this.Trigger(C3.Behaviors.Platform.Cnds.OnJump),
                this._animMode = 'jumping',
                this._dy = -this._jumpStrength,
                a = !0,
                t ? this._jumped = !0 : this._doubleJumped = !0),
                r.SetXY(e, l),
                r.SetBboxChanged()
            }
            return a
        }
        _ApplyJumpGravity(e, t, a) {
            t && 0 < this._sustainTime ? (this._dy = -this._jumpStrength,
            this._sustainTime -= a) : (this._lastFloorObject = null,
            this._dy += this._g * a,
            this._dy > this._maxFall && (this._dy = this._maxFall)),
            e && (this._jumped = !0)
        }
        _ApplyHorizontalAcceleration(t, a, n) {
            const r = this._acc
              , i = this._dec;
            t === a && (0 > this._dx ? (this._dx += i * n,
            0 < this._dx && (this._dx = 0)) : 0 < this._dx && (this._dx -= i * n,
            0 > this._dx && (this._dx = 0)));
            let e = 0;
            return t && !a && (0 < this._dx ? e = -(r + i) : e = -r),
            a && !t && (0 > this._dx ? e = r + i : e = r),
            this._dx += e * n,
            this._dx = C3.clamp(this._dx, -this._maxSpeed, this._maxSpeed),
            e
        }
        _HandleHorizontalMovement(S, a, c, d) {
            var e = Math.abs;
            const f = this._inst
              , g = f.GetWorldInfo()
              , h = this._runtime.GetCollisionEngine()
              , i = this._downX
              , y = this._downY
              , G = this._rightX
              , l = this._rightY
              , m = this._maxSpeed;
            let n = !1
              , b = g.GetX()
              , T = g.GetY();
            const I = _(this._dx, -m, m, a, S) * G
              , r = _(this._dx, -m, m, a, S) * l;
            g.OffsetXY(G * (1 < this._dx ? 1 : -1) - i, l * (1 < this._dx ? 1 : -1) - y),
            g.SetBboxChanged();
            let t = !1;
            const C = h.TestOverlapSolid(f);
            g.SetXY(b + I, T + r),
            g.SetBboxChanged();
            let v = h.TestOverlapSolid(f);
            if (!v && c && (v = h.TestOverlapJumpthru(f),
            v && (g.SetXY(b, T),
            g.SetBboxChanged(),
            h.TestOverlap(f, v) ? (v = null,
            t = !1) : t = !0,
            g.SetXY(b + I, T + r),
            g.SetBboxChanged())),
            v) {
                let r = e(this._dx * S) + 2;
                C || !h.PushOutSolid(f, -i, -y, r, t, v) ? (h.RegisterCollision(f, v),
                r = Math.max(e(2.5 * (this._dx * S)), 30),
                h.PushOutSolid(f, G * (0 > this._dx ? 1 : -1), l * (0 > this._dx ? 1 : -1), r, !1) ? c && !t && !this._floorIsJumpthru && (b = g.GetX(),
                T = g.GetY(),
                g.OffsetXY(i, y),
                h.TestOverlapSolid(f) ? !h.PushOutSolid(f, -i, -y, 3, !1) && (g.SetXY(b, T),
                g.SetBboxChanged()) : (g.SetXY(b, T),
                g.SetBboxChanged())) : (g.SetXY(b, T),
                g.SetBboxChanged()),
                !t && (this._dx = 0)) : !C && !d && e(this._dy) < e(this._jumpStrength / 4) && (this._dy = 0,
                !c && (n = !0))
            } else {
                const t = this._IsOnFloor();
                if (c && !t) {
                    const t = Math.ceil(e(this._dx * S)) + 2;
                    b = g.GetX(),
                    T = g.GetY(),
                    g.OffsetXY(i * t, y * t),
                    g.SetBboxChanged(),
                    h.TestOverlapSolid(f) || h.TestOverlapJumpthru(f) ? h.PushOutSolid(f, -i, -y, t + 2, !0) : (g.SetXY(b, T),
                    g.SetBboxChanged())
                } else if (t) {
                    if (!c && this._floorIsJumpthru) {
                        this._lastFloorObject = t;
                        const e = t.GetWorldInfo();
                        this._lastFloorX = e.GetX(),
                        this._lastFloorY = e.GetY(),
                        this._dy = 0,
                        n = !0
                    }
                    0 === this._dy && h.PushInFractional(f, -i, -y, t, 16)
                }
            }
            return n
        }
        _HandleVerticalMovement(t, a) {
            const r = this._inst
              , d = r.GetWorldInfo()
              , u = this._runtime.GetCollisionEngine()
              , e = this._downX
              , c = this._downY;
            let g = !1
              , h = d.GetX()
              , f = d.GetY();
            const l = _(this._dy, -Infinity, this._maxFall, this._g, t);
            d.OffsetXY(l * e, l * c);
            const S = d.GetX()
              , m = d.GetY();
            d.SetBboxChanged();
            let n = u.TestOverlapSolid(r)
              , y = !1;
            if (!n && 0 < this._dy && !a) {
                const t = 0 < this._fallThrough ? null : u.TestOverlapJumpthru(r, !0);
                if (t && t.length) {
                    if (this._wasOverJumpthru) {
                        d.SetXY(h, f),
                        d.SetBboxChanged();
                        let a = 0;
                        for (let n = 0, i = t.length; n < i; ++n)
                            t[a] = t[n],
                            u.TestOverlap(r, t[n]) || ++a;
                        C3.truncateArray(t, a),
                        d.SetXY(S, m),
                        d.SetBboxChanged()
                    }
                    1 <= t.length && (n = t[0])
                }
                y = !!n
            }
            if (n) {
                u.RegisterCollision(r, n),
                this._sustainTime = 0;
                const i = Math.max(Math.abs(1.1 * (this._dy * t)), 2);
                if (!u.PushOutSolid(r, e * (0 > this._dy ? 1 : -1), c * (0 > this._dy ? 1 : -1), i, y, n))
                    d.SetXY(h, f),
                    d.SetBboxChanged(),
                    this._wasOnFloor = !0,
                    y || (this._dy = 0);
                else {
                    this._lastFloorObject = n;
                    const t = n.GetWorldInfo();
                    this._lastFloorX = t.GetX(),
                    this._lastFloorY = t.GetY(),
                    this._floorIsJumpthru = y,
                    y && (g = !0),
                    (0 < this._dy || 0 === this._ceilingCollisionMode) && (this._dy = 0),
                    0 > this._dy && 1 === this._ceilingCollisionMode && u.PushInFractional(r, e, c, n, 32)
                }
            }
            return [g, l]
        }
        _HandleAnimationTriggers(e, t, a) {
            'falling' !== this._animMode && 0 < this._dy && !e && (this.Trigger(C3.Behaviors.Platform.Cnds.OnFall),
            this._animMode = 'falling'),
            (e || t) && 0 <= this._dy && ('falling' === this._animMode || t || a && 0 === this._dy ? (this.Trigger(C3.Behaviors.Platform.Cnds.OnLand),
            this._animMode = 0 === this._dx && 0 === this._dy ? 'stopped' : 'moving') : ('stopped' !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(C3.Behaviors.Platform.Cnds.OnStop),
            this._animMode = 'stopped'),
            'moving' !== this._animMode && (0 !== this._dx || 0 !== this._dy) && !a && (this.Trigger(C3.Behaviors.Platform.Cnds.OnMove),
            this._animMode = 'moving')))
        }
        _CheckIfStandingOnFloor() {
            if (0 !== this._dy)
                return !1;
            const t = this._inst
              , a = this.GetWorldInfo()
              , n = this._runtime.GetCollisionEngine()
              , r = a.GetX()
              , i = a.GetY();
            a.OffsetXY(this._downX, this._downY),
            a.SetBboxChanged();
            const e = n.TestOverlapSolid(t);
            let l = null;
            if (e || 0 !== this._fallThrough || (l = n.TestOverlapJumpthru(t, !0)),
            a.SetXY(r, i),
            a.SetBboxChanged(),
            e)
                return !n.TestOverlap(t, e);
            if (l && l.length) {
                let a = 0;
                for (let r = 0, i = l.length; r < i; ++r)
                    l[a] = l[r],
                    n.TestOverlap(t, l[r]) || a++;
                if (1 <= a)
                    return !0
            }
            return !1
        }
        _IsByWall(t) {
            const a = this._inst
              , n = this.GetWorldInfo()
              , r = this._runtime.GetCollisionEngine()
              , i = n.GetX()
              , e = n.GetY();
            if (0 === t ? n.OffsetXY(2 * -this._rightX, 2 * -this._rightY) : n.OffsetXY(2 * this._rightX, 2 * this._rightY),
            n.SetBboxChanged(),
            !r.TestOverlapSolid(a))
                return n.SetXY(i, e),
                n.SetBboxChanged(),
                !1;
            n.OffsetXY(3 * -this._downX, 3 * -this._downY),
            n.SetBboxChanged();
            const l = !!r.TestOverlapSolid(a);
            return n.SetXY(i, e),
            n.SetBboxChanged(),
            l
        }
        _FallThroughJumpThru() {
            const e = this.GetWorldInfo()
              , t = e.GetX()
              , a = e.GetY();
            e.OffsetXY(this._downX, this._downY),
            e.SetBboxChanged();
            const n = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, !1);
            e.SetXY(t, a),
            e.SetBboxChanged(),
            n && (this._fallThrough = 3,
            this._lastFloorObject = null)
        }
        _ResetDoubleJump(e) {
            this._doubleJumped = !e
        }
        _GetSpeed() {
            return Math.hypot(this._dx, this._dy)
        }
        _GetMovingAngle() {
            return Math.atan2(this._dy, this._dx)
        }
        _IsJumping() {
            return 0 > this._dy
        }
        _IsFalling() {
            return 0 < this._dy
        }
        _SetMaxSpeed(e) {
            this._maxSpeed = Math.max(e, 0)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _SetAcceleration(e) {
            this._acc = Math.max(e, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(e) {
            this._dec = Math.max(e, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _SetJumpStrength(e) {
            this._jumpStrength = Math.max(e, 0)
        }
        _GetJumpStrength() {
            return this._jumpStrength
        }
        _SetMaxFallSpeed(e) {
            this._maxFall = Math.max(e, 0)
        }
        _GetMaxFallSpeed() {
            return this._maxFall
        }
        _SetGravity(e) {
            if (this._g1 !== e) {
                this._g = e,
                this._UpdateGravity();
                const t = this._runtime.GetCollisionEngine()
                  , a = this.GetWorldInfo();
                t.TestOverlapSolid(this._inst) && (t.PushOutSolid(this._inst, this._downX, this._downY, 10),
                a.OffsetXY(2 * this._downX, 2 * this._downY),
                a.SetBboxChanged()),
                this._lastFloorObject = null
            }
        }
        _GetGravity() {
            return this._g
        }
        _SetGravityAngle(e) {
            e = C3.clampAngle(e),
            this._ga === e || (this._ga = e,
            this._UpdateGravity(),
            this._lastFloorObject = null)
        }
        _GetGravityAngle() {
            return this._ga
        }
        _SetDoubleJumpEnabled(e) {
            this._enableDoubleJump = !!e
        }
        _IsDoubleJumpEnabled() {
            return this._enableDoubleJump
        }
        _SetJumpSustain(e) {
            this._jumpSustain = e
        }
        _GetJumpSustain() {
            return this._jumpSustain
        }
        _SetCeilingCollisionMode(e) {
            this._ceilingCollisionMode = e
        }
        _GetCeilingCollisionMode() {
            return this._ceilingCollisionMode
        }
        _SetVectorX(e) {
            this._dx = e
        }
        _GetVectorX() {
            return this._dx
        }
        _SetVectorY(e) {
            this._dy = e
        }
        _GetVectorY() {
            return this._dy
        }
        _SimulateControl(e) {
            this._isEnabled && (0 === e ? this._simLeft = !0 : 1 === e ? this._simRight = !0 : 2 === e ? this._simJump = !0 : void 0)
        }
        _SetDefaultControls(e) {
            e = !!e,
            this._defaultControls === e || (this._defaultControls = e,
            this._defaultControls ? this._BindEvents() : (this._UnBindEvents(),
            this._OnWindowBlur()))
        }
        _IsDefaultControls() {
            return this._defaultControls
        }
        _SetIgnoreInput(e) {
            this._ignoreInput = !!e
        }
        _IsIgnoreInput() {
            return this._ignoreInput
        }
        _SetEnabled(e) {
            e = !!e,
            this._isEnabled === e || (this._isEnabled = e,
            this._isEnabled ? this._StartPostTicking() : (this._StopPostTicking(),
            this._lastFloorObject = null,
            this._simLeft = !1,
            this._simRight = !1,
            this._simJump = !1))
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(e) {
            return 0 === e ? this._GetMaxSpeed() : 1 === e ? this._GetAcceleration() : 2 === e ? this._GetDeceleration() : 3 === e ? this._GetJumpStrength() : 4 === e ? this._GetGravity() : 5 === e ? this._GetMaxFallSpeed() : 6 === e ? this._IsDoubleJumpEnabled() : 7 === e ? 1e3 * this._GetJumpSustain() : 8 === e ? this._IsDefaultControls() : 9 === e ? this._IsEnabled() : void 0
        }
        SetPropertyValueByIndex(e, t) {
            0 === e ? this._SetMaxSpeed(t) : 1 === e ? this._SetAcceleration(t) : 2 === e ? this._SetDeceleration(t) : 3 === e ? this._SetJumpStrength(t) : 4 === e ? this._SetGravity(t) : 5 === e ? this._SetMaxFallSpeed(t) : 6 === e ? this._SetDoubleJumpEnabled(!!t) : 7 === e ? this._SetJumpSustain(t / 1e3) : 8 === e ? this._SetDefaultControls(!!t) : 9 === e ? this._SetEnabled(!!t) : void 0
        }
        GetDebuggerProperties() {
            return [{
                title: '$' + this.GetBehaviorType().GetName(),
                properties: [{
                    name: 'behaviors.platform.debugger.vector-x',
                    value: this._GetVectorX(),
                    onedit: e=>this._SetVectorX(e)
                }, {
                    name: 'behaviors.platform.debugger.vector-y',
                    value: this._GetVectorY(),
                    onedit: e=>this._SetVectorY(e)
                }, {
                    name: 'behaviors.platform.properties.max-speed.name',
                    value: this._GetMaxSpeed(),
                    onedit: e=>this._SetMaxSpeed(e)
                }, {
                    name: 'behaviors.platform.properties.acceleration.name',
                    value: this._GetAcceleration(),
                    onedit: e=>this._SetAcceleration(e)
                }, {
                    name: 'behaviors.platform.properties.deceleration.name',
                    value: this._GetDeceleration(),
                    onedit: e=>this._SetDeceleration(e)
                }, {
                    name: 'behaviors.platform.properties.jump-strength.name',
                    value: this._GetJumpStrength(),
                    onedit: e=>this._SetJumpStrength(e)
                }, {
                    name: 'behaviors.platform.properties.gravity.name',
                    value: this._GetGravity(),
                    onedit: e=>this._SetGravity(e)
                }, {
                    name: 'behaviors.platform.debugger.gravity-angle',
                    value: C3.toDegrees(this._GetGravityAngle()),
                    onedit: e=>this._SetGravityAngle(C3.toRadians(e))
                }, {
                    name: 'behaviors.platform.properties.max-fall-speed.name',
                    value: this._GetMaxFallSpeed(),
                    onedit: e=>this._SetMaxFallSpeed(e)
                }, {
                    name: 'behaviors.platform.debugger.animation-mode',
                    value: ['behaviors.platform.debugger.anim-' + this._animMode]
                }, {
                    name: 'behaviors.platform.properties.enabled.name',
                    value: this._IsEnabled(),
                    onedit: e=>this._SetEnabled(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return IPlatformBehaviorInstance
        }
    }
    ;
    const e = new WeakMap
      , t = new Map([['left', 0], ['right', 1], ['jump', 2]]);
    self.IPlatformBehaviorInstance = class extends IBehaviorInstance {
        constructor() {
            super(),
            e.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())
        }
        fallThrough() {
            e.get(this)._FallThroughJumpThru()
        }
        resetDoubleJump(t) {
            e.get(this)._ResetDoubleJump(!!t)
        }
        simulateControl(n) {
            const a = t.get(n);
            if ('number' != typeof a)
                throw new Error('invalid control');
            e.get(this)._SimulateControl(a)
        }
        get speed() {
            return e.get(this)._GetSpeed()
        }
        get maxSpeed() {
            return e.get(this)._GetMaxSpeed()
        }
        set maxSpeed(t) {
            e.get(this)._SetMaxSpeed(t)
        }
        get acceleration() {
            return e.get(this)._GetAcceleration()
        }
        set acceleration(t) {
            e.get(this)._SetAcceleration(t)
        }
        get deceleration() {
            return e.get(this)._GetDeceleration()
        }
        set deceleration(t) {
            e.get(this)._GetDeceleration(t)
        }
        get jumpStrength() {
            return e.get(this)._GetJumpStrength()
        }
        set jumpStrength(t) {
            e.get(this)._SetJumpStrength(s)
        }
        get maxFallSpeed() {
            return e.get(this)._GetMaxFallSpeed()
        }
        set maxFallSpeed(t) {
            e.get(this)._SetMaxFallSpeed(t)
        }
        get gravity() {
            return e.get(this)._GetGravity()
        }
        set gravity(t) {
            e.get(this)._SetGravity(t)
        }
        get gravityAngle() {
            return e.get(this)._GetGravityAngle()
        }
        set gravityAngle(t) {
            e.get(this)._SetGravityAngle(t)
        }
        get isDoubleJumpEnabled() {
            return e.get(this)._IsDoubleJumpEnabled()
        }
        set isDoubleJumpEnabled(t) {
            e.get(this)._SetDoubleJumpEnabled(!!t)
        }
        get jumpSustain() {
            return e.get(this)._GetJumpSustain()
        }
        set jumpSustain(t) {
            e.get(this)._SetJumpSustain(t)
        }
        get ceilingCollisionMode() {
            const t = e.get(this)._GetCeilingCollisionMode();
            return 0 === t ? 'stop' : 'preserve-momentum'
        }
        set ceilingCollisionMode(t) {
            const a = e.get(this);
            if ('stop' === t)
                a._SetCeilingCollisionMode(0);
            else if ('preserve-momentum' === t)
                a._SetCeilingCollisionMode(1);
            else
                throw new Error('invalid mode')
        }
        get isOnFloor() {
            return e.get(this)._CheckIfStandingOnFloor()
        }
        isByWall(t) {
            const a = e.get(this);
            if ('left' === t)
                return a._IsByWall(0);
            if ('right' === t)
                return a._IsByWall(1);
            throw new Error('invalid side')
        }
        get isJumping() {
            return e.get(this)._IsJumping()
        }
        get isFalling() {
            return e.get(this)._IsFalling()
        }
        get vectorX() {
            return e.get(this)._GetVectorX()
        }
        set vectorX(t) {
            e.get(this)._SetVectorX(t)
        }
        get vectorY() {
            return e.get(this)._GetVectorY()
        }
        set vectorY(t) {
            e.get(this)._SetVectorY(t)
        }
        get isDefaultControls() {
            return e.get(this)._IsDefaultControls()
        }
        set isDefaultControls(t) {
            e.get(this)._SetDefaultControls(!!t)
        }
        get isIgnoringInput() {
            return e.get(this)._IsIgnoreInput()
        }
        set isIgnoringInput(t) {
            e.get(this)._SetIgnoreInput(!!t)
        }
        get isEnabled() {
            return e.get(this)._IsEnabled()
        }
        set isEnabled(t) {
            e.get(this)._SetEnabled(!!t)
        }
    }
}
'use strict',
C3.Behaviors.Platform.Cnds = {
    IsMoving() {
        return 0 !== this._GetVectorX() || 0 !== this._GetVectorY()
    },
    CompareSpeed(e, t) {
        return C3.compare(this._GetSpeed(), e, t)
    },
    IsOnFloor() {
        return this._CheckIfStandingOnFloor()
    },
    IsByWall(e) {
        return this._IsByWall(e)
    },
    IsJumping() {
        return this._IsJumping()
    },
    IsFalling() {
        return this._IsFalling()
    },
    IsDoubleJumpEnabled() {
        return this._IsDoubleJumpEnabled()
    },
    OnJump() {
        return !0
    },
    OnFall() {
        return !0
    },
    OnStop() {
        return !0
    },
    OnMove() {
        return !0
    },
    OnLand() {
        return !0
    },
    IsEnabled() {
        return this._IsEnabled()
    }
},
'use strict',
C3.Behaviors.Platform.Acts = {
    SetMaxSpeed(e) {
        this._SetMaxSpeed(e)
    },
    SetAcceleration(e) {
        this._SetAcceleration(e)
    },
    SetDeceleration(e) {
        this._SetDeceleration(e)
    },
    SetJumpStrength(e) {
        this._SetJumpStrength(e)
    },
    SetMaxFallSpeed(e) {
        this._SetMaxFallSpeed(e)
    },
    SetGravity(e) {
        this._SetGravity(e)
    },
    SimulateControl(e) {
        this._SimulateControl(e)
    },
    SetIgnoreInput(e) {
        this._SetIgnoreInput(!!e)
    },
    SetVectorX(e) {
        this._SetVectorX(e)
    },
    SetVectorY(e) {
        this._SetVectorY(e)
    },
    SetGravityAngle(e) {
        this._SetGravityAngle(C3.toRadians(e))
    },
    SetEnabled(e) {
        this._SetEnabled(0 !== e)
    },
    FallThrough() {
        this._FallThroughJumpThru()
    },
    SetDoubleJumpEnabled(e) {
        this._SetDoubleJumpEnabled(0 !== e)
    },
    SetJumpSustain(e) {
        this._SetJumpSustain(e / 1e3)
    },
    SetCeilingCollision(e) {
        this._SetCeilingCollisionMode(e)
    },
    SetDefaultControls(e) {
        this._SetDefaultControls(e)
    },
    ResetDoubleJump(e) {
        this._ResetDoubleJump(e)
    }
},
'use strict',
C3.Behaviors.Platform.Exps = {
    Speed() {
        return this._GetSpeed()
    },
    MaxSpeed() {
        return this._GetMaxSpeed()
    },
    Acceleration() {
        return this._GetAcceleration()
    },
    Deceleration() {
        return this._GetDeceleration()
    },
    JumpStrength() {
        return this._GetJumpStrength()
    },
    Gravity() {
        return this._GetGravity()
    },
    GravityAngle() {
        return C3.toDegrees(this._GetGravityAngle())
    },
    MaxFallSpeed() {
        return this._GetMaxFallSpeed()
    },
    MovingAngle() {
        return C3.toDegrees(this._GetMovingAngle())
    },
    VectorX() {
        return this._GetVectorX()
    },
    VectorY() {
        return this._GetVectorY()
    },
    JumpSustain() {
        return 1e3 * this._GetJumpSustain()
    }
},
'use strict',
self.C3_GetObjectRefTable = function() {
    return [C3.Plugins.Sprite, C3.Behaviors.solid, C3.Behaviors.MoveTo, C3.Behaviors.Sin, C3.Behaviors.Rotate, C3.Behaviors.Fade, C3.Behaviors.scrollto, C3.Plugins.TiledBg, C3.Plugins.Spritefont2, C3.Plugins.LocalStorage, C3.Plugins.Mouse, C3.Plugins.progressbar, C3.Plugins.Text, C3.Plugins.Touch, C3.Plugins.Audio, C3.Plugins.Keyboard, C3.Plugins.Tilemap, C3.Behaviors.jumpthru, C3.Plugins.GD_SDK, C3.Plugins.GameAnalytics, C3.Behaviors.Platform, C3.Plugins.System.Cnds.IsGroupActive, C3.Plugins.GD_SDK.Cnds.PauseGame, C3.Plugins.Audio.Acts.SetSilent, C3.Plugins.System.Acts.SetTimescale, C3.Plugins.GD_SDK.Cnds.ResumeGame, C3.Behaviors.Platform.Cnds.OnStop, C3.Plugins.Sprite.Cnds.IsOverlapping, C3.Plugins.System.Acts.SetBoolVar, C3.Plugins.Sprite.Acts.SetAnim, C3.Behaviors.Sin.Acts.SetMovement, C3.Behaviors.Sin.Acts.SetMagnitude, C3.Behaviors.Sin.Acts.SetPeriod, C3.Behaviors.Platform.Acts.SetEnabled, C3.Plugins.Sprite.Acts.SetCollisions, C3.Plugins.Sprite.Acts.SetBoolInstanceVar, C3.Plugins.Audio.Acts.Play, C3.Plugins.System.Acts.Wait, C3.Plugins.Sprite.Acts.SetVisible, C3.Behaviors.MoveTo.Acts.MoveToPosition, C3.Plugins.Sprite.Exps.X, C3.Plugins.Sprite.Exps.Y, C3.Behaviors.MoveTo.Cnds.OnArrived, C3.Plugins.Sprite.Cnds.IsBoolInstanceVarSet, C3.Plugins.Sprite.Acts.SetOpacity, C3.Plugins.Sprite.Cnds.IsOverlappingOffset, C3.Plugins.Sprite.Cnds.CompareInstanceVar, C3.Plugins.Sprite.Acts.SetInstanceVar, C3.Plugins.Sprite.Cnds.CompareX, C3.Behaviors.solid.Acts.SetEnabled, C3.Behaviors.scrollto.Acts.Shake, C3.Plugins.System.Cnds.OnLayoutStart, C3.Plugins.Sprite.Cnds.OnCollision, C3.Behaviors.Rotate.Acts.SetEnabled, C3.Plugins.Sprite.Cnds.IsVisible, C3.Plugins.System.Cnds.CompareBoolVar, C3.Plugins.Sprite.Cnds.IsAnimPlaying, C3.Plugins.System.Cnds.Compare, C3.Plugins.Sprite.Exps.Width, C3.Plugins.Sprite.Acts.SetPos, C3.Plugins.Sprite.Acts.SetMirrored, C3.Behaviors.MoveTo.Cnds.IsMoving, C3.Behaviors.Fade.Acts.StartFade, C3.Plugins.Sprite.Acts.Destroy, C3.Plugins.Sprite.Acts.AddInstanceVar, C3.Plugins.Sprite.Acts.MoveToLayer, C3.Behaviors.Rotate.Acts.SetSpeed, C3.Plugins.System.Exps.random, C3.Behaviors.Sin.Acts.SetEnabled, C3.Plugins.Sprite.Acts.SetSize, C3.Plugins.System.Acts.SetGroupActive, C3.Plugins.System.Cnds.EveryTick, C3.Plugins.Sprite.Acts.MoveToBottom, C3.Plugins.Sprite.Acts.SetAngle, C3.Plugins.Sprite.Cnds.IsBetweenAngles, C3.Plugins.Sprite.Cnds.PickByUID, C3.Plugins.Sprite.Exps.UID, C3.Plugins.Sprite.Acts.SubInstanceVar, C3.Plugins.Touch.Cnds.IsInTouch, C3.Plugins.Touch.Exps.Y, C3.Plugins.Sprite.Cnds.CompareY, C3.Behaviors.MoveTo.Acts.SetMaxSpeed, C3.Plugins.Keyboard.Cnds.IsKeyDown, C3.Plugins.Touch.Cnds.OnTouchStart, C3.Behaviors.Platform.Cnds.IsMoving, C3.Plugins.Touch.Exps.X, C3.Behaviors.Platform.Acts.SimulateControl, C3.Behaviors.Platform.Cnds.OnMove, C3.Behaviors.Platform.Cnds.OnLand, C3.Behaviors.Platform.Exps.Speed, C3.Plugins.System.Cnds.CompareVar, C3.Plugins.System.Acts.AddVar, C3.Plugins.LocalStorage.Acts.SetItem, C3.Plugins.GameAnalytics.Acts.addProgressionEventWithScore, C3.Plugins.GameAnalytics.Acts.addDesignEventWithValue, C3.Plugins.System.Cnds.ForEach, C3.Plugins.System.Acts.GoToLayout, C3.Plugins.Spritefont2.Acts.SetText, C3.Plugins.Sprite.Acts.SetX, C3.Plugins.System.Acts.SubVar, C3.Plugins.System.Acts.SetVar, C3.Plugins.System.Acts.CreateObject, C3.Behaviors.Platform.Cnds.IsFalling, C3.Behaviors.Platform.Cnds.IsOnFloor, C3.Plugins.Touch.Cnds.OnTapGestureObject, C3.Plugins.System.Acts.RestartLayout, C3.Plugins.GD_SDK.Acts.ShowAd, C3.Behaviors.Platform.Acts.SetJumpStrength, C3.Plugins.System.Exps.layoutname, C3.Plugins.Sprite.Cnds.IsMirrored, C3.Plugins.Sprite.Acts.SetPosToObject, C3.Plugins.LocalStorage.Acts.RemoveItem, C3.Plugins.Sprite.Cnds.IsOnLayer, C3.Behaviors.MoveTo.Acts.SetDeceleration, C3.Behaviors.MoveTo.Acts.SetAcceleration, C3.Plugins.Sprite.Exps.ObjectTypeName, C3.Plugins.System.Cnds.PickLastCreated, C3.Plugins.System.Acts.CreateObjectByName, C3.Plugins.System.Acts.Signal, C3.Plugins.System.Cnds.PickOverlappingPoint, C3.Plugins.System.Acts.WaitForSignal, C3.Plugins.Sprite.Acts.SetY, C3.Plugins.Sprite.Acts.SetEffectParam, C3.Plugins.GameAnalytics.Acts.addDesignEvent, C3.Plugins.LocalStorage.Acts.CheckItemExists, C3.Behaviors.scrollto.Acts.SetEnabled, C3.Plugins.Sprite.Exps.Height, C3.Plugins.System.Cnds.ObjectUIDExists, C3.Plugins.LocalStorage.Cnds.OnItemMissing, C3.Plugins.LocalStorage.Cnds.OnItemExists, C3.Plugins.LocalStorage.Exps.ItemValue, C3.Plugins.System.Acts.GoToLayoutByName, C3.Plugins.GameAnalytics.Acts.initialize, C3.Plugins.TiledBg.Acts.SetWidth, C3.Plugins.System.Exps.loadingprogress, C3.Plugins.System.Cnds.OnLoadFinished]
}
,
self.C3_JsPropNameTable = [{
    twin: 0
}, {
    code: 0
}, {
    Variable1: 0
}, {
    Solid: 0
}, {
    MoveTo: 0
}, {
    barrierstone: 0
}, {
    action: 0
}, {
    Sine: 0
}, {
    brontoleg: 0
}, {
    key: 0
}, {
    doorstone3key: 0
}, {
    Rotate: 0
}, {
    gate1: 0
}, {
    sticksbutton: 0
}, {
    Fade: 0
}, {
    phase: 0
}, {
    waitfornextclimb: 0
}, {
    ladder: 0
}, {
    Lever1: 0
}, {
    floor: 0
}, {
    floor1: 0
}, {
    floor2: 0
}, {
    lift: 0
}, {
    set: 0
}, {
    triceraptorrope: 0
}, {
    var: 0
}, {
    sticks: 0
}, {
    teleporting: 0
}, {
    teleport1: 0
}, {
    teleport2: 0
}, {
    waitfornextclimbup: 0
}, {
    waitfornextclimbdown: 0
}, {
    Treetrunk: 0
}, {
    woodenbridge: 0
}, {
    gatekey: 0
}, {
    given: 0
}, {
    stuffrequesting: 0
}, {
    stuffrewarding: 0
}, {
    keytaken: 0
}, {
    gatekeylock: 0
}, {
    ticks: 0
}, {
    sizemushroom: 0
}, {
    totem: 0
}, {
    trap: 0
}, {
    lifttrice: 0
}, {
    init_y: 0
}, {
    release: 0
}, {
    Sine2: 0
}, {
    feather: 0
}, {
    barriercircle: 0
}, {
    barriercircle_button: 0
}, {
    turtlenotmoved: 0
}, {
    canmoveright: 0
}, {
    canmoveleft: 0
}, {
    turtle: 0
}, {
    direction: 0
}, {
    agressive: 0
}, {
    triceraptorhead: 0
}, {
    timer: 0
}, {
    cobra: 0
}, {
    brontohead: 0
}, {
    flower: 0
}, {
    cloud1: 0
}, {
    cloud2: 0
}, {
    flowergrowing: 0
}, {
    houseyellow: 0
}, {
    plantcarrot: 0
}, {
    plantdirt: 0
}, {
    plantflower: 0
}, {
    plantmushroomgreen: 0
}, {
    plantpalm1: 0
}, {
    treepalm: 0
}, {
    treepalm2: 0
}, {
    treeprehist: 0
}, {
    grass: 0
}, {
    blackman: 0
}, {
    cleo: 0
}, {
    cleobath: 0
}, {
    man1: 0
}, {
    manbad: 0
}, {
    manblack2: 0
}, {
    manblackshaking: 0
}, {
    manguard: 0
}, {
    maninmask: 0
}, {
    manslave: 0
}, {
    manslavecleo: 0
}, {
    mummy: 0
}, {
    mummything: 0
}, {
    unfreezing: 0
}, {
    sleepingman: 0
}, {
    firsttimetouch: 0
}, {
    winterman: 0
}, {
    taken: 0
}, {
    name: 0
}, {
    movingintoinventary: 0
}, {
    tutorial: 0
}, {
    axe: 0
}, {
    bow: 0
}, {
    movingdown: 0
}, {
    takenrewarding: 0
}, {
    bowl: 0
}, {
    bowl2: 0
}, {
    cheese: 0
}, {
    eggs: 0
}, {
    garlic: 0
}, {
    mask: 0
}, {
    rope: 0
}, {
    scissors: 0
}, {
    shorts: 0
}, {
    socks: 0
}, {
    hummer: 0
}, {
    table: 0
}, {
    tooththing: 0
}, {
    waterthing: 0
}, {
    skull: 0
}, {
    box: 0
}, {
    flything: 0
}, {
    flowerred: 0
}, {
    heart: 0
}, {
    Leverrewarding: 0
}, {
    gatekeyKeyBlue: 0
}, {
    gatekeyKeyBrown: 0
}, {
    gatekeyKeyGreen: 0
}, {
    gatekeyKeyRed: 0
}, {
    triceraptorbody: 0
}, {
    gavefruit: 0
}, {
    fruiter: 0
}, {
    dinogreen: 0
}, {
    dinolittle: 0
}, {
    dinosss: 0
}, {
    trexbody: 0
}, {
    trexhead: 0
}, {
    trexlittle: 0
}, {
    crocodile: 0
}, {
    crocodilebath: 0
}, {
    flyingdino: 0
}, {
    flyingdinobg: 0
}, {
    cat: 0
}, {
    Sprite25: 0
}, {
    crocodile2: 0
}, {
    talking: 0
}, {
    live: 0
}, {
    fallingcounter: 0
}, {
    mushroomcounter: 0
}, {
    minisized: 0
}, {
    movingturtle: 0
}, {
    Adam: 0
}, {
    adamevehouse: 0
}, {
    touched: 0
}, {
    touched2: 0
}, {
    AdamOrEveAtEndLevel: 0
}, {
    Eve: 0
}, {
    mouth: 0
}, {
    takencollect: 0
}, {
    collectapple: 0
}, {
    collectpear: 0
}, {
    EveStatic: 0
}, {
    collectbanana2: 0
}, {
    collectbanana: 0
}, {
    showing: 0
}, {
    Bubble: 0
}, {
    Bubbletutorial: 0
}, {
    gear: 0
}, {
    arrow: 0
}, {
    ScrollTo: 0
}, {
    camerainmenu: 0
}, {
    started: 0
}, {
    hand: 0
}, {
    keytutorial: 0
}, {
    levelmapbutton: 0
}, {
    LoadingBar: 0
}, {
    LoadingFont: 0
}, {
    LocalStorage: 0
}, {
    Mouse: 0
}, {
    level: 0
}, {
    playbutton: 0
}, {
    playbuttonshadow: 0
}, {
    playsymbol: 0
}, {
    ProgressBar: 0
}, {
    score: 0
}, {
    Text: 0
}, {
    Touch: 0
}, {
    Audio: 0
}, {
    Keyboard: 0
}, {
    logo: 0
}, {
    logofunctu: 0
}, {
    mantutorial: 0
}, {
    Adamstatic: 0
}, {
    givingeffect: 0
}, {
    invisibleforce: 0
}, {
    invisibleforce2: 0
}, {
    camerainlevel1and2: 0
}, {
    TiledBackground: 0
}, {
    TiledBackground10: 0
}, {
    TiledBackground11: 0
}, {
    TiledBackground2: 0
}, {
    TiledBackground3: 0
}, {
    TiledBackground4: 0
}, {
    TiledBackground5: 0
}, {
    TiledBackground7: 0
}, {
    TiledBackground8: 0
}, {
    TiledBackground9: 0
}, {
    Jumpthru: 0
}, {
    Tilemap: 0
}, {
    footstep: 0
}, {
    GameDistributionSDK: 0
}, {
    snura: 0
}, {
    arrow2: 0
}, {
    Sprite2: 0
}, {
    arrow3: 0
}, {
    fruit: 0
}, {
    Sprite3: 0
}, {
    mamut: 0
}, {
    mamutthing: 0
}, {
    fire: 0
}, {
    woodcut: 0
}, {
    wintertree: 0
}, {
    fire2: 0
}, {
    smallstone: 0
}, {
    question: 0
}, {
    zzz: 0
}, {
    arrow4: 0
}, {
    Sprite: 0
}, {
    egg: 0
}, {
    aaeboard: 0
}, {
    Text2: 0
}, {
    Text3: 0
}, {
    GameAnalytics: 0
}, {
    arrow5: 0
}, {
    MoveToC: 0
}, {
    collect: 0
}, {
    MoveTo2: 0
}, {
    stuffasking: 0
}, {
    askers: 0
}, {
    Platform: 0
}, {
    heroes: 0
}, {
    numberFruit: 0
}, {
    levelReached: 0
}, {
    numberAllFruit: 0
}, {
    currentLevel: 0
}, {
    keygreen: 0
}, {
    keyred: 0
}, {
    keybrown: 0
}, {
    keyblue: 0
}, {
    heroWorks: 0
}],
'use strict';
{
    function e(e, t) {
        var a = Math.round;
        if ('string' == typeof e || 'string' == typeof t) {
            let n, r;
            return n = 'number' == typeof e ? (a(1e10 * e) / 1e10).toString() : e,
            r = 'number' == typeof t ? (a(1e10 * t) / 1e10).toString() : t,
            n + r
        }
        return e && t ? 1 : 0
    }
    self.C3_ExpressionFuncs = [()=>'GD', ()=>0, ()=>1, ()=>'Teleport', ()=>'blinking', ()=>-50, ()=>.1, ()=>'stand', ()=>'', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject()
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 18
    }
    , ()=>.5, ()=>-1, ()=>.7, ()=>100, ()=>'on', ()=>'off', ()=>'Brontoleg', ()=>35, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 100
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 100
    }
    , ()=>6, ()=>.4, ()=>2, ()=>'Gate wooden lever', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpInstVar()
    }
    , ()=>'Gate key 4 colors', ()=>'blue', ()=>'closed', ()=>'open', ()=>'brown', ()=>'red', ()=>'green', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 54
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 7
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 54
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 7
    }
    , ()=>'Door stone 3 key', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 44
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 6
    }
    , ()=>'pink', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 46
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 35
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 24
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 20
    }
    , ()=>'redin', ()=>'pinkin', ()=>'bluein', ()=>3, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 133
    }
    , ()=>.25, ()=>'Bridge Twin Totem', ()=>-10, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 70
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 70
    }
    , ()=>'Bridge Old Wooden', ()=>.3, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 200
    }
    , e=>{
        const t = e._GetNode(0).GetBoundMethod();
        return ()=>t(-300, 300)
    }
    , ()=>'Mushroom Sizing', ()=>60, ()=>61, ()=>'Talking', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpInstVar_Family()
    }
    , ()=>146, ()=>150, ()=>'Sticks', ()=>'Animation 2', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 110
    }
    , ()=>'Animation 1', ()=>'Triceraptor', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 23
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 19
    }
    , ()=>.01, ()=>20, ()=>65, ()=>70, ()=>-500, ()=>500, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 25
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 44
    }
    , ()=>40, ()=>'Lift', ()=>'move', ()=>'still', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 3
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 148
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 55
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 81
    }
    , ()=>'Ladder', ()=>'walk', e=>{
        const t = e._GetNode(0).GetBoundMethod();
        return ()=>t()
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 150
    }
    , ()=>'lc', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 260
    }
    , ()=>700, ()=>1e3, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 260
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 10
    }
    , ()=>'Tree Trunk', ()=>30, ()=>'Plants', ()=>'(game) Movement', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 40
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 40
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpBehavior()
    }
    , ()=>.05, ()=>'(game) Victory', e=>{
        const t = e._GetNode(0).GetVar();
        return ()=>t.GetValue()
    }
    , ()=>'levelReached', t=>{
        const a = t._GetNode(0).GetVar();
        return ()=>e('LevelReachedProgression', a.GetValue())
    }
    , ()=>'LevelReachedDesign', ()=>300, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 46
    }
    , e=>{
        const t = e._GetNode(0)
          , a = e._GetNode(1).GetBoundMethod()
          , n = e._GetNode(2).GetVar();
        return ()=>t.ExpObject() - 300 - a(40 * n.GetValue())
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 108
    }
    , e=>{
        const t = e._GetNode(0).GetVar();
        return ()=>.13 * t.GetValue()
    }
    , ()=>'numberAllFruit', ()=>180, ()=>5, ()=>4, ()=>'(game) Death Function', ()=>'fall', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 1e3
    }
    , ()=>.8, ()=>8, ()=>350, ()=>200, ()=>470, ()=>120, ()=>14, ()=>9, ()=>'(game) Immediately After Start', ()=>220, ()=>'Hero', ()=>-13, ()=>'Camera higher in Level1,2', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 300
    }
    , ()=>'mouth', ()=>'Collect', e=>{
        const t = e._GetNode(0)
          , a = e._GetNode(1).GetBoundMethod();
        return ()=>t.ExpObject() - 300 - a(500)
    }
    , ()=>10, ()=>'Cheats', ()=>'Tutorial', ()=>519, ()=>580, ()=>644, ()=>549, ()=>215, ()=>95, ()=>-215, ()=>1500, ()=>-644, ()=>1059, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 180
    }
    , ()=>'Inventory & Asking', ()=>800, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 80
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 200
    }
    , ()=>7, e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 140
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>'' + t.ExpInstVar_Family()
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 130
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 190
    }
    , ()=>600, ()=>'talking', ()=>-8, ()=>'destroy stuff in bubble', ()=>'Grass', ()=>.2, ()=>'Trap and Feather', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 5e3
    }
    , ()=>'trapping', ()=>'FlyingDinos', ()=>3e3, ()=>131, ()=>-2e3, ()=>-1e3, ()=>4e3, ()=>-4e3, ()=>380, ()=>'Cobra', ()=>'sleep', ()=>50, ()=>'STORY: Level Mamut Freezing Man', ()=>436, ()=>33, ()=>2153, ()=>34, ()=>1267, ()=>'AdjustHSL', ()=>1272, ()=>1015, ()=>1243, ()=>1296, ()=>'Turtle & Barrier Circle', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 60
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 60
    }
    , ()=>'go', ()=>'down', ()=>'up', ()=>'STORY: Level Cleopatra', ()=>'STORY: Winter 2 Lever Reqarding', ()=>11, ()=>'STORY: T-Rex Big Flower', ()=>763, ()=>'13levelTouchTrex', ()=>'Dinogreen', e=>{
        const t = e._GetNode(0)
          , a = e._GetNode(1).GetBoundMethod();
        return ()=>t.ExpObject() + a(500)
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 10
    }
    , e=>{
        const t = e._GetNode(0)
          , a = e._GetNode(1).GetBoundMethod();
        return ()=>t.ExpObject() - a(500)
    }
    , ()=>'STORY: Level Crocodile', ()=>'play', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 120
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 120
    }
    , ()=>3111, ()=>3079, ()=>'T-rex Little', e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() + 1e4
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 1e4
    }
    , ()=>239, ()=>983, ()=>88, ()=>-12, ()=>'MainPlayButton', t=>{
        const a = t._GetNode(0);
        return ()=>e('', a.ExpInstVar())
    }
    , e=>{
        const t = e._GetNode(0).GetVar();
        return ()=>t.GetValue() - 1
    }
    , e=>{
        const t = e._GetNode(0);
        return ()=>t.ExpObject() - 75
    }
    , ()=>'Cheats-levelmap', ()=>'GD2', ()=>'Menu', e=>{
        const t = e._GetNode(0).GetBoundMethod();
        return ()=>Math.round(201 * t())
    }
    ]
}
{
    self.C3.ScriptsInEvents = {}
}
